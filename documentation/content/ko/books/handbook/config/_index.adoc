---
description: '이 장에서는 FreeBSD 시스템을 튜닝하기 위해 설정할 수 있는 몇 가지 파라미터를 포함하여 FreeBSD 구성 프로세스의 대부분을 설명합니다.'
next: books/handbook/boot
part: '파트 III. 시스템 관리'
path: /books/handbook/
prev: books/handbook/partiii
showBookMenu: 'true'
tags: ["configuration", "tuning", "services", "cron", "virtual hosts", "logging", "configuration files", "sysctl", "tuning disks", "kernel limits", "swap", "power management"]
title: '13장. 구성 및 튜닝'
weight: 17
---

[[config-tuning]]
= 구성 및 튜닝
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 13
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/config/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[config-synopsis]]
== 요약

FreeBSD의 중요한 측면 중 하나는 적절한 시스템 구성입니다. 이 장에서는 FreeBSD 시스템을 튜닝하기 위해 설정할 수 있는 몇 가지 파라미터를 포함하여 FreeBSD 구성 프로세스의 대부분을 설명합니다.

이 장을 읽고 나면 다음을 알 수 있습니다:

* [.filename]#rc.conf# 구성 및 [.filename]#/usr/local/etc/rc.d# 시작 스크립트의 기본.
* 네트워크 카드를 구성하고 테스트하는 방법.
* 네트워크 장치에서 가상 호스트를 구성하는 방법.
* [.filename]#/etc# 에 있는 다양한 설정 파일을 사용하는 방법.
* man:sysctl[8] 변수를 사용하여 FreeBSD를 튜닝하는 방법.
* 디스크 성능을 조정하고 커널 제한을 수정하는 방법.

이 챕터를 읽기 전에 알아두어야 할 사항입니다:

* UNIX(R) 및 FreeBSD 기본 사항을 이해합니다(crossref:basics[basics,FreeBSD Basics]).
* 커널 구성 및 컴파일의 기본 사항에 익숙해야 합니다 (crossref:kernelconfig[kernelconfig,Configuring the FreeBSD Kernel]).

[[configtuning-starting-services]]
== 서비스 시작하기

많은 사용자가 포트 컬렉션에서 타사 소프트웨어를 FreeBSD에 설치하며, 시스템 초기화 시 설치된 서비스가 시작되도록 요구합니다. package:mail/postfix[] 또는 package:www/apache22[]와 같은 서비스는 시스템 초기화 중에 시작될 수 있는 많은 소프트웨어 패키지 중 두 가지에 불과합니다. 이 섹션에서는 타사 소프트웨어를 시작할 때 사용할 수 있는 절차에 대해 설명합니다.

FreeBSD에서는 man:cron[8]과 같은 대부분의 기본 제공 서비스가 시스템 시작 스크립트를 통해 시작됩니다.

=== 확장된 애플리케이션 구성

이제 FreeBSD에 [.filename]#rc.d# 가 포함되었으므로, 애플리케이션 시작을 구성하는 것이 더 쉬워지고 더 많은 기능을 제공합니다. <<configtuning-rcd>> 에 설명된 키워드를 사용하여 애플리케이션이 특정 다른 서비스 이후에 시작되도록 설정할 수 있으며, 시작 스크립트에서 하드 코딩된 플래그 대신 [.filename]#/etc/rc.conf# 을 통해 추가 플래그를 전달할 수 있습니다. 기본 스크립트는 다음과 비슷하게 보일 수 있습니다:

[.programlisting]
....
#!/bin/sh
#
# PROVIDE: utility
# REQUIRE: DAEMON
# KEYWORD: shutdown

. /etc/rc.subr

name=utility
rcvar=utility_enable

command="/usr/local/sbin/utility"

load_rc_config $name

#
# DO NOT CHANGE THESE DEFAULT VALUES HERE
# SET THEM IN THE /etc/rc.conf FILE
#
utility_enable=${utility_enable-"NO"}
pidfile=${utility_pidfile-"/var/run/utility.pid"}

run_rc_command "$1"
....

이 스크립트는 제공된 `utility` 가 `DAEMON` 의사 서비스 이후에 시작되도록 합니다. 또한 프로세스 ID(PID)를 설정하고 추적하는 방법도 제공합니다.

그러면 이 애플리케이션은 [.filename]#/etc/rc.conf# 에 다음 줄을 넣을 수 있습니다:

[.programlisting]
....
utility_enable="YES"
....

이 방법을 사용하면 명령줄 인수를 더 쉽게 조작할 수 있고, [.filename]#/etc/rc.subr# 에 제공되는 기본 함수를 포함할 수 있으며, man:rcorder[8]와 호환되고, [.filename]#rc.conf# 를 통해 더 쉽게 구성할 수 있습니다.

=== 서비스를 사용하여 시작하기

다른 서비스는 man:inetd[8]을 사용하여 시작할 수 있습니다. man:inetd[8] 및 그 구성에 대한 작업은 crossref:network-servers[network-inetd,“The inetd Super-Server”]에 자세히 설명되어 있습니다.

경우에 따라 man:cron[8]을 사용하여 시스템 서비스를 시작하는 것이 더 합리적일 수 있습니다. 이 접근 방식은 man:crontab[5]의 소유자로서 이러한 프로세스를 실행하기 때문에 여러 가지 장점이 있습니다. 이를 통해 일반 사용자가 자신의 애플리케이션을 시작하고 유지 관리할 수 있습니다.

man:cron[8]의 `@reboot` 기능을 시간 지정 대신 사용할 수 있습니다. 이렇게 하면 일반적으로 시스템 초기화 중에 man:cron[8]이 시작될 때 작업이 실행됩니다.

[[configtuning-cron]]
== man:cron[8] 구성하기

FreeBSD에서 가장 유용한 유틸리티 중 하나는 cron입니다. 이 유틸리티는 백그라운드에서 실행되며 [.filename]#/etc/crontab# 에서 실행할 작업이 있는지 정기적으로 확인하고 [.filename]#/var/cron/tabs# 에서 사용자 지정 crontab 파일을 검색합니다. 이러한 파일은 지정된 시간에 cron이 실행할 작업을 예약하는 데 사용됩니다. crontab의 각 항목은 실행할 작업을 정의하며 이를 _cron job_ 이라고 합니다.

두 가지 유형의 구성 파일이 사용됩니다. 수정해서는 안 되는 system crontab과 필요에 따라 생성하고 편집할 수 있는 user crontab이 그것입니다. 이러한 파일에 사용되는 형식은 man:crontab[5]에 문서화되어 있습니다. System crontab의 형식인 [.filename]#/etc/crontab# 에는 user crontab에는 없는 `who` 열이 포함되어 있습니다. System crontab에서 cron은 이 열에 지정된 사용자로 명령을 실행합니다. User crontab에서는 모든 명령이 crontab을 생성한 사용자로 실행됩니다.

User crontab을 사용하면 개별 사용자가 자신의 작업을 예약할 수 있습니다. `root` 사용자는 시스템 [.filename]#crontab# 에 존재하지 않는 작업을 예약하는 데 사용할 수 있는 사용자 [.filename]#crontab# 을 가질 수도 있습니다.

다음은 system crontab의 샘플 항목인 [.filename]#/etc/crontab# 입니다:

[.programlisting]
....
# /etc/crontab - root's crontab for FreeBSD
#
# $FreeBSD$
# <.>
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin <.>
#
#minute	hour	mday	month	wday	who	command <.>
#
*/5	*	*	*	*	root	/usr/libexec/atrun <.>
....

<.> `+#+` 문자로 시작하는 줄은 주석입니다. 주석은 파일에 원하는 작업이 수행되는 이유와 내용을 알려주는 알림으로 사용할 수 있습니다. 주석은 명령과 같은 줄에 있으면 명령의 일부로 해석되므로 새 줄에 넣어야 합니다. 빈 줄은 무시됩니다.

<.> 등호(`=`) 문자는 환경 설정을 정의하는 데 사용됩니다. 이 예제에서는 `SHELL` 과 `PATH` 를 정의하는 데 사용됩니다. `SHELL` 을 생략하면 cron은 기본 Bourne 셸을 사용합니다. `PATH` 가 생략된 경우 실행할 명령 또는 스크립트의 전체 경로를 지정해야 합니다.

<.> 이 줄은 시스템 크론탭에 사용되는 7개의 필드를 정의합니다: `minute`, `hour`, `mday`, `month`, `wday`, `who`, `command` 입니다. `minute` 필드는 지정된 명령이 실행될 시간(분), `hour` 은 지정된 명령이 실행될 시간, `mday` 은 그 달의 날짜, `month` 은 월, `wday` 는 요일입니다. 이러한 필드는 24시간 시계를 나타내는 숫자 값 또는 해당 필드의 모든 값을 나타내는 `*` 여야 합니다. `who` 필드는 system crontab에만 존재하며 명령으로 어떤 사용자로 실행될지 지정합니다. 마지막 필드는 실행할 명령입니다.

<.> 이 항목은 이 cron job의 값을 정의합니다. `\*/5` 뒤에 여러 개의 `*` 문자가 이어지면 매시간, 매일, 요일, 매월 5분마다 `root` 에 의해 `/usr/libexec/atrun` 이 호출되도록 지정되며, 명령에는 스위치 개수에 제한 없이 포함될 수 있습니다. 그러나 여러 줄로 확장되는 명령은 백슬래시 "\" 연속 문자로 끊어야 합니다.

[[configtuning-installcrontab]]
=== User Crontab 만들기

User crontab을 만들려면 편집기 모드에서 `crontab` 을 호출합니다:

[source, shell]
....
% crontab -e
....

그러면 기본 텍스트 편집기를 사용하여 사용자의 crontab이 열립니다. 사용자가 이 명령을 처음 실행하면 빈 파일이 열립니다. 사용자가 crontab을 만들면 이 명령은 편집을 위해 해당 파일을 엽니다.

환경 변수를 설정하고 crontab에 있는 필드의 의미를 기억하기 위해 crontab 파일 상단에 이 줄을 추가하는 것이 유용합니다:

[.programlisting]
....
SHELL=/bin/sh
PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin
# Order of crontab fields
# minute	hour	mday	month	wday	command
....

그런 다음 실행할 각 명령 또는 스크립트에 대해 한 줄을 추가하여 명령 실행 시간을 지정합니다. 이 예에서는 매일 오후 2시에 지정된 사용자 지정 Bourne 셸 스크립트를 실행합니다. 스크립트 경로가 `PATH` 에 지정되지 않았으므로 스크립트의 전체 경로가 제공됩니다:

[.programlisting]
....
0	14	*	*	*	/usr/home/dru/bin/mycustomscript.sh
....

[TIP]
====

사용자 지정 스크립트를 사용하기 전에 실행 가능한지 확인하고 cron에서 설정한 제한된 환경 변수 집합으로 테스트하세요. 위의 cron 항목을 실행하는 데 사용되는 환경을 복제하려면 다음을 사용합니다:

[.programlisting]
....
env -i SHELL=/bin/sh PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin HOME=/home/dru LOGNAME=dru /usr/home/dru/bin/mycustomscript.sh
....

Cron으로 설정한 환경은 man:crontab[5]에 설명되어 있습니다. 스크립트가 와일드카드를 사용하여 파일을 삭제하는 명령이 포함된 경우 스크립트가 cron 환경에서 올바르게 작동하는지 확인하는 것이 특히 중요합니다.
====

Crontab 편집이 끝나면 파일을 저장합니다. 그러면 자동으로 설치되고 cron이 crontab을 읽고 지정된 시간에 cron job을 실행합니다. Crontab에 있는 cron job을 나열하려면 다음 명령을 사용합니다:

[source, shell]
....
% crontab -l
0	14	*	*	*	/usr/home/dru/bin/mycustomscript.sh
....

User crontab에서 모든 cron job을 제거하려면:

[source, shell]
....
% crontab -r
remove crontab for dru? y
....

[[configtuning-rcd]]
== FreeBSD에서 서비스 관리하기

FreeBSD는 시스템 초기화와 서비스 관리를 위해 man:rc[8] 시스템의 시작 스크립트를 사용합니다. [.filename]#/etc/rc.d# 에 나열된 스크립트는 man:service[8]에 `start`, `stop` 및 `restart` 옵션으로 제어할 수 있는 기본 서비스를 제공합니다. 예를 들어, 다음 명령으로 man:sshd[8]를 재시작할 수 있습니다:

[source, shell]
....
# service sshd restart
....

이 절차는 실행 중인 시스템에서 서비스를 시작하는 데 사용할 수 있습니다. 서비스는 man:rc.conf[5]에 지정된 대로 부팅 시 자동으로 시작됩니다. 예를 들어, 시스템 시작 시 man:natd[8]를 활성화하려면 [.filename]#/etc/rc.conf# 에 다음 줄을 추가합니다:

[.programlisting]
....
natd_enable="YES"
....

`natd_enable="NO"` 줄이 이미 있는 경우, `NO` 를 `YES` 로 변경합니다. 아래에 설명된 대로 다음 부팅 시 man:rc[8] 스크립트가 종속 서비스를 자동으로 로드합니다.

man:rc[8] 시스템은 주로 시스템 시작 및 종료 시 서비스를 시작하고 중지하기 위한 것이므로, `start`, `stop` 및 `restart` 옵션은 적절한 [.filename]#/etc/rc.conf# 변수가 설정되어 있는 경우에만 동작을 수행합니다. 예를 들어, `sshd restart` 는 `sshd_enable` 이 [.filename]#/etc/rc.conf# 에서 `YES` 로 설정된 경우에만 작동합니다. [.filename]#/etc/rc.conf# 의 설정에 관계없이 서비스를 `start`, `stop` 또는 `restart` 하려면 이러한 명령 앞에 "one"을 붙여야 합니다. 예를 들어, 현재 [.filename]#/etc/rc.conf# 설정에 관계없이 man:sshd[8]을 다시 시작하려면 다음 명령을 실행합니다:

[source, shell]
....
# service sshd onerestart
....

[.filename]#/etc/rc.conf# 에서 서비스가 활성화되어 있는지 확인하려면 `rcvar` 와 함께 적절한 man:rc[8] 스크립트를 실행합니다. 이 예에서는 [.filename]#/etc/rc.conf# 에서 man:sshd[8]이 활성화되어 있는지 확인합니다:

[source, shell]
....
# service sshd rcvar
# sshd
#
sshd_enable="YES"
#   (default: "")
....

[NOTE]
====
`root` 콘솔이 아닌 위 명령에서 `# sshd` 줄이 출력됩니다.
====

서비스가 실행 중인지 확인하려면 `status` 를 사용합니다. 예를 들어, man:sshd[8]이 실행 중인지 확인합니다:

[source, shell]
....
# service sshd status
sshd is running as pid 433.
....

경우에 따라 서비스를 `reload` 할 수도 있습니다. 이는 개별 서비스에 신호를 전송하여 서비스가 구성 파일을 강제로 다시 로드하도록 시도합니다. 대부분의 경우 이는 서비스에 `SIGHUP` 신호를 보내는 것을 의미합니다. 이 기능이 모든 서비스에 지원되는 것은 아닙니다.

man:rc[8] 시스템은 네트워크 서비스에 사용되며 대부분의 시스템 초기화에도 기여합니다. 예를 들어 [.filename]#/etc/rc.d/bgfsck# 스크립트가 실행되면 다음과 같은 메시지가 출력됩니다:

[source, shell]
....
60초 후에 백그라운드 파일 시스템 검사를 시작하기.
....

이 스크립트는 시스템 초기화 중에만 발생하는 백그라운드 파일 시스템 검사에 사용됩니다.

많은 시스템 서비스는 제대로 작동하기 위해 다른 서비스에 의존합니다. 예를 들어, man:yp[8] 및 기타 RPC 기반 서비스는 man:rpcbind[8] 서비스가 시작될 때까지 시작하지 못할 수 있습니다. 이 문제를 해결하기 위해 종속성 및 기타 메타 데이터에 대한 정보가 각 시작 스크립트 상단의 주석에 포함되어 있습니다. man:rcorder[8] 프로그램은 시스템 초기화 중에 이러한 주석을 파싱하여 종속성을 충족하기 위해 시스템 서비스를 호출해야 하는 순서를 결정하는 데 사용됩니다.

다음 키워드는 시작 스크립트를 "활성화"하기 위해 man:rc.subr[8]에 필요하므로 모든 시작 스크립트에 포함되어야 합니다:

* `PROVIDE` : 이 파일이 제공하는 서비스를 지정합니다.

각 시작 스크립트 상단에 다음 키워드를 포함할 수 있습니다. 반드시 필요한 것은 아니지만 man:rcorder[8]에 대한 힌트로 유용합니다:

* `REQUIRE` : 이 서비스에 필요한 서비스를 나열합니다. 이 키워드가 포함된 스크립트는 지정된 서비스 _후_ 에 실행됩니다.
* `BEFORE` : 이 서비스에 종속된 서비스를 나열합니다. 이 키워드가 포함된 스크립트는 지정된 서비스 _전에_ 실행됩니다.

각 시작 스크립트에 대해 이러한 키워드를 신중하게 설정하면 관리자는 일부 UNIX(R) 운영 체제에서 사용하는 "runlevels"을 사용하지 않고도 스크립트의 시작 순서를 세밀하게 제어할 수 있습니다.

추가 정보는 man:rc[8] 및 man:rc.subr[8]에서 확인할 수 있습니다. 사용자 지정 man:rc[8] 스크립트를 만드는 방법에 대한 지침은 extref:{rc-scripting}[이 문서]를 참조하세요.

[[configtuning-core-configuration]]
=== 시스템에 특화된 구성 관리하기

시스템 구성 정보의 주요 위치는 [.filename]#/etc/rc.conf# 입니다. 이 파일에는 다양한 구성 정보가 포함되어 있으며 시스템 시작 시 시스템을 구성하기 위해 읽습니다. 이 파일은 [.filename]#rc*# 파일에 대한 구성 정보를 제공합니다.

[.filename]#/etc/rc.conf# 의 항목은 [.filename]#/etc/defaults/rc.conf# 의 기본 설정을 재정의합니다. 기본 설정이 포함된 파일은 편집해서는 안 됩니다. 대신 모든 시스템별 변경 사항은 [.filename]#/etc/rc.conf# 에서 수행해야 합니다.

클러스터된 애플리케이션에서는 관리 오버헤드를 줄이기 위해 사이트 전체 구성과 시스템별 구성을 분리하는 여러 가지 전략을 적용할 수 있습니다. 권장되는 접근 방식은 시스템별 구성을 [.filename]#/etc/rc.conf.local# 에 배치하는 것입니다. 예를 들어 [.filename]#/etc/rc.conf# 에 있는 이러한 항목은 모든 시스템에 적용됩니다:

[.programlisting]
....
sshd_enable="YES"
keyrate="fast"
defaultrouter="10.1.1.254"
....

반면 [.filename]#/etc/rc.conf.local# 의 이러한 항목은 이 시스템에만 적용됩니다:

[.programlisting]
....
hostname="node1.example.org"
ifconfig_fxp0="inet 10.1.1.1/8"
....

[.filename]#/etc/rc.conf# 는 고유한 상태로 유지하면서, [.filename]#/etc/rc.conf.local# 은 rsync 또는 puppet과 같은 애플리케이션을 사용하여 모든 시스템에 배포하세요.

시스템을 업그레이드해도 [.filename]#/etc/rc.conf# 를 덮어쓰지는 않으므로 시스템 구성 정보는 손실되지 않습니다.

[TIP]
====

[.filename]#/etc/rc.conf# 및 [.filename]#/etc/rc.conf.local# 은 모두 man:sh[1]로 파싱됩니다. 이를 통해 시스템 운영자는 복잡한 구성 시나리오를 만들 수 있습니다. 이 주제에 대한 자세한 내용은 man:rc.conf[5]를 참조하세요.
====

[[config-network-setup]]
== 네트워크 인터페이스 카드 설정하기

네트워크 인터페이스 카드(NIC)를 추가하고 구성하는 것은 모든 FreeBSD 관리자에게 일반적인 작업입니다.

=== 올바른 드라이버 찾기

먼저, NIC의 모델과 사용하는 칩을 결정합니다. FreeBSD는 다양한 NIC를 지원합니다. 해당 NIC가 지원되는지 확인하려면 FreeBSD 릴리즈의 하드웨어 호환성 목록을 확인하세요.

NIC가 지원되는 경우, NIC용 FreeBSD 드라이버의 이름을 결정합니다. 지원되는 칩셋에 대한 정보가 포함된 NIC 드라이버 목록은 [.filename]#/usr/src/sys/conf/NOTES# 및 [.filename]#/usr/src/sys/arch/conf/NOTES# 를 참조하세요. 확실하지 않은 경우 드라이버의 설명서 페이지에서 지원되는 하드웨어와 드라이버의 알려진 제한 사항에 대한 자세한 정보를 확인할 수 있습니다.

일반 NIC용 드라이버는 [.filename]#GENERIC# 커널에 이미 존재하므로 부팅 중에 NIC를 검색해야 합니다. 시스템의 부팅 메시지는 `more /var/run/dmesg.boot` 를 입력하고 스페이스바를 사용하여 텍스트를 스크롤하면 볼 수 있습니다. 이 예제에서는 man:dc[4] 드라이버를 사용하는 두 개의 이더넷 NIC가 시스템에 있습니다:

[source, shell]
....
dc0: <82c169 PNIC 10/100BaseTX> port 0xa000-0xa0ff mem 0xd3800000-0xd38
000ff irq 15 at device 11.0 on pci0
miibus0: <MII bus> on dc0
bmtphy0: <BCM5201 10/100baseTX PHY> PHY 1 on miibus0
bmtphy0:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc0: Ethernet address: 00:a0:cc:da:da:da
dc0: [ITHREAD]
dc1: <82c169 PNIC 10/100BaseTX> port 0x9800-0x98ff mem 0xd3000000-0xd30
000ff irq 11 at device 12.0 on pci0
miibus1: <MII bus> on dc1
bmtphy1: <BCM5201 10/100baseTX PHY> PHY 1 on miibus1
bmtphy1:  10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto
dc1: Ethernet address: 00:a0:cc:da:da:db
dc1: [ITHREAD]
....

NIC용 드라이버가 [.filename]#GENERIC# 에 없지만 드라이버를 사용할 수 있는 경우, 드라이버를 로드해야 NIC를 구성하고 사용할 수 있습니다. 이 작업은 두 가지 방법 중 하나로 수행할 수 있습니다:

* 가장 쉬운 방법은 man:kldload[8]를 사용하여 NIC용 커널 모듈을 로드하는 것입니다. 부팅 시 드라이버를 자동으로 로드하려면 [.filename]#/boot/loader.conf# 에 적절한 줄을 추가하세요. 모든 NIC 드라이버를 모듈로 사용할 수 있는 것은 아닙니다.
* 또는 NIC에 대한 지원을 사용자 정의 커널에 정적으로 컴파일합니다. 사용자 지정 커널 구성 파일에 추가할 줄을 결정하려면 [.filename]#/usr/src/sys/conf/NOTES#, [.filename]#/usr/src/sys/arch/conf/NOTES# 및 드라이버의 설명서 페이지를 참조하세요. 커널을 다시 컴파일하는 방법에 대한 자세한 내용은 crossref:kernelconfig[kernelconfig,Configuring the FreeBSD Kernel]를 참조하십시오. 부팅 시 NIC가 감지된 경우 커널을 다시 컴파일할 필요가 없습니다.

[[config-network-ndis]]
==== Windows(R) NDIS 드라이버 사용하기

안타깝게도 이러한 정보를 영업 비밀로 간주하여 오픈 소스 커뮤니티에 드라이버의 회로도를 제공하지 않는 공급업체가 여전히 많이 있습니다. 따라서 FreeBSD 및 기타 운영 체제 개발자는 오랜 시간이 걸리는 리버스 엔지니어링 프로세스를 통해 드라이버를 개발하거나 Microsoft(R) Windows(R) 플랫폼에서 사용할 수 있는 기존 드라이버 바이너리를 사용하는 두 가지 선택지가 남습니다.

FreeBSD는 네트워크 드라이버 인터페이스 사양(NDIS)에 대한 "네이티브" 지원을 제공합니다. 여기에는 man:ndisgen[8]이 포함되어 있는데, 이는 Windows(R) XP 드라이버를 FreeBSD에서 사용할 수 있는 포맷으로 변환하는 데 사용할 수 있습니다. man:ndis[4] 드라이버는 Windows(R) XP 바이너리를 사용하므로, i386(TM) 및 amd64 시스템에서만 실행됩니다. PCI, CardBus, PCMCIA 및 USB 장치가 지원됩니다.

man:ndisgen[8]을 사용하려면 세 가지가 필요합니다:

. FreeBSD 커널 소스.
. 확장자가 [.filename]#.SYS# 인 Windows(R) XP 드라이버 바이너리입니다.
. 확장자가 [.filename]#.INF# 인 Windows(R) XP 드라이버 구성 파일입니다.

특정 NIC에 대한 [.filename]#.SYS# 및 [.filename]#.INF# 파일을 다운로드합니다. 일반적으로 드라이버 CD 또는 공급업체 웹사이트에서 찾을 수 있습니다. 다음 예제에서는 [.filename]#W32DRIVER.SYS# 및 [.filename]#W32DRIVER.INF# 를 사용합니다.

드라이버 비트 폭은 FreeBSD 버전과 일치해야 합니다. FreeBSD/i386의 경우 Windows(R) 32비트 드라이버를 사용합니다. FreeBSD/amd64의 경우 Windows(R) 64비트 드라이버가 필요합니다.

다음 단계는 드라이버 바이너리를 로드 가능한 커널 모듈로 컴파일하는 것입니다. `root` 로 man:ndisgen[8]을 사용합니다:

[source, shell]
....
# ndisgen /path/to/W32DRIVER.INF /path/to/W32DRIVER.SYS
....

이 명령은 대화형이며 필요한 추가 정보를 묻는 메시지를 표시합니다. 현재 디렉토리에 새 커널 모듈이 생성됩니다. man:kldload[8]을 사용하여 새 모듈을 로드합니다:

[source, shell]
....
# kldload ./W32DRIVER_SYS.ko
....

생성된 커널 모듈 외에도 [.filename]#ndis.ko# 및 [.filename]#if_ndis.ko# 모듈을 로드해야 합니다. 이 작업은 man:ndis[4]에 의존하는 모듈이 로드될 때 자동으로 수행되어야 합니다. 그렇지 않은 경우 다음 명령을 사용하여 수동으로 로드하세요:

[source, shell]
....
# kldload ndis
# kldload if_ndis
....

첫 번째 명령은 man:ndis[4] 미니포트 드라이버 래퍼를 로드하고 두 번째 명령은 생성된 NIC 드라이버를 로드합니다.

man:dmesg[8]를 확인하여 로드 오류가 있는지 확인합니다. 모든 것이 정상적으로 진행되었다면 출력은 다음과 비슷할 것입니다:

[source, shell]
....
ndis0: <Wireless-G PCI Adapter> mem 0xf4100000-0xf4101fff irq 3 at device 8.0 on pci1
ndis0: NDIS API version: 5.0
ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5
ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps
ndis0: 11g rates: 6Mbps 9Mbps 12Mbps 18Mbps 36Mbps 48Mbps 54Mbps
....

여기에서 [.filename]#ndis0# 은 다른 NIC와 마찬가지로 구성할 수 있습니다.

부팅 시 man:ndis[4] 모듈을 로드하도록 시스템을 구성하려면 생성된 모듈인 [.filename]#W32DRIVER_SYS.ko# 를 [.filename]#/boot/modules# 에 복사합니다. 그런 다음 [.filename]#/boot/loader.conf# 에 다음 줄을 추가합니다:

[.programlisting]
....
W32DRIVER_SYS_load="YES"
....

=== 네트워크 카드 구성하기

NIC에 적합한 드라이버가 로드되면 카드를 구성해야 합니다. 설치 시 man:bsdinstall[8]에 의해 구성되었을 수 있습니다.

NIC 구성을 표시하려면 다음 명령을 입력합니다:

[source, shell]
....
% ifconfig
dc0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
        options=80008<VLAN_MTU,LINKSTATE>
        ether 00:a0:cc:da:da:da
        inet 192.168.1.3 netmask 0xffffff00 broadcast 192.168.1.255
        media: Ethernet autoselect (100baseTX <full-duplex>)
        status: active
dc1: flags=8802<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500
        options=80008<VLAN_MTU,LINKSTATE>
        ether 00:a0:cc:da:da:db
        inet 10.0.0.1 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet 10baseT/UTP
        status: no carrier
lo0: flags=8049<UP,LOOPBACK,RUNNING,MULTICAST> metric 0 mtu 16384
        options=3<RXCSUM,TXCSUM>
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x4
        inet6 ::1 prefixlen 128
        inet 127.0.0.1 netmask 0xff000000
        nd6 options=3<PERFORMNUD,ACCEPT_RTADV>
....

이 예제에서는 다음과 같은 장치가 표시되었습니다:

* [.filename]#dc0# : 첫번째 이더넷 인터페이스.
* [.filename]#dc1# : 두 번째 이더넷 인터페이스.
* [.filename]#lo0# : 루프백 장치.

FreeBSD는 드라이버 이름 뒤에 부팅 시 카드가 감지되는 순서를 사용하여 NIC의 이름을 지정합니다. 예를 들어, [.filename]#sis2# 는 man:sis[4] 드라이버를 사용하는 시스템에서 세 번째 NIC입니다.

이 예에서는 [.filename]#dc0# 이 실행 중입니다. 주요 지표는 다음과 같습니다:

. `UP` 은 카드가 구성되고 준비되었음을 의미합니다.
. 카드의 인터넷(`inet`) 주소는 `192.168.1.3` 입니다.
. 유효한 서브넷 마스크(`netmask`)가 있으며, 여기서 `0xffffff00` 은 `255.255.255.0` 과 동일합니다.
. 유효한 브로드캐스트 주소는 `192.168.1.255` 입니다.
. 카드의 MAC 주소(`ether`)는 `00:a0:cc:da:da:da` 입니다.
. 물리적 미디어 선택이 자동 선택 모드에 있습니다( `media: Ethernet autoselect (100baseTX <full-duplex>)` ). 이 예제에서는 [.filename]#dc1# 이 `10baseT/UTP` 미디어로 실행되도록 구성되었습니다. 드라이버에 사용 가능한 미디어 유형에 대한 자세한 내용은 해당 설명서 페이지를 참조하십시오.
. 링크의 상태( `status` )는 `active` 로, 캐리어 신호가 감지되었음을 나타냅니다. 이더넷 케이블이 카드에 연결되어 있지 않은 경우 [.filename]#dc1# 의 경우 `status: no carrier` 상태는 정상입니다.

man:ifconfig[8] 출력에 다음과 비슷한 내용이 표시되었다면:

[source, shell]
....
dc0: flags=8843<BROADCAST,SIMPLEX,MULTICAST> metric 0 mtu 1500
	options=80008<VLAN_MTU,LINKSTATE>
	ether 00:a0:cc:da:da:da
	media: Ethernet autoselect (100baseTX <full-duplex>)
	status: active
....

로 나타나면, 카드가 구성되지 않았음을 나타냅니다.

카드는 `root` 로 구성해야 합니다. NIC 구성은 명령줄에서 man:ifconfig[8]을 사용하여 수행할 수 있지만 [.filename]#/etc/rc.conf# 에도 구성을 추가하지 않으면 재부팅 후에도 지속되지 않습니다. LAN에 DHCP 서버가 있는 경우 이 줄만 추가하면 됩니다:

[.programlisting]
....
ifconfig_dc0="DHCP"
....

_dc0_ 를 시스템에 맞는 올바른 값으로 바꿉니다.

그런 다음 추가한 줄에 <<config-network-testing>> 에 제공된 지침을 따릅니다.

[NOTE]
====
설치 중에 네트워크를 구성한 경우, NIC에 대한 일부 항목이 이미 있을 수 있습니다. 줄을 추가하기 전에 [.filename]#/etc/rc.conf# 을 다시 확인하세요.
====

DHCP 서버가 없는 경우 NIC를 수동으로 구성해야 합니다. 이 예와 같이 시스템에 있는 각 NIC에 대해 한 줄을 추가합니다:

[.programlisting]
....
ifconfig_dc0="inet 192.168.1.3 netmask 255.255.255.0"
ifconfig_dc1="inet 10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP"
....

[.filename]#dc0# 및 [.filename]#dc1# 과 IP 주소 정보를 시스템에 맞는 올바른 값으로 바꿉니다. 허용되는 옵션과 [.filename]#/etc/rc.conf# 의 구문에 대한 자세한 내용은 드라이버의 매뉴얼 페이지, man:ifconfig[8] 및 man:rc.conf[5]를 참조하세요.

네트워크에서 DNS를 사용하지 않는 경우, [.filename]#/etc/hosts# 을 수정하여 LAN에 호스트의 이름과 IP 주소가 없는 경우 추가하세요. 자세한 내용은 man:hosts[5] 및 [.filename]#/usr/share/examples/etc/hosts# 을 참조하세요.

[NOTE]
====
DHCP 서버가 없고 인터넷에 액세스해야 하는 경우 기본 게이트웨이와 네임서버를 수동으로 구성합니다:

[source, shell]
....
# sysrc defaultrouter="your_default_router"
# echo 'nameserver your_DNS_server' >> /etc/resolv.conf
....

====

[[config-network-testing]]
=== 테스트 및 문제 해결

[.filename]#/etc/rc.conf# 에 필요한 변경 사항을 저장한 후 재부팅하여 네트워크 구성을 테스트하고 구성 오류 없이 시스템이 다시 시작되는지 확인할 수 있습니다. 또는 이 명령을 사용하여 네트워킹 시스템에 설정을 적용할 수도 있습니다:

[source, shell]
....
# service netif restart
....

[NOTE]
====
기본 게이트웨이가 [.filename]#/etc/rc.conf# 에 설정되어 있는 경우에도 이 명령을 실행하세요:

[source, shell]
....
# service routing restart
....

====

네트워킹 시스템이 다시 시작되면 NIC를 테스트합니다.

==== 이더넷 카드 테스트하기

이더넷 카드가 올바르게 구성되었는지 확인하려면 인터페이스 자체를 man:ping[8]한 다음 LAN에 있는 다른 머신을 man:ping[8]합니다:

[source, shell]
....
% ping -c5 192.168.1.3
PING 192.168.1.3 (192.168.1.3): 56 data bytes
64 bytes from 192.168.1.3: icmp_seq=0 ttl=64 time=0.082 ms
64 bytes from 192.168.1.3: icmp_seq=1 ttl=64 time=0.074 ms
64 bytes from 192.168.1.3: icmp_seq=2 ttl=64 time=0.076 ms
64 bytes from 192.168.1.3: icmp_seq=3 ttl=64 time=0.108 ms
64 bytes from 192.168.1.3: icmp_seq=4 ttl=64 time=0.076 ms

--- 192.168.1.3 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.074/0.083/0.108/0.013 ms
....

[source, shell]
....
% ping -c5 192.168.1.2
PING 192.168.1.2 (192.168.1.2): 56 data bytes
64 bytes from 192.168.1.2: icmp_seq=0 ttl=64 time=0.726 ms
64 bytes from 192.168.1.2: icmp_seq=1 ttl=64 time=0.766 ms
64 bytes from 192.168.1.2: icmp_seq=2 ttl=64 time=0.700 ms
64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.747 ms
64 bytes from 192.168.1.2: icmp_seq=4 ttl=64 time=0.704 ms

--- 192.168.1.2 ping statistics ---
5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.700/0.729/0.766/0.025 ms
....

네트워크 확인을 테스트하려면 IP 주소 대신 호스트 이름을 사용하세요. 네트워크에 DNS 서버가 없는 경우 먼저 [.filename]#/etc/hosts# 을 구성해야 합니다. 이를 위해 [.filename]#/etc/hosts# 을 편집하여 LAN에 호스트의 이름과 IP 주소가 없는 경우 추가합니다. 자세한 내용은 man:hosts[5] 및 [.filename]#/usr/share/examples/etc/hosts# 을 참조하세요.

==== 문제 해결

하드웨어 및 소프트웨어 구성 문제를 해결할 때는 간단한 사항을 먼저 확인하세요. 네트워크 케이블이 연결되어 있나요? 네트워크 서비스가 올바르게 구성되어 있나요? 방화벽이 올바르게 구성되어 있나요? NIC가 FreeBSD에서 지원되나요? 버그 리포트를 보내기 전에 항상 하드웨어 노트를 확인하고, FreeBSD 버전을 최신 안정 버전으로 업데이트하고, 메일링 리스트 아카이브를 확인하고, 인터넷에서 검색하세요.

카드가 작동하지만 성능이 좋지 않은 경우, man:tuning[7]을 읽어보세요. 또한 네트워크 설정이 잘못되면 연결 속도가 느려질 수 있으므로 네트워크 구성을 확인하세요.

일부 사용자는 한두 번의 `device timeout` 메시지를 경험하는데, 이는 일부 카드의 경우 정상입니다. 메시지가 계속 표시되거나 귀찮을 경우 장치가 다른 장치와 충돌하는지 확인하세요. 케이블 연결을 다시 확인하세요. 다른 카드를 사용해 보세요.

`watchdog timeout` 오류를 해결하려면 먼저 네트워크 케이블을 확인하세요. 많은 카드에는 버스 마스터링을 지원하는 PCI 슬롯이 필요합니다. 일부 구형 마더보드에서는 하나의 PCI 슬롯(보통 슬롯 0)만 허용합니다. NIC와 마더보드 설명서를 확인하여 해당 문제가 있는지 확인하세요.

시스템이 대상 호스트로 패킷을 라우팅할 수 없는 경우 `No route to host` 메시지가 표시됩니다. 기본 경로가 지정되지 않았거나 케이블이 분리된 경우 발생할 수 있습니다. `netstat -rn` 의 출력을 확인하여 호스트에 대한 유효한 경로가 있는지 확인하세요. 그렇지 않은 경우 crossref:advanced-networking[network-routing,“Gateways and Routes”]을 참조하세요.

`ping: sendto: Permission denied` 오류 메시지는 종종 잘못 구성된 방화벽으로 인해 발생합니다. 방화벽이 FreeBSD에서 활성화되었지만 규칙이 정의되지 않은 경우, 기본 정책은 모든 트래픽을 거부하는 것입니다(심지어 man:ping[8] 포함). 자세한 내용은 crossref:firewalls[firewalls,Firewalls]을 참고하세요.

때때로 카드의 성능이 좋지 않거나 평균 이하인 경우가 있습니다. 이러한 경우 미디어 선택 모드를 `autoselect` 에서 올바른 미디어 선택으로 설정해 보세요. 이 방법은 대부분의 하드웨어에서 작동하지만, 문제가 해결될 수도 있고 해결되지 않을 수도 있습니다. 다시 한 번 모든 네트워크 설정을 확인하고 man:tuning[7]을 참조하세요.

[[configtuning-virtual-hosts]]
== 가상 호스트

하나의 서버가 네트워크에 여러 대의 서버로 표시되는 가상 사이트 호스팅은 FreeBSD의 일반적인 용도입니다. 이는 단일 인터페이스에 여러 네트워크 주소를 할당하여 이루어집니다.

주어진 네트워크 인터페이스에는 하나의 "실제" 주소가 있으며, "별칭" 주소는 얼마든지 가질 수 있습니다. 이러한 별칭은 일반적으로 이 예제에서 볼 수 있듯이 [.filename]#/etc/rc.conf# 에 별칭 항목을 배치하여 추가합니다:

[.programlisting]
....
ifconfig_fxp0_alias0="inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx"
....

별칭 항목은`alias0`, `alias1` 등과 같은 순차 번호를 사용하여 `alias__0__` 으로 시작해야 합니다. 구성 프로세스는 첫 번째 누락된 번호에서 중지됩니다.

별칭 넷마스크 계산은 중요합니다. 주어진 인터페이스에 대해 네트워크의 넷마스크를 올바르게 나타내는 주소가 하나 있어야 합니다. 이 네트워크에 속하는 다른 모든 주소는 `255.255.255.255` 또는 `0xffffffff` 로 표현되는 모든 ``1`` 의 넷마스크를 가져야 합니다.

예를 들어, [.filename]#fxp0# 인터페이스가 두 개의 네트워크에 연결되어 있는 경우를 생각해 보겠습니다: 넷마스크가 `255.255.255.0` 인 `10.1.1.0` 과 넷마스크가 `255.255.255.240` 인 `202.0.75.16` 이죠. 시스템은 `10.1.1.1` ~ `10.1.1.5` 및 `202.0.75.17` ~ `202.0.75.20` 범위에 나타나도록 구성해야 합니다. 주어진 네트워크 범위의 첫 번째 주소만 실제 넷마스크를 가져야 합니다. 나머지 모든 주소(`10.1.1.2` ~ `10.1.1.5` 및 `202.0.75.18` ~ `202.0.75.20`)는 `255.255.255.255` 의 넷마스크로 구성해야 합니다.

다음 [.filename]#/etc/rc.conf# 항목은 이 시나리오에 맞게 어댑터를 올바르게 구성한 것입니다:

[.programlisting]
....
ifconfig_fxp0="inet 10.1.1.1 netmask 255.255.255.0"
ifconfig_fxp0_alias0="inet 10.1.1.2 netmask 255.255.255.255"
ifconfig_fxp0_alias1="inet 10.1.1.3 netmask 255.255.255.255"
ifconfig_fxp0_alias2="inet 10.1.1.4 netmask 255.255.255.255"
ifconfig_fxp0_alias3="inet 10.1.1.5 netmask 255.255.255.255"
ifconfig_fxp0_alias4="inet 202.0.75.17 netmask 255.255.255.240"
ifconfig_fxp0_alias5="inet 202.0.75.18 netmask 255.255.255.255"
ifconfig_fxp0_alias6="inet 202.0.75.19 netmask 255.255.255.255"
ifconfig_fxp0_alias7="inet 202.0.75.20 netmask 255.255.255.255"
....

이를 더 간단하게 표현하는 방법은 공백으로 구분된 IP 주소 범위 목록을 사용하는 것입니다. 첫 번째 주소에는 지정된 서브넷 마스크가 지정되고 추가 주소에는 `255.255.255.255` 의 서브넷 마스크가 지정됩니다.

[.programlisting]
....
ifconfig_fxp0_aliases="inet 10.1.1.1-5/24 inet 202.0.75.17-20/28"
....

[[configtuning-syslog]]
== 시스템 로깅 구성하기

시스템 로그를 생성하고 읽는 것은 시스템 관리의 중요한 측면입니다. 시스템 로그의 정보는 하드웨어 및 소프트웨어 문제와 애플리케이션 및 시스템 구성 오류를 감지하는 데 사용할 수 있습니다. 이 정보는 보안 감사 및 사고 대응에도 중요한 역할을 합니다. 대부분의 시스템 데몬과 애플리케이션은 로그 항목을 생성합니다.

FreeBSD는 로깅을 관리하기 위해 시스템 로거인 syslogd를 제공합니다. 기본적으로 시스템이 부팅될 때 syslogd가 시작됩니다. 이것은 [.filename]#/etc/rc.conf# 의 `syslogd_enable` 변수에 의해 제어됩니다. [.filename]#/etc/rc.conf# 의 `syslogd_flags` 를 사용하여 설정할 수 있는 애플리케이션 인수는 다양합니다. 사용 가능한 인자에 대한 자세한 내용은 man:syslogd[8]을 참조하세요.

이 섹션에서는 로컬 및 원격 로깅을 위해 FreeBSD 시스템 로거를 구성하는 방법과 로그 로테이션 및 로그 관리를 수행하는 방법을 설명합니다.

=== 로컬 로깅 구성하기

구성 파일인 [.filename]#/etc/syslog.conf# 는 수신된 로그 항목에 대해 syslogd가 수행하는 작업을 제어합니다. 들어오는 이벤트의 처리를 제어하는 몇 가지 매개변수가 있습니다. _facility_ 는 커널이나 데몬 등 메시지를 생성한 하위 시스템을 설명하고, _level_ 은 발생한 이벤트의 심각도를 설명합니다. 이를 통해 시설과 수준에 따라 로그 메시지의 기록 여부와 위치를 구성할 수 있습니다. 또한 메시지를 전송한 애플리케이션과 원격 로깅의 경우 로깅 이벤트를 생성하는 머신의 호스트 이름에 따라 조치를 취할 수도 있습니다.

이 구성 파일에는 작업당 한 줄씩 추가되며, 각 줄의 구문은 선택기 필드 다음에 작업 필드가 있습니다. 선택기 필드의 구문은 _facility.level_ 로, _facility_ 에서 _level_ 이상의 로그 메시지와 일치합니다. 레벨 앞에 선택적 비교 플래그를 추가하여 기록되는 내용을 보다 정확하게 지정할 수도 있습니다. 동일한 작업에 여러 선택기 필드를 사용할 수 있으며 세미콜론( `;` )으로 구분합니다. `*` 를 사용하면 모든 항목이 일치합니다. 작업 필드는 로그 메시지를 보낼 위치(예: 파일 또는 원격 로그 호스트)를 나타냅니다. 예를 들어, 다음은 FreeBSD의 기본 [.filename]#syslog.conf# 입니다:

[.programlisting]
....
# $FreeBSD$
#
#       Spaces ARE valid field separators in this file. However,
#       other *nix-like systems still insist on using tabs as field
#       separators. If you are sharing this file between systems, you
#       may want to use only tabs as field separators here.
#       Consult the syslog.conf(5) manpage.
*.err;kern.warning;auth.notice;mail.crit                /dev/console
*.notice;authpriv.none;kern.debug;lpr.info;mail.crit;news.err   /var/log/messages
security.*                                      /var/log/security
auth.info;authpriv.info                         /var/log/auth.log
mail.info                                       /var/log/maillog
lpr.info                                        /var/log/lpd-errs
ftp.info                                        /var/log/xferlog
cron.*                                          /var/log/cron
!-devd
*.=debug                                        /var/log/debug.log
*.emerg                                         *
# uncomment this to log all writes to /dev/console to /var/log/console.log
#console.info                                   /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
# touch /var/log/all.log and chmod it to mode 600 before it will work
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote loghost named loghost
#*.*                                            @loghost
# uncomment these if you're running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
# Uncomment this if you wish to see messages produced by devd
# !devd
# *.>=info
!ppp
*.*                                             /var/log/ppp.log
!*
....

이 예제에서는

* 8행은 `err` 이상의 모든 메시지와 `kern.warning`, `auth.notice` 및 `mail.crit` 을 찾고 이러한 로그 메시지를 콘솔( [.filename]#/dev/console# )로 보냅니다.
* 12줄은 `info` 레벨 이상의 `mail` 기능의 모든 메시지를 찾고 메시지를 [.filename]#/var/log/maillog# 에 기록합니다.
* 17행은 비교 플래그( `=` )를 사용하여 `debug` 레벨의 메시지만 찾고 이를 [.filename]#/var/log/debug.log# 에 기록합니다.
* 33줄은 프로그램 사양의 사용 예시입니다. 따라서 그 뒤에 나오는 규칙은 지정된 프로그램에 대해서만 유효합니다. 이 경우 ppp에서 생성된 메시지만 [.filename]#/var/log/ppp.log# 에 기록됩니다.

사용 가능한 레벨은 가장 심각한 것부터 가장 덜 심각한 것 순으로 `emerg`, `alert`, `crit`, `err`, `warning`, `notice`, `info`, `debug` 입니다.

특정 순서 없이 `auth`, `authpriv`, `console`, `cron`, `daemon`, `ftp`, `kern`, `lpr`, `mail`, `mark`, `news`, `security`, `syslog`, `user`, `uucp`, `local0`~`local7` 의 순서입니다. 다른 운영 체제에는 다른 기능이 있을 수 있습니다.

`notice` 레벨 이상의 모든 항목을 [.filename]#/var/log/daemon.log# 에 기록하려면 다음 항목을 추가합니다:

[.programlisting]
....
daemon.notice                                        /var/log/daemon.log
....

다양한 수준과 기능에 대한 자세한 내용은 man:syslog[3] 및 man:syslogd[8]를 참조하세요. [.filename]#/etc/syslog.conf#, 구문 및 고급 사용 예제에 대한 자세한 내용은 man:syslog.conf[5]를 참조하세요.

=== 로그 관리 및 순환

로그 파일은 빠르게 증가하여 디스크 공간을 차지하고 유용한 정보를 찾기가 더 어려워질 수 있습니다. 로그 관리는 이를 완화하기 위해 사용됩니다. FreeBSD에서는 newsyslog를 사용하여 로그 파일을 관리합니다. 이 기본 제공 프로그램은 주기적으로 로그 파일을 순환 및 압축하고, 선택적으로 누락된 로그 파일을 생성하고 로그 파일이 이동될 때 프로그램에 신호를 보냅니다. 로그 파일은 syslogd 또는 로그 파일을 생성하는 다른 프로그램에서 생성할 수 있습니다. newsyslog는 일반적으로 man:cron[8]에서 실행되지만 시스템 데몬은 아닙니다. 기본 구성에서는 매시간 실행됩니다.

어떤 조치를 취해야 하는지 알기 위해 newsyslog는 구성 파일인 [.filename]#/etc/newsyslog.conf# 를 읽습니다. 이 파일에는 newsyslog가 관리하는 각 로그 파일에 대해 한 줄씩 포함되어 있습니다. 각 줄에는 파일 소유자, 권한, 해당 파일을 회전할 시기, 압축과 같이 로그 회전에 영향을 주는 선택적 플래그, 로그가 회전할 때 신호를 보내는 프로그램이 명시되어 있습니다. 다음은 FreeBSD의 기본 구성입니다:

[.programlisting]
....
# configuration file for newsyslog
# $FreeBSD$
#
# Entries which do not specify the '/pid_file' field will cause the
# syslogd process to be signalled when that log file is rotated.  This
# action is only appropriate for log files which are written to by the
# syslogd process (ie, files listed in /etc/syslog.conf).  If there
# is no process which needs to be signalled when a given log file is
# rotated, then the entry for that file should include the 'N' flag.
#
# The 'flags' field is one or more of the letters: BCDGJNUXZ or a '-'.
#
# Note: some sites will want to select more restrictive protections than the
# defaults.  In particular, it may be desirable to switch many of the 644
# entries to 640 or 600.  For example, some sites will consider the
# contents of maillog, messages, and lpd-errs to be confidential.  In the
# future, these defaults may change to more conservative ones.
#
# logfilename          [owner:group]    mode count size when  flags [/pid_file] [sig_num]
/var/log/all.log                        600  7     *    @T00  J
/var/log/amd.log                        644  7     100  *     J
/var/log/auth.log                       600  7     100  @0101T JC
/var/log/console.log                    600  5     100  *     J
/var/log/cron                           600  3     100  *     JC
/var/log/daily.log                      640  7     *    @T00  JN
/var/log/debug.log                      600  7     100  *     JC
/var/log/kerberos.log                   600  7     100  *     J
/var/log/lpd-errs                       644  7     100  *     JC
/var/log/maillog                        640  7     *    @T00  JC
/var/log/messages                       644  5     100  @0101T JC
/var/log/monthly.log                    640  12    *    $M1D0 JN
/var/log/pflog                          600  3     100  *     JB    /var/run/pflogd.pid
/var/log/ppp.log        root:network    640  3     100  *     JC
/var/log/devd.log                       644  3     100  *     JC
/var/log/security                       600  10    100  *     JC
/var/log/sendmail.st                    640  10    *    168   B
/var/log/utx.log                        644  3     *    @01T05 B
/var/log/weekly.log                     640  5     1    $W6D0 JN
/var/log/xferlog                        600  7     100  *     JC
....

각 줄은 회전할 로그의 이름으로 시작하며, 선택적으로 회전된 파일과 새로 생성된 파일 모두에 대한 소유자와 그룹이 뒤따릅니다. `mode` 필드는 로그 파일에 대한 권한을 설정하고 `count` 는 보관해야 하는 회전된 로그 파일 수를 나타냅니다. `size` 및 `when` 필드는 파일을 회전할 시기를 newsyslog에 알려줍니다. 로그 파일은 크기가 `size` 필드보다 크거나 `when` 필드의 시간이 지나면 회전됩니다. 별표( `*` )는 이 필드가 무시됨을 의미합니다. _flags_ 필드는 회전된 파일을 압축하는 방법이나 누락된 경우 로그 파일을 생성하는 방법과 같은 추가 지침을 제공합니다. 마지막 두 필드는 선택 사항이며 프로세스의 프로세스 ID(PID) 파일 이름과 파일이 회전될 때 해당 프로세스로 전송할 신호 번호를 지정합니다.

모든 필드, 유효한 플래그 및 로테이션 시간을 지정하는 방법에 대한 자세한 내용은 man:newsyslog.conf[5]를 참조하세요. newsyslog는 man:cron[8]에서 실행되기 때문에 man:cron[8]에서 실행되도록 예약된 것보다 더 자주 파일을 회전시킬 수는 없습니다.

[[network-syslogd]]
=== 원격 로깅 구성하기

시스템 수가 증가함에 따라 여러 호스트의 로그 파일을 모니터링하는 것이 부담스러워질 수 있습니다. 중앙 집중식 로깅을 구성하면 로그 파일 관리의 관리 부담을 일부 줄일 수 있습니다.

FreeBSD에서 중앙 집중식 로그 파일 집계, 병합 및 로테이션은 syslogd와 newsyslog를 사용하여 구성할 수 있습니다. 이 섹션에서는 `logserv.example.com` 이라는 이름의 호스트 `A` 가 로컬 네트워크에 대한 로깅 정보를 수집하는 구성 예시를 보여줍니다. 호스트 `B` 는 `logclient.example.com` 이라는 이름으로 로깅 정보를 로깅 서버로 전달하도록 구성됩니다.

==== 로그 서버 구성

로그 서버는 다른 호스트의 로깅 정보를 받아들이도록 구성된 시스템입니다. 로그 서버를 구성하기 전에 다음 사항을 확인하세요:

* 로깅 서버와 로깅 클라이언트 사이에 방화벽이 있는 경우 방화벽 규칙 집합이 클라이언트와 서버 모두에 대해 UDP 포트 514를 허용하는지 확인합니다.
* 로깅 서버와 모든 클라이언트 시스템에는 로컬 DNS에 정방향 및 역방향 항목이 있어야 합니다. 네트워크에 DNS 서버가 없는 경우 각 시스템의 [.filename]#/etc/hosts# 에 항목을 만듭니다. 로그 항목이 로깅 서버에서 거부되지 않도록 올바른 이름 확인이 필요합니다.

로그 서버에서 [.filename]#/etc/syslog.conf# 를 편집하여 로그 항목을 수신할 클라이언트의 이름, 사용할 로깅 facility, 호스트의 로그 항목을 저장할 로그의 이름을 지정합니다. 이 예제에서는 호스트 이름을 `B` 로 추가하고 모든 facility를 로깅한 후 로그 항목을 [.filename]#/var/log/logclient.log# 에 저장합니다.

.샘플 로그 서버 구성
[example]
====

[.programlisting]
....
+logclient.example.com
*.*     /var/log/logclient.log
....

====

여러 로그 클라이언트를 추가할 때는 각 클라이언트에 대해 비슷한 두 줄 항목을 추가하세요. 사용 가능한 기능에 대한 자세한 내용은 man:syslog.conf[5]에서 확인할 수 있습니다.

그런 다음 [.filename]#/etc/rc.conf# 을 구성합니다:

[.programlisting]
....
syslogd_enable="YES"
syslogd_flags="-a logclient.example.com -v -v"
....

첫 번째 항목은 시스템 부팅 시 syslogd를 시작합니다. 두 번째 항목은 지정된 클라이언트의 로그 항목을 허용합니다. `-v -v` 는 기록된 메시지의 상세도를 높입니다. 관리자가 각 기능에서 어떤 유형의 메시지가 기록되고 있는지 확인할 수 있으므로 기능을 조정하는 데 유용합니다.

여러 개의 `-a` 옵션을 지정하여 여러 클라이언트의 로깅을 허용할 수 있습니다. IP 주소와 전체 넷블록도 지정할 수 있습니다. 가능한 옵션의 전체 목록은 man:syslogd[8]를 참조하세요.

마지막으로 로그 파일을 생성합니다:

[source, shell]
....
# touch /var/log/logclient.log
....

이 시점에서 syslogd를 다시 시작하고 확인해야 합니다:

[source, shell]
....
# service syslogd restart
# pgrep syslog
....

PID가 반환되면 서버가 성공적으로 재시작된 것이며 클라이언트 구성을 시작할 수 있습니다. 서버가 다시 시작되지 않았다면 [.filename]#/var/log/messages# 에서 오류를 참조하세요.

==== 로그 클라이언트 구성

로깅 클라이언트는 로그 항목을 네트워크의 로깅 서버로 전송합니다. 클라이언트는 자체 로그의 로컬 복사본도 보관합니다.

로깅 서버가 구성되면 로깅 클라이언트에서 [.filename]#/etc/rc.conf# 를 편집합니다:

[.programlisting]
....
syslogd_enable="YES"
syslogd_flags="-s -v -v"
....

첫 번째 항목은 부팅 시 syslogd를 활성화합니다. 두 번째 항목은 이 클라이언트가 다른 호스트( `-s` )로부터 로그를 수신하지 못하도록 하고 기록된 메시지의 상세도를 높입니다.

그런 다음 클라이언트의 [.filename]#/etc/syslog.conf# 에서 로깅 서버를 정의합니다. 이 예제에서는 모든 로깅된 시설이 지정된 호스트 이름으로 `@` 기호로 표시된 원격 시스템으로 전송됩니다:

[.programlisting]
....
*.*		@logserv.example.com
....

편집 내용을 저장한 후 변경 내용을 적용하려면 syslogd를 다시 시작합니다:

[source, shell]
....
# service syslogd restart
....

로그 메시지가 네트워크를 통해 전송되고 있는지 테스트하려면 클라이언트에서 man:logger[1]를 사용하여 syslogd로 메시지를 보내세요:

[source, shell]
....
# logger "Test message from logclient"
....

이제 이 메시지는 클라이언트의 [.filename]#/var/log/messages# 와 로그 서버의 [.filename]#/var/log/logclient.log# 에 모두 존재해야 합니다.

==== 로그 서버 디버깅하기

로그 서버에 메시지가 수신되지 않는다면 네트워크 연결 문제, 호스트 이름 확인 문제 또는 구성 파일의 오타가 원인일 가능성이 높습니다. 원인을 파악하려면 로깅 서버와 로깅 클라이언트가 모두 [.filename]#/etc/rc.conf# 에 지정된 호스트명을 사용하여 서로를 `ping` 할 수 있는지 확인하세요. 실패하면 네트워크 케이블, 방화벽 규칙 집합, 로깅 서버와 클라이언트 모두의 DNS 서버 또는 [.filename]#/etc/hosts# 에 있는 호스트 이름 항목을 확인하세요. 두 호스트 모두에서 `ping` 이 성공할 때까지 이 과정을 반복합니다.

두 호스트 모두에서 `ping` 이 성공했지만 로그 메시지가 여전히 수신되지 않는 경우 일시적으로 로깅 상세도를 높여 구성 문제를 좁히세요. 다음 예제에서는 로깅 서버의 [.filename]#/var/log/logclient.log# 가 비어 있고 로깅 클라이언트의 [.filename]#/var/log/messages# 에 실패 사유가 표시되지 않습니다. 디버깅 출력을 늘리려면 로깅 서버에서 `syslogd_flags` 항목을 편집하고 다시 시작하세요:

[.programlisting]
....
syslogd_flags="-d -a logclient.example.com -v -v"
....

[source, shell]
....
# service syslogd restart
....

재시작 직후 콘솔에 다음과 유사한 디버깅 데이터가 깜박입니다:

[source, shell]
....
logmsg: pri 56, flags 4, from logserv.example.com, msg syslogd: restart
syslogd: restarted
logmsg: pri 6, flags 4, from logserv.example.com, msg syslogd: kernel boot file is /boot/kernel/kernel
Logging to FILE /var/log/messages
syslogd: kernel boot file is /boot/kernel/kernel
cvthname(192.168.1.10)
validate: dgram from IP 192.168.1.10, port 514, name logclient.example.com;
rejected in rule 0 due to name mismatch.
....

이 예에서는 오타로 인해 호스트 이름 불일치가 발생하여 로그 메시지가 거부되고 있습니다. 클라이언트의 호스트 이름은 `logclient` 가 아니라 `logclien` 이어야 합니다. 오타를 수정하고 다시 시작한 후 결과를 확인합니다:

[source, shell]
....
# service syslogd restart
logmsg: pri 56, flags 4, from logserv.example.com, msg syslogd: restart
syslogd: restarted
logmsg: pri 6, flags 4, from logserv.example.com, msg syslogd: kernel boot file is /boot/kernel/kernel
syslogd: kernel boot file is /boot/kernel/kernel
logmsg: pri 166, flags 17, from logserv.example.com,
msg Dec 10 20:55:02 <syslog.err> logserv.example.com syslogd: exiting on signal 2
cvthname(192.168.1.10)
validate: dgram from IP 192.168.1.10, port 514, name logclient.example.com;
accepted in rule 0.
logmsg: pri 15, flags 0, from logclient.example.com, msg Dec 11 02:01:28 trhodes: Test message 2
Logging to FILE /var/log/logclient.log
Logging to FILE /var/log/messages
....

이 시점에서는 메시지가 제대로 수신되어 올바른 파일에 저장되고 있는 것입니다.

==== 보안 고려사항

다른 네트워크 서비스와 마찬가지로 로깅 서버를 구현하기 전에 보안 요구 사항을 고려해야 합니다. 로그 파일에는 로컬 호스트에서 활성화된 서비스, 사용자 계정 및 구성 데이터에 대한 민감한 데이터가 포함될 수 있습니다. 클라이언트에서 서버로 전송되는 네트워크 데이터는 암호화되거나 비밀번호로 보호되지 않습니다. 암호화가 필요한 경우, 암호화된 터널을 통해 로깅 데이터를 전송하는 package:security/stunnel[] 사용을 고려하세요.

로컬 보안도 문제입니다. 로그 파일은 사용 중 또는 로그 로테이션 후에 암호화되지 않습니다. 로컬 사용자는 로그 파일에 액세스하여 시스템 구성에 대한 추가 인사이트를 얻을 수 있습니다. 로그 파일에 대한 적절한 권한을 설정하는 것이 중요합니다. 기본 제공 로그 로테이터인 newsyslog는 새로 생성 및 로테이션되는 로그 파일에 대한 권한 설정을 지원합니다. 로그 파일을 `600` 모드로 설정하면 로컬 사용자의 원치 않는 액세스를 방지할 수 있습니다. 자세한 내용은 man:newsyslog.conf[5]를 참조하세요.

[[configtuning-configfiles]]
== 구성 파일

=== [.filename]#/etc# 레이아웃

구성 정보가 저장되는 디렉터리에는 여러 가지가 있습니다. 여기에는 다음이 포함됩니다:

[.informaltable]
[cols="1,1", frame="none"]
|===

|[.filename]#/etc#
|Generic system-specific configuration information.

|[.filename]#/etc/defaults#
|Default versions of system configuration files.

|[.filename]#/etc/mail#
|Extra man:sendmail[8] configuration and other MTA configuration files.

|[.filename]#/etc/ppp#
|Configuration for both user- and kernel-ppp programs.

|[.filename]#/usr/local/etc#
|Configuration files for installed applications. May contain per-application subdirectories.

|[.filename]#/usr/local/etc/rc.d#
|man:rc[8] scripts for installed applications.

|[.filename]#/var/db#
|Automatically generated system-specific database files, such as the package database and the man:locate[1] database.
|===

=== Hostnames

==== [.filename]#/etc/resolv.conf#

FreeBSD 시스템이 인터넷 도메인 네임 시스템(DNS)에 액세스하는 방법은 man:resolv.conf[5]에 의해 제어됩니다.

[.filename]#/etc/resolv.conf# 의 가장 일반적인 항목은 다음과 같습니다:

[.informaltable]
[cols="1,1", frame="none"]
|===

|`nameserver`
|The IP address of a name server the resolver should query. The servers are queried in the order listed with a maximum of three.

|`search`
|Search list for hostname lookup. This is normally determined by the domain of the local hostname.

|`domain`
|The local domain name.
|===

일반적인 [.filename]#/etc/resolv.conf# 는 다음과 같습니다:

[.programlisting]
....
search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30
....

[NOTE]
====
`search` 및 `domain` 옵션 중 하나만 사용해야 합니다.
====

DHCP를 사용할 때 man:dhclient[8]는 일반적으로 DHCP 서버에서 받은 정보로 [.filename]#/etc/resolv.conf# 를 다시 작성합니다.

==== [.filename]#/etc/hosts#

[.filename]#/etc/hosts# 는 DNS 및 NIS와 함께 작동하여 호스트 이름과 IP 주소 매핑을 제공하는 간단한 텍스트 데이터베이스입니다. LAN을 통해 연결된 로컬 컴퓨터에 대한 항목은 man:named[8] 서버를 설정하는 대신 간단한 명명 목적으로 이 파일에 추가할 수 있습니다. 또한 [.filename]#/etc/hosts# 을 사용하여 인터넷 이름의 로컬 레코드를 제공할 수 있으므로 일반적으로 액세스하는 이름을 외부 DNS 서버에 쿼리할 필요성을 줄일 수 있습니다.

[.programlisting]
....
# $FreeBSD$
#
#
# Host Database
#
# This file should contain the addresses and aliases for local hosts that
# share this file.  Replace 'my.domain' below with the domainname of your
# machine.
#
# In the presence of the domain name service or NIS, this file may
# not be consulted at all; see /etc/nsswitch.conf for the resolution order.
#
#
::1			localhost localhost.my.domain
127.0.0.1		localhost localhost.my.domain
#
# Imaginary network.
#10.0.0.2		myname.my.domain myname
#10.0.0.3		myfriend.my.domain myfriend
#
# According to RFC 1918, you can use the following IP networks for
# private nets which will never be connected to the Internet:
#
#	10.0.0.0	-   10.255.255.255
#	172.16.0.0	-   172.31.255.255
#	192.168.0.0	-   192.168.255.255
#
# In case you want to be able to connect to the Internet, you need
# real official assigned numbers.  Do not try to invent your own network
# numbers but instead get one from your network provider (if any) or
# from your regional registry (ARIN, APNIC, LACNIC, RIPE NCC, or AfriNIC.)
#
....

[.filename]#/etc/hosts# 의 형식은 다음과 같습니다:

[.programlisting]
....
[Internet address] [official hostname] [alias1] [alias2] ...
....

예를 들어:

[.programlisting]
....
10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2
....

자세한 내용은 man:hosts[5]를 참조하세요.

[[configtuning-sysctl]]
== man:sysctl[8]로 튜닝하기

man:sysctl[8]은 실행 중인 FreeBSD 시스템을 변경하는 데 사용됩니다. 여기에는 숙련된 시스템 관리자의 성능을 크게 향상시킬 수 있는 TCP/IP 스택과 가상 메모리 시스템의 많은 고급 옵션이 포함됩니다. 500개 이상의 시스템 변수를 man:sysctl[8]을 사용하여 읽고 설정할 수 있습니다.

man:sysctl[8]은 기본적으로 시스템 설정을 읽고 수정하는 두 가지 기능을 수행합니다.

읽기 가능한 모든 변수를 보려면:

[source, shell]
....
% sysctl -a
....

특정 변수를 읽으려면 해당 이름을 지정합니다:

[source, shell]
....
% sysctl kern.maxproc
kern.maxproc: 1044
....

특정 변수를 설정하려면 _variable_=_value_ 구문을 사용합니다:

[source, shell]
....
# sysctl kern.maxfiles=5000
kern.maxfiles: 2088 -> 5000
....

sysctl 변수의 설정은 일반적으로 문자열, 숫자 또는 부울이며, 여기서 부울은 예인 경우 `1`, 아니오인 경우 `0` 입니다.

머신이 부팅될 때마다 일부 변수를 자동으로 설정하려면 [.filename]#/etc/sysctl.conf# 에 추가합니다. 자세한 내용은 man:sysctl.conf[5] 및 <<configtuning-sysctlconf>> 을 참조하세요.

[[configtuning-sysctlconf]]
=== [.filename]#sysctl.conf#

man:sysctl[8]의 구성 파일인 [.filename]#/etc/sysctl.conf# 는 [.filename]#/etc/rc.conf# 와 매우 유사합니다. 값은 `variable=value` 형식으로 설정됩니다. 지정된 값은 시스템이 다중 사용자 모드로 전환된 후에 설정됩니다. 이 모드에서 모든 변수를 설정할 수 있는 것은 아닙니다.

예를 들어 치명적인 신호 종료 로깅을 끄고 다른 사용자가 시작한 프로세스가 사용자에게 표시되지 않도록 하려면 [.filename]#/etc/sysctl.conf# 에서 다음 튜너블을 설정하면 됩니다:

[.programlisting]
....
# Do not log fatal signal exits (e.g., sig 11)
kern.logsigexit=0

# Prevent users from seeing information about processes that
# are being run under another UID.
security.bsd.see_other_uids=0
....

[[sysctl-readonly]]
=== man:sysctl[8] 읽기 전용

경우에 따라 시스템을 재부팅해야 하는 읽기 전용 man:sysctl[8] 값을 수정하는 것이 바람직할 수 있습니다.

예를 들어, 일부 노트북 모델에서 man:cardbus[4] 장치는 메모리 범위를 조사하지 않으며 다음과 유사한 오류로 실패합니다:

[source, shell]
....
cbb0: Could not map register memory
device_probe_and_attach: cbb0 attach returned 12
....

이 문제를 해결하려면 읽기 전용 man:sysctl[8] 설정을 수정해야 합니다. [.filename]#/boot/loader.conf# 에 `hw.pci.allow_unsupported_io_range=1` 을 추가하고 재부팅합니다. 이제 man:cardbus[4]가 제대로 작동합니다.

[[configtuning-disk]]
== 디스크 튜닝

다음 섹션에서는 디스크 장치에 적용할 수 있는 다양한 튜닝 메커니즘과 옵션에 대해 설명합니다. 대부분의 경우 SCSI 드라이브와 같은 기계적 부품이 포함된 디스크는 전체 시스템 성능을 저하시키는 병목 현상을 유발합니다. 솔리드 스테이트 드라이브와 같이 기계적 부품이 없는 드라이브를 설치하는 것이 해결책이 될 수 있지만, 기계식 드라이브는 가까운 장래에 사라지지 않을 것입니다. 디스크를 튜닝할 때는 man:iostat[8] 명령의 기능을 활용하여 시스템에 대한 다양한 변경 사항을 테스트하는 것이 좋습니다. 이 명령을 통해 사용자는 시스템 I/O에 대한 유용한 정보를 얻을 수 있습니다.

=== Sysctl 변수

==== `vfs.vmiodirenable`

`vfs.vmiodirenable` man:sysctl[8] 변수는 `0` (꺼짐) 또는 `1` (켜짐)로 설정할 수 있습니다. 기본적으로 `1` 로 설정되어 있습니다. 이 변수는 시스템에서 디렉터리를 캐시하는 방법을 제어합니다. 대부분의 디렉터리는 파일 시스템에서 단일 조각(일반적으로 1K)만 사용하고 버퍼 캐시에서 일반적으로 512바이트를 사용하는 작은 크기입니다. 이 변수를 끄면 시스템에 엄청난 양의 메모리가 있더라도 버퍼 캐시는 정해진 수의 디렉터리만 캐시합니다. 이 man:sysctl[8]을 켜면 버퍼 캐시가 VM 페이지 캐시를 사용하여 디렉터리를 캐시할 수 있으므로 디렉터리를 캐시하는 데 모든 메모리를 사용할 수 있습니다. 그러나 디렉토리를 캐시하는 데 사용되는 최소 인코어 메모리는 512바이트가 아닌 물리적 페이지 크기(일반적으로 4K)입니다. 시스템에서 많은 수의 파일을 조작하는 서비스를 실행하는 경우 이 옵션을 활성화하는 것이 좋습니다. 이러한 서비스에는 웹 캐시, 대용량 메일 시스템 및 뉴스 시스템이 포함될 수 있습니다. 이 옵션을 켜두면 일반적으로 메모리가 낭비되더라도 성능이 저하되지 않지만 실험을 통해 확인해야 합니다.

==== `vfs.write_behind`

`vfs.write_behind` man:sysctl[8] 변수의 기본값은 `1` (켜짐)입니다. 이는 일반적으로 대용량 순차 파일을 쓸 때 발생하는 전체 클러스터가 수집될 때 미디어 쓰기를 실행하도록 파일 시스템에 지시합니다. 이렇게 하면 I/O 성능에 도움이 되지 않을 때 더티 버퍼로 버퍼 캐시가 포화되는 것을 방지할 수 있습니다. 하지만 프로세스가 중단될 수 있으므로 특정 상황에서는 이 기능을 해제해야 합니다.

==== `vfs.hirunningspace`

`vfs.hirunningspace` man:sysctl[8] 변수는 특정 인스턴스에서 시스템 전체의 디스크 컨트롤러 큐에 대기할 수 있는 미결 쓰기 I/O의 양을 결정합니다. 기본값은 일반적으로 충분하지만 디스크가 많은 시스템에서는 4~5 _메가바이트_ 까지 늘려보세요. 버퍼 캐시의 쓰기 임계값을 초과하는 값을 너무 높게 설정하면 클러스터링 성능이 저하될 수 있습니다. 쓰기 값이 높으면 동시에 발생하는 읽기에 지연 시간이 추가될 수 있으므로 이 값을 임의로 높게 설정하지 마세요.

그 외에도 버퍼 캐시 및 VM 페이지 캐시와 관련된 다양한 man:sysctl[8] 값이 있습니다. 이러한 값은 VM 시스템에서 자동으로 잘 조정되므로 수정하지 않는 것이 좋습니다.

==== `vm.swap_idle_enabled`

man:sysctl[8] 의 `vm.swap_idle_enabled` 변수는 활성 로그인 사용자가 많고 유휴 프로세스가 많은 대규모 다중 사용자 시스템에서 유용합니다. 이러한 시스템은 사용 가능한 메모리에 지속적인 압박을 가하는 경향이 있습니다. 이 기능을 켜고 `vm.swap_idle_threshold1` 및 `vm.swap_idle_threshold2` 를 통해 스왑아웃 히스테리시스(유휴 초 단위)를 조정하면 일반 페이지아웃 알고리즘보다 유휴 프로세스와 관련된 메모리 페이지의 우선 순위가 더 빨리 낮아집니다. 이는 페이지아웃 데몬에 도움을 줍니다. 이 옵션은 기본적으로 메모리를 더 빨리 사전 페이지화하여 더 많은 스왑 및 디스크 대역폭을 사용한다는 단점이 있으므로 필요한 경우에만 이 옵션을 켜세요. 소규모 시스템에서는 이 옵션이 결정적인 영향을 미치지만, 이미 중간 정도의 페이징을 수행하는 대규모 시스템에서는 이 옵션을 사용하면 VM 시스템이 전체 프로세스를 메모리 안팎으로 쉽게 스테이징할 수 있습니다.

==== `hw.ata.wc`

IDE 쓰기 캐싱을 끄면 IDE 디스크에 대한 쓰기 대역폭이 줄어들지만, 하드 드라이브 공급업체에서 도입한 데이터 일관성 문제를 해결하기위해 필요할 수도 있습니다. 문제는 일부 IDE 드라이브가 쓰기 완료 시점에 대해 거짓말을 한다는 것입니다. IDE 쓰기 캐싱이 켜져 있으면 IDE 하드 드라이브는 디스크에 데이터를 순서대로 쓰지 않고 디스크 부하가 많을 때 일부 블록 쓰기를 무기한 지연시킬 수 있습니다. 충돌 또는 정전으로 인해 심각한 파일 시스템 손상이 발생할 수 있습니다. `hw.ata.wc` man:sysctl[8] 변수를 관찰하여 시스템의 기본값을 확인하십시오. IDE 쓰기 캐싱이 꺼져 있는 경우, 부팅 시 활성화하려면 [.filename]#/boot/loader.conf# 에서 이 읽기 전용 변수를 `1` 로 설정합니다.

자세한 내용은 man:ata[4]를 참조하세요.

==== `SCSI_DELAY` (`kern.cam.scsi_delay`)

시스템 부팅 시간을 줄이기 위해 `SCSI_DELAY` 커널 구성 옵션을 사용할 수 있습니다. 기본값은 상당히 높으며 부팅 프로세스에서 `15` 초의 지연을 초래할 수 있습니다. 이를 `5` 초로 줄여도 일반적인 최신 드라이브에서 잘 작동합니다. 부팅 시간 튜너블인 `kern.cam.scsi_delay` 를 사용해야 합니다. 튜너블 및 커널 구성 옵션은 _초 단위_ 가 아닌, _밀리초(ms)_ 단위를 사용합니다.

[[soft-updates]]
=== 소프트 업데이트 (Soft Updates)

파일 시스템을 미세 조정하려면 man:tunefs[8]를 사용하세요. 이 프로그램에는 다양한 옵션이 있습니다. 소프트 업데이트를 켜고 끄려면 다음을 사용합니다:

[source, shell]
....
# tunefs -n enable /filesystem
# tunefs -n disable /filesystem
....

파일 시스템이 마운트되어 있는 동안에는 man:tunefs[8]로 파일 시스템을 수정할 수 없습니다. 단일 사용자 모드에서 파티션을 마운트하기 전에 소프트 업데이트를 활성화하는 것이 좋습니다.

소프트 업데이트는 메모리 캐시를 사용하여 주로 파일 생성 및 삭제와 같은 메타데이터 성능을 크게 향상시키므로 UFS 파일 시스템에서 권장됩니다. 소프트 업데이트에는 두 가지 단점이 있습니다. 첫째, 소프트 업데이트는 충돌이 발생할 경우 파일 시스템 일관성을 보장하지만, 실제 디스크 업데이트보다 몇 초 또는 몇 분 정도 늦어질 수 있습니다. 시스템이 충돌하면 기록되지 않은 데이터가 손실될 수 있습니다. 둘째, 소프트 업데이트는 파일 시스템 블록의 해제 시간을 지연시킵니다. 루트 파일 시스템이 거의 꽉 차 있는 경우 `make installworld` 와 같은 큰 규모의 업데이트를 수행하면 파일 시스템의 공간이 부족하여 업데이트가 실패할 수 있습니다.

==== 소프트 업데이트에 대한 보다 자세한 정보

메타데이터 업데이트는 이노드나 디렉터리와 같은 콘텐츠가 아닌 데이터에 대한 업데이트입니다. 파일 시스템의 메타데이터를 디스크에 다시 쓰는 전통적인 접근 방식에는 두 가지가 있습니다.

역사적으로 메타데이터 업데이트를 동기식으로 기록하는 것이 기본 동작이었습니다. 디렉터리가 변경되면 시스템은 변경 내용이 실제로 디스크에 기록될 때까지 기다렸습니다. 파일 데이터 버퍼(파일 내용)는 버퍼 캐시를 통과하여 나중에 비동기적으로 디스크에 백업되었습니다. 이 구현의 장점은 안전하게 작동한다는 것입니다. 업데이트 중에 장애가 발생하더라도 메타데이터는 항상 일관된 상태를 유지합니다. 파일은 완전히 생성되거나 전혀 생성되지 않습니다. 파일의 데이터 블록이 크래시 시점까지 버퍼 캐시에서 디스크로 이동하지 못한 경우, man:fsck[8]는 이를 인식하고 파일 길이를 `0` 으로 설정하여 파일 시스템을 복구합니다. 또한 구현이 명확하고 간단합니다. 단점은 메타 데이터 변경이 느리다는 것입니다. 예를 들어 `rm -r` 은 디렉터리의 모든 파일을 순차적으로 변경하지만 각 디렉터리 변경 사항은 디스크에 동기적으로 기록됩니다. 여기에는 디렉터리 자체, inode 테이블, 파일이 할당하는 간접 블록에 대한 업데이트가 포함됩니다. `tar -x` 를 사용하여 복잡한 계층 구조의 압축을 풀 때도 비슷한 고려 사항이 적용됩니다.

두 번째 접근 방식은 비동기 메타데이터 업데이트를 사용하는 것입니다. 이것은 `mount -o async` 로 마운트된 UFS 파일 시스템의 기본값입니다. 모든 메타데이터 업데이트도 버퍼 캐시를 통해 전달되므로 파일 콘텐츠 데이터의 업데이트와 혼합됩니다. 이 구현의 장점은 각 메타데이터 업데이트가 디스크에 기록될 때까지 기다릴 필요가 없으므로 대량의 메타데이터 업데이트를 유발하는 모든 작업이 동기식 경우보다 훨씬 빠르게 작동한다는 것입니다. 이 구현은 여전히 명확하고 간단하므로 코드에 버그가 숨어 있을 위험이 낮습니다. 단점은 파일 시스템의 일관된 상태를 보장할 수 없다는 것입니다. 대량의 메타데이터를 업데이트하는 작업 중에 정전이나 누군가 리셋 버튼을 누르는 등의 장애가 발생하면 파일 시스템이 예측할 수 없는 상태로 남게 됩니다. 파일의 데이터 블록은 이미 디스크에 기록되었을 수 있지만, 이노드 테이블이나 관련 디렉터리의 업데이트는 기록되지 않았을 수 있으므로 시스템이 다시 시작될 때 파일 시스템의 상태를 검사할 기회가 없습니다. 디스크에서 필요한 정보를 사용할 수 없기 때문에 그로 인한 혼돈을 정리할 수 있는 man:fsck[8]를 구현하는 것은 불가능합니다. 파일 시스템이 복구할 수 없을 정도로 손상된 경우 유일한 선택은 파일 시스템을 다시 포맷하고 백업에서 복원하는 것입니다.

이 문제에 대한 일반적인 해결책은 _저널링_ 이라고도 하는 _더티 영역 로깅_ 을 구현하는 것입니다. 메타데이터 업데이트는 여전히 동기식으로 기록되지만 디스크의 작은 영역에만 기록됩니다. 나중에 적절한 위치로 이동됩니다. 로깅 영역은 디스크의 작고 인접한 영역이므로 작업이 많은 경우에도 디스크 헤드가 이동해야 하는 거리가 길지 않으므로 이러한 작업이 동기식 업데이트보다 빠릅니다. 또한 구현의 복잡성이 제한되어 있으므로 버그가 발생할 위험이 낮습니다. 단점은 모든 메타데이터가 로깅 영역에 한 번, 적절한 위치에 한 번씩 두 번 기록되므로 성능이 저하될 수 있다는 것입니다. 반면에 충돌이 발생하면 보류 중인 모든 메타데이터 작업을 빠르게 롤백하거나 시스템이 다시 가동된 후 로깅 영역에서 완료할 수 있으므로 파일 시스템을 빠르게 시작할 수 있습니다.

버클리 FFS의 개발자 Kirk McKusick은 소프트 업데이트로 이 문제를 해결했습니다. 보류 중인 모든 메타데이터 업데이트는 메모리에 보관되고 정렬된 순서("정렬된 메타데이터 업데이트")로 디스크에 기록됩니다. 이렇게 하면 메타데이터 작업이 많은 경우 나중에 항목에 대한 업데이트가 아직 메모리에 남아 있고 디스크에 아직 기록되지 않은 이전 업데이트를 "포착"하는 효과가 있습니다. 모든 작업은 일반적으로 업데이트가 디스크에 기록되기 전에 메모리에서 수행되며, 데이터 블록은 위치에 따라 정렬되어 메타 데이터보다 디스크에 먼저 기록되지 않습니다. 시스템이 충돌하면 암시적 '로그 되감기'로 인해 디스크에 기록되지 않은 모든 작업이 마치 발생한 적이 없는 것처럼 표시됩니다. 30~60초 전의 파일 시스템 상태가 일관되게 유지됩니다. 사용된 알고리즘은 사용 중인 모든 리소스가 해당 블록과 이노드에 표시되도록 보장합니다. 크래시 후 발생하는 유일한 리소스 할당 오류는 실제로는 "비었음"인 리소스가 "사용 중"으로 표시되는 것입니다. man:fsck[8]는 이 상황을 인식하고 더 이상 사용되지 않는 리소스를 해제합니다. `mount -f` 로 강제 마운트하여 크래시 후 파일 시스템의 더티 상태를 무시하는 것이 안전합니다. 사용하지 않을 수 있는 리소스를 확보하려면 나중에 man:fsck[8]를 실행해야 합니다. 이것이 바로 시스템 시작 시 파일 시스템의 _스냅샷_ 만 기록하고 나중에 man:fsck[8]을 실행하는 _background man:fsck[8]_ 의 아이디어입니다. 그러면 모든 파일 시스템을 "더티" 마운트할 수 있으므로 시스템 시작이 다중 사용자 모드에서 진행됩니다. 그런 다음 백그라운드 man:fsck[8]가 필요한 모든 파일 시스템에 대해 스케줄링되어 사용되지 않을 수 있는 리소스를 해제합니다. 소프트 업데이트를 사용하지 않는 파일 시스템에는 여전히 일반적인 포그라운드 man:fsck[8]가 필요합니다.

장점은 메타데이터 작업이 비동기 업데이트만큼 빠르며 메타데이터를 두 번 써야 하는 _logging_ 보다 빠르다는 것입니다. 단점은 코드가 복잡하고 메모리를 더 많이 사용하며 몇 가지 특이한 점이 있다는 것입니다. 충돌 후 파일 시스템의 상태는 다소 "오래된" 것처럼 보입니다. 표준 동기식 접근 방식에서는 man:fsck[8] 이후에도 길이가 0인 파일이 일부 남아있을 수 있지만, 소프트 업데이트에서는 메타데이터나 파일 내용이 디스크에 기록되지 않았기 때문에 이러한 파일이 전혀 존재하지 않습니다. 디스크 공간은 업데이트가 디스크에 기록될 때까지 해제되지 않으며, 이는 man:rm[1]을 실행한 후 일정 시간이 지난 후에 발생할 수 있습니다. 모든 파일을 두 번 저장할 수 있는 충분한 여유 공간이 없는 파일 시스템에 많은 양의 데이터를 설치할 때 문제가 발생할 수 있습니다.

[[configtuning-kernel-limits]]
== 커널 제한 튜닝하기

[[file-process-limits]]
=== 파일/프로세스 제한

[[kern-maxfiles]]
==== `kern.maxfiles`

`kern.maxfiles` man:sysctl[8] 변수는 시스템 요구 사항에 따라 높이거나 낮출 수 있습니다. 이 변수는 시스템에서 파일 기술자(descriptor)의 최대 수를 나타냅니다. 파일 기술자 테이블이 가득 차면 시스템 메시지 버퍼에 `file: table is full` 이 반복적으로 표시되며, 이는 man:dmesg[8]을 사용하여 확인할 수 있습니다.

열려 있는 파일, 소켓 또는 fifo는 각각 하나의 파일 기술자를 사용합니다. 대규모 프로덕션 서버에는 동시에 실행되는 서비스의 종류와 수에 따라 수천 개의 파일 설명자가 필요할 수 있습니다.

이전 FreeBSD 릴리즈에서, `kern.maxfiles` 의 기본값은 커널 구성 파일의 `maxusers` 에서 파생됩니다. `kern.maxfiles` 는 `maxusers` 의 값에 비례하여 증가합니다. 커스텀 커널을 컴파일할 때 시스템 용도에 따라 이 커널 구성 옵션을 설정하는 것을 고려하세요. 이 수치에서 커널은 대부분의 사전 정의된 한계를 부여받습니다. 프로덕션 머신의 동시 사용자 수가 256명이 아닐지라도 필요한 리소스는 대규모 웹 서버와 비슷할 수 있습니다.

읽기 전용 man:sysctl[8] 변수 `kern.maxusers` 는 시스템에서 사용 가능한 메모리 양에 따라 부팅 시 자동으로 크기가 결정되며, 런타임에 `kern.maxusers` 의 값을 검사하여 결정될 수 있습니다. 일부 시스템에서는 더 크거나 작은 값을 필요로 하며 `64`, `128`, `256` 의 값은 드물지 않습니다. 많은 수의 파일 기술자가 필요하지 않는 한 `256` 을 초과하는 것은 권장하지 않습니다. `kern.maxusers` 에 의해 기본값으로 설정된 많은 조정 가능한 값은 부팅 시간 또는 런타임에 [.filename]#/boot/loader.conf# 에서 개별적으로 재정의할 수 있습니다. 자세한 내용과 몇 가지 힌트는 man:loader.conf[5] 및 [.filename]#/boot/defaults/loader.conf# 를 참조하세요.

과거 릴리스에선 `maxusers` 가 `0` 으로 설정되어 있으면 자동 튜닝이 되었습니다. footnote:[자동 튜닝 알고리즘은 최소 32에서 최대 384까지 시스템의 메모리 양과 동일한 최대 사용자를 자동 튜닝합니다.] 이 옵션을 설정할 때, 특히 시스템이 Xorg를 실행하거나 소프트웨어 컴파일에 사용되는 경우 `maxusers` 를 최소 `4` 로 설정하세요. `maxusers` 로 설정되는 가장 중요한 테이블은 최대 프로세스 수이며, `20 + 16 * maxusers` 로 설정됩니다. `maxusers` 가 `1` 로 설정되면 부팅 시 시스템이 시작되는 `18` 개와 Xorg가 사용하는 `15` 개를 포함하여 총 `36` 개의 동시 프로세스만 있을 수 있습니다. 매뉴얼 페이지를 읽는 것과 같은 간단한 작업도 필터링, 압축 해제 및 보기를 위해 9개의 프로세스가 시작됩니다. `maxusers` 를 `64` 로 설정하면 최대 `1044` 개의 프로세스를 동시에 처리할 수 있으므로 거의 모든 용도에 충분합니다. 그러나 다른 프로그램을 시작하려고 할 때 오류가 표시되거나 동시 사용자 수가 많은 서버를 실행 중인 경우 수를 늘린 후 다시 빌드하세요.

[NOTE]
====
`maxusers` 는 시스템에 로그인할 수 있는 사용자 수를 _제한하지 않습니다_ . 대신 시스템의 최대 사용자 수와 각 사용자가 실행할 프로세스 수를 고려하여 다양한 테이블 크기를 합리적인 값으로 설정합니다.
====

==== `kern.ipc.soacceptqueue`

`kern.ipc.soacceptqueue` man:sysctl[8] 변수는 새 `TCP` 연결을 수락하기 위한 수신 대기열의 크기를 제한합니다. 기본값인 `128` 은 일반적으로 부하가 많은 웹 서버에서 새 연결을 안정적으로 처리하기에는 너무 낮습니다. 이러한 환경에서는 이 값을 `1024` 이상으로 늘리는 것이 좋습니다. man:sendmail[8]이나 아파치 같은 서비스는 자체적으로 수신 대기열 크기를 제한할 수도 있지만, 구성 파일에 대기열 크기를 조정하는 지시어가 있는 경우가 많습니다. 수신 대기열이 크면 서비스 거부(DoS) 공격을 더 잘 피할 수 있습니다.

[[nmbclusters]]
=== 네트워크 제한

커널 구성 옵션인 `NMBCLUSTERS` 는 시스템에서 사용할 수 있는 네트워크 Mbuf의 양을 결정합니다. 트래픽이 많은 서버에서 Mbuf 수가 적으면 성능이 저하됩니다. 각 클러스터는 약 2K의 메모리를 나타내므로 `1024` 값은 네트워크 버퍼를 위해 예약된 커널 메모리의 `2` 메가바이트를 나타냅니다. 간단한 계산을 통해 얼마나 많은 메모리가 필요한지 알아낼 수 있습니다. 각 연결이 6K 수신 및 16K 전송 버퍼를 사용하는 동시 연결이 최대 `1000` 인 웹 서버의 경우 웹 서버를 처리하려면 약 32MB 상당의 네트워크 버퍼가 필요합니다. 경험상 `2` 를 곱하는 것이 좋으므로 2x32MB/2KB = 64MB/2kB = `32768` 입니다. `4096` 에서 `32768` 사이의 값은 메모리 용량이 더 큰 컴퓨터에 권장됩니다. 이 매개변수에 임의로 높은 값을 지정하면 부팅 시간 충돌이 발생할 수 있으므로 절대로 높은 값을 지정하지 마십시오. 네트워크 클러스터 사용량을 관찰하려면 `-m` 을 man:netstat[1]과 함께 사용하세요.

부팅할 때 `kern.ipc.nmbclusters` 로더 튜너블을 사용하여 이를 조정해야 합니다. 이전 버전의 FreeBSD에서만 `NMBCLUSTERS` 커널 man:config[8] 옵션을 사용해야 합니다.

man:sendfile[2] 시스템 호출을 광범위하게 사용하는 바쁜 서버의 경우, `NSFBUFS` 커널 구성 옵션을 통해 또는 [.filename]#/boot/loader.conf# 에 값을 설정하여 man:sendfile[2] 버퍼 수를 늘려야 할 수 있습니다(자세한 내용은 man:loader[8] 참고). 이 매개변수를 조정해야 하는 일반적인 지표는 프로세스가 `sfbufa` 상태로 표시되는 경우입니다. man:sysctl[8] 변수 `kern.ipc.nsfbufs` 는 읽기 전용입니다. 이 매개변수는 명목상 `kern.maxusers` 에 따라 스케일링되지만 직접 조정해야 할 수도 있습니다.

[IMPORTANT]
====
소켓이 비차단 소켓으로 표시되어 있더라도, 비차단 소켓에서 man:sendfile[2]을 호출하면 충분한 ``struct sf_buf`` 를 사용할 수 있을 때까지 man:sendfile[2] 호출이 차단될 수 있습니다.
====

==== `net.inet.ip.portrange.*`

`net.inet.ip.portrange.*` man:sysctl[8] 변수는 `TCP` 및 `UDP` 소켓에 자동으로 바인딩되는 포트 번호 범위를 제어합니다. 낮은 범위, 기본 범위, 높은 범위의 세 가지 범위가 있습니다. 대부분의 네트워크 프로그램은 `net.inet.ip.portrange.first` 와 `net.inet.ip.portrange.last` 에 의해 제어되는 기본 범위를 사용하며, 기본값은 각각 `1024` 와 `5000` 입니다. 바운드 포트 범위는 나가는 연결에 사용되며 특정 상황에서는 포트가 부족하여 시스템이 고갈될 수 있습니다. 이는 부하가 많은 웹 프록시를 실행할 때 가장 일반적으로 발생합니다. 웹 서버와 같이 주로 들어오는 연결을 처리하거나 메일 릴레이와 같이 나가는 연결 수가 제한되어 있는 서버를 실행할 때는 포트 범위가 문제가 되지 않습니다. 포트가 부족한 상황에서는 `net.inet.ip.portrange.last` 를 적당히 늘리는 것이 좋습니다. `10000`, `20000` 또는 `30000` 의 값이 적당할 수 있습니다. 포트 범위를 변경할 때는 방화벽 효과를 고려하세요. 일부 방화벽은 넓은 범위의 포트(일반적으로 낮은 번호의 포트)를 차단하고 시스템이 나가는 연결에 더 높은 범위의 포트를 사용하도록 기대할 수 있습니다. 따라서 `net.inet.ip.portrange.first` 의 값을 낮추지 않는 것이 좋습니다.

=== 가상 메모리

==== `kern.maxvnodes`

vnode는 파일 또는 디렉터리의 내부 표현입니다. 운영 체제에서 사용할 수 있는 vnode 수를 늘리면 디스크 I/O가 줄어듭니다. 일반적으로 이는 운영 체제에서 처리하므로 변경할 필요가 없습니다. 디스크 I/O가 병목 현상이 발생하여 시스템 vnode가 부족한 경우에는 이 설정을 늘려야 하는 경우도 있습니다. 비활성 및 사용 가능한 RAM의 양을 고려해야 합니다.

현재 사용 중인 vnode 수를 확인하려면:

[source, shell]
....
# sysctl vfs.numvnodes
vfs.numvnodes: 91349
....

최대 vnode 수를 확인하려면:

[source, shell]
....
# sysctl kern.maxvnodes
kern.maxvnodes: 100000
....

현재 vnode 사용량이 최대치에 가까우면 `kern.maxvnodes` 값을 `1000` 만큼 늘려보십시오. `vfs.numvnodes` 의 수를 주시합니다. 다시 최대치까지 올라간다면 `kern.maxvnodes` 를 더 늘려야 합니다. 그렇지 않으면, man:top[1]에 보고된 메모리 사용량의 변화를 볼 수 있어야 하며 더 많은 메모리가 활성화되어야 합니다.

[[adding-swap-space]]
== 스왑 공간 추가하기

시스템에 더 많은 스왑 공간이 필요한 경우가 있습니다. 이 섹션에서는 기존 파티션 또는 새 하드 드라이브에 스왑을 추가하는 방법과 기존 파티션에 스왑 파일을 만드는 두 가지 스왑 공간을 늘리는 방법에 대해 설명합니다.

스왑 공간을 암호화하는 방법, 어떤 옵션이 있는지, 왜 암호화해야 하는지에 대한 자세한 내용은 crossref:disks[swap-encrypting,“Encrypting Swap”]를 참조하세요.

[[new-drive-swap]]
=== 새 하드 드라이브 또는 기존 파티션에서 스왑

스왑을 위해 새 하드 드라이브를 추가하면 기존 드라이브의 파티션을 사용하는 것보다 더 나은 성능을 제공합니다. 파티션 및 하드 드라이브 설정은 crossref:disks[disks-adding,“Adding Disks”] 에 설명되어 있으며, crossref:bsdinstall[configtuning-initial,“Designing the Partition Layout”]에서는 파티션 레이아웃과 스왑 파티션 크기 고려 사항에 대해 설명합니다.

`swapon` 을 사용하여 시스템에 스왑 파티션을 추가합니다. 예를 들어:

[source, shell]
....
# swapon /dev/ada1s1b
....

[WARNING]
====

현재 마운트되지 않은 파티션은 이미 데이터가 포함되어 있더라도 사용할 수 있습니다. 데이터가 있는 파티션에 `swapon` 을 사용하면 해당 데이터를 덮어쓰고 파괴합니다. `swapon` 을 실행하기 전에 스왑으로 추가할 파티션이 실제로 의도한 파티션인지 확인하세요.
====

부팅 시 이 스왑 파티션을 자동으로 추가하려면 [.filename]#/etc/fstab# 에 내용을 추가하세요:

[.programlisting]
....
/dev/ada1s1b	none	swap	sw	0	0
....

[.filename]#/etc/fstab# 의 항목에 대한 설명은 man:fstab[5]를 참조하세요. `swapon` 에 대한 자세한 정보는 man:swapon[8]에서 확인할 수 있습니다.

[[create-swapfile]]
=== 스왑 파일 생성하기

이 예제에서는 파티션을 사용하는 대신 [.filename]#/usr/swap0# 이라는 512M 스왑 파일을 생성합니다.

스왑 파일을 사용하려면 man:md[4]에 필요한 모듈이 커널에 빌드되었거나 스왑이 활성화되기 전에 로드되어 있어야 합니다. 커스텀 커널을 빌드하는 방법에 대한 정보는 crossref:kernelconfig[kernelconfig,Configuring the FreeBSD Kernel]를 참고하세요.

[[swapfile-10-and-later]]
.스왑 파일 생성하기
[example]
====
[.procedure]
. 스왑 파일을 생성합니다:
+
[source, shell]
....
# dd if=/dev/zero of=/usr/swap0 bs=1m count=512
....

. 새 파일에 적절한 권한을 설정합니다:
+
[source, shell]
....
# chmod 0600 /usr/swap0
....

. [.filename]#/etc/fstab# 에 한 줄을 추가하여 스왑 파일에 대해 시스템에 알립니다:
+
[.programlisting]
....
md	none	swap	sw,file=/usr/swap0,late	0	0
....
+
. 스왑 공간은 시스템 시작 시 추가됩니다. 스왑 공간을 즉시 추가하려면 man:swapon[8]을 사용합니다:
+
[source, shell]
....
# swapon -aL
....

====

[[acpi-overview]]
== 전원 및 리소스 관리

하드웨어 리소스를 효율적으로 활용하는 것이 중요합니다. 전력 및 리소스 관리를 통해 운영 체제는 시스템 한계를 모니터링하고 시스템 온도가 예기치 않게 상승할 경우 경고를 제공할 수 있습니다. 전력 관리를 제공하기 위한 초기 사양은 고급 전원 관리(APM) 기능이었습니다. APM은 시스템 활동을 기반으로 시스템의 전력 사용량을 제어합니다. 그러나 운영 체제가 시스템의 전력 사용량과 열 속성을 관리하는 것은 어렵고 유연하지 않았습니다. 하드웨어는 BIOS에 의해 관리되었고 사용자는 전원 관리 설정에 대한 구성 가능성과 가시성이 제한적이었습니다. APMBIOS는 공급업체에서 제공하며 하드웨어 플랫폼에 따라 다릅니다. 운영 체제의 APM 드라이버는 전력 수준을 관리할 수 있는 APM 소프트웨어 인터페이스에 대한 액세스를 중개합니다.

APM에는 네 가지 주요 문제가 있습니다. 첫째, 전원 관리가 운영 체제와 별도로 공급업체별 BIOS에 의해 수행됩니다. 예를 들어, 사용자는 하드 드라이브의 유휴 시간 값을 APMBIOS에서 설정하여 초과 시 운영 체제의 동의 없이 BIOS가 하드 드라이브를 턴다운하도록 할 수 있습니다. 둘째, APM 로직은 BIOS에 내장되어 있으며 운영 체제의 범위 밖에서 작동합니다. 즉, 사용자는 ROM에 새 펌웨어를 플래시해야만 APMBIOS의 문제를 해결할 수 있으며, 이는 실패 시 시스템을 복구할 수 없는 상태로 만들 수 있는 위험한 절차입니다. 셋째, APM은 공급업체별 기술이기 때문에 중복되는 작업이 많고 한 공급업체의 BIOS에서 발견된 버그가 다른 공급업체에서는 해결되지 않을 수 있습니다. 마지막으로, APMBIOS는 정교한 전원 정책이나 기계의 목적에 맞게 잘 조정할 수 있는 정책을 구현할 여지가 충분하지 않았습니다.

Plug and Play BIOS(PNPBIOS)는 많은 상황에서 불안정했습니다. PNPBIOS는 16비트 기술이기 때문에 운영 체제가 16비트 에뮬레이션을 사용해야 PNPBIOS 방식과 인터페이스할 수 있습니다. 2000년 이전에 제조된 시스템에서는 여전히 APM을 사용해야 하므로 FreeBSD는 APM 드라이버를 제공합니다. 드라이버는 man:apm[4]에 문서화되어 있습니다.

APM의 후속 버전은 고급 구성 및 전원 인터페이스(ACPI)입니다. ACPI는 하드웨어 리소스 및 전원 관리를 위한 인터페이스를 제공하기 위해 공급업체 연합에서 작성한 표준입니다. 운영 체제에 더 많은 제어와 유연성을 제공하기 때문에 _운영 체제 중심 구성 및 전원 관리_ 의 핵심 요소입니다.

이 장에서는 FreeBSD에서 ACPI를 구성하는 방법을 설명합니다. 그런 다음 개발자가 ACPI 문제를 진단하고 수정할 수 있도록 ACPI를 디버깅하는 방법과 디버깅 정보가 포함된 문제 보고서를 제출하는 방법에 대한 몇 가지 팁을 제공합니다.

[[acpi-config]]
=== ACPI 구성하기

FreeBSD에서는 시스템 부팅 시 man:acpi[4] 드라이버가 기본적으로 로드되며 커널에 컴파일해서는 _안됩니다_ . 이 드라이버는 시스템 버스가 다양한 하드웨어 상호 작용에 사용하기 때문에 부팅 후 언로드할 수 없습니다. 그러나 시스템에 문제가 있는 경우 [.filename]#/boot/loader.conf# 에서 `hint.acpi.0.disabled="1"` 을 설정한 후 재부팅하거나 crossref:boot[boot-loader,“Stage Three”]에 설명된 대로 로더 프롬프트에서 이 변수를 설정하여 ACPI를 완전히 비활성화할 수 있습니다.

[NOTE]
====
ACPI와 APM은 공존할 수 없으며 별도로 사용해야 합니다. 드라이버가 다른 드라이버가 실행 중인 것을 감지하면 마지막으로 로드한 드라이버가 종료됩니다.
====

ACPI는 `acpiconf`, `-s` 플래그 및 `1` 에서 `5` 사이의 숫자를 사용하여 시스템을 절전 모드로 전환하는 데 사용할 수 있습니다. 대부분의 사용자는 `1` (RAM으로 빠른 일시 중단) 또는 `3` (RAM으로 일시 중단)만 필요합니다. 옵션 `5` 는 `halt -p` 를 실행하는 것과 동일한 소프트 오프를 수행합니다.

man:acpi_video[4] 드라이버는 link:https://uefi.org/specs/ACPI/6.4/Apx_B_Video_Extensions/Apx_B_Video_Extensions.html[ACPI 비디오 확장]을 사용하여 디스플레이 전환 및 백라이트 밝기를 제어합니다. 이 드라이버는 DRM 커널 모듈 다음에 로드해야 합니다. 드라이버를 로드한 후 kbd:[Fn] 밝기 키로 화면 밝기를 변경할 수 있습니다. ACPI 이벤트는 [.filename]#/var/run/devd.pipe# 를 검사하여 확인할 수 있습니다:

[source, shell]
... # cat /var/run/devd.pipe !system=ACPI subsystem=Video type=brightness notify=62 !system=ACPI subsystem=Video type=brightness notify=63 !system=ACPI subsystem=Video type=brightness notify=64 ...

다른 옵션은 `sysctl` 을 사용하여 사용할 수 있습니다. 자세한 내용은 man:acpi[4] 및 man:acpiconf[8]을 참조하세요.

[[ACPI-comprob]]
=== 일반적인 문제

ACPI는 ia32(x86) 및 amd64(AMD) 아키텍처를 준수하는 모든 최신 컴퓨터에 존재합니다. 전체 표준에는 CPU 성능 관리, 전원면 제어, 열 영역, 다양한 배터리 시스템, 임베디드 컨트롤러, 버스 열거 등 많은 기능이 포함되어 있습니다. 대부분의 시스템은 전체 표준보다 적은 기능을 구현합니다. 예를 들어 데스크톱 시스템은 일반적으로 버스 열거만 구현하는 반면 노트북은 냉각 및 배터리 관리도 지원할 수 있습니다. 또한 노트북에는 일시 중단 및 재개 기능이 있으며, 이와 관련된 복잡한 설정도 있습니다.

ACPI 호환 시스템에는 다양한 구성 요소가 있습니다. BIOS 및 칩셋 공급업체는 APIC 맵(SMP에 사용됨), 구성 레지스터, 간단한 구성 값 등을 지정하는 FADT와 같은 다양한 고정 테이블을 메모리에 제공합니다. 또한 바이트코드 테이블인 차별화 시스템 설명 테이블 (Differentiated System Description Table, DSDT는 장치 및 메서드의 트리와 같은 이름 공간을 지정합니다.

ACPI 드라이버는 고정 테이블을 구문 분석하고, 바이트코드에 대한 인터프리터를 구현하고, 장치 드라이버와 커널을 수정하여 ACPI 서브시스템의 정보를 받아들여야 합니다. FreeBSD의 경우, 인텔(R)은 Linux(R) 및 NetBSD와 공유되는 인터프리터(ACPI-CA)를 제공했습니다. ACPI-CA 소스 코드의 경로는 [.filename]#src/sys/contrib/dev/acpica# 입니다. ACPI-CA가 FreeBSD에서 작동할 수 있도록 하는 글루 코드는 [.filename]#src/sys/dev/acpica/Osd# 에 있습니다. 마지막으로, 다양한 ACPI 장치를 구현하는 드라이버는 [.filename]#src/sys/dev/acpica# 에서 찾을 수 있습니다.

ACPI가 올바르게 작동하려면 모든 부품이 올바르게 작동해야 합니다. 다음은 자주 발생하는 몇 가지 일반적인 문제와 가능한 해결 방법 또는 수정 사항을 빈도 순으로 나열한 것입니다. 수정해도 문제가 해결되지 않으면 <<ACPI-submitdebug>> 에서 버그 리포트를 제출하는 방법에 대한 지침을 참조하세요.

==== 마우스 문제

경우에 따라 일시 중단된 작업에서 다시 시작하면 마우스가 실패할 수 있습니다. 알려진 해결 방법은 `hint.psm.0.flags="0x3000"` 을 [.filename]#/boot/loader.conf# 에 추가하는 것입니다.

==== 일시 중단/재개

ACPI에는 `S1`-`S3` 의 세 가지 RAM 일시 중단(STR) 상태와 `S4` 라는 하나의 디스크 일시 중단(STD) 상태가 있습니다. STD는 두 가지 방법으로 구현할 수 있습니다. ``S4`` BIOS는 BIOS가 지원하는 디스크 일시 중단이고 ``S4`` OS는 운영 체제에서 전적으로 구현합니다. 전원이 연결되었지만 전원이 켜지지 않은 상태의 정상적인 시스템은 "소프트 오프"( ``S5`` ) 상태입니다.

`sysctl hw.acpi` 를 사용하여 일시 중단 관련 항목을 확인합니다. 이 예제 결과는 Thinkpad의 결과입니다:

[source, shell]
....
hw.acpi.supported_sleep_state: S3 S4 S5
hw.acpi.s4bios: 0
....

`acpiconf -s` 를 사용하여 `S3`, `S4` 및 `S5` 를 테스트합니다. `s4bios` 가 1( `1` )이면 `S4` 운영 체제 지원 대신 `S4` BIOS를 지원함을 나타냅니다.

일시 중단/재개를 테스트할 때, 지원되는 경우 `S1` 으로 시작합니다. 이 상태는 많은 드라이버 지원이 필요하지 않으므로 작동할 가능성이 가장 높습니다. `S1` 과 유사한 `S2` 를 구현한 곳은 없습니다. 다음으로 `S3` 을 시도해 보세요. 이것은 가장 깊은 STR 상태이며 하드웨어를 올바르게 다시 초기화하기 위해 많은 드라이버 지원이 필요합니다.

일시 중단/재개와 관련된 일반적인 문제는 많은 장치 드라이버가 펌웨어, 레지스터 또는 장치 메모리를 제대로 저장, 복원 또는 다시 초기화하지 못한다는 점입니다. 문제를 디버깅하기 위한 첫 번째 시도로 다음을 시도해 보세요:

[source, shell]
....
# sysctl debug.bootverbose=1
# sysctl debug.acpi.suspend_bounce=1
# acpiconf -s 3
....

이 테스트는 실제로 `S3` 상태가 되지 않고 모든 디바이스 드라이버의 일시 중단/재개 주기를 에뮬레이션합니다. 경우에 따라 펌웨어 상태 손실, 장치 감시 시간 초과, 영원히 재시도하는 등의 문제를 이 방법으로 캡처할 수 있습니다. 시스템이 실제로 `S3` 상태가 되지 않으므로 기기의 전원이 손실되지 않을 수 있으며, 실제 `S3` 상태와 달리 일시 중단/재시작 방법이 완전히 누락되더라도 많은 기기가 정상적으로 작동한다는 점에 유의하세요.

이전 테스트가 작동했다면 노트북에서 뚜껑을 닫을 때 시스템이 `S3' 로 일시 중단되었다가 열면 다시 시작되도록 구성할 수 있습니다:

[source, shell]
....
# sysctl hw.acpi.lid_switch_state=S3
....

이 변경 사항은 재부팅 시에도 영구적으로 적용될 수 있습니다:

[source, shell]
....
# echo 'hw.acpi.lid_switch_state=S3' >> /etc/sysctl.conf
....

더 어려운 경우에는 직렬 콘솔을 통한 디버깅하기 위해 직렬 포트 및 케이블, man:dcons[4] 실행을 위한 Firewire 포트 및 케이블, 커널 디버깅 기술 등의 추가 하드웨어가 필요합니다.

문제를 분리하는 데 도움이 되도록 최대한 많은 드라이버를 언로드하세요. 작동하면 다시 실패할 때까지 드라이버를 로드하여 어떤 드라이버가 문제인지 좁혀보세요. 일반적으로 [.filename]#nvidia.ko# 와 같은 바이너리 드라이버, 디스플레이 드라이버, USB에 가장 많은 문제가 발생하지만 이더넷 인터페이스는 보통 정상 작동합니다. 드라이버를 제대로 로드 및 언로드할 수 있는 경우 [.filename]#/etc/rc.suspend# 및 [.filename]#/etc/rc.resume# 에 적절한 명령을 넣어 이 작업을 자동화하세요. 다시 시작한 후 디스플레이가 엉망인 경우 `hw.acpi.reset_video` 를 `1` 로 설정해 보세요. `hw.acpi.sleep_delay` 의 값을 더 길게 또는 더 짧게 설정하여 도움이 되는지 확인하세요.

최신 Linux(R) 배포판을 로드하여 동일한 하드웨어에서 일시 중단/다시 시작이 작동하는지 확인하세요. Linux(R)에서 작동한다면 FreeBSD 드라이버 문제일 가능성이 높습니다. 문제를 일으키는 드라이버를 좁히면 개발자가 문제를 해결하는 데 도움이 됩니다. ACPI 유지 관리자는 사운드나 ATA와 같은 다른 드라이버는 거의 관리하지 않으므로, 드라이버 문제는 {freebsd-current}에 게시하고 드라이버 유지 관리자에게 메일을 보내야 합니다. 고급 사용자는 문제가 있는 드라이버에서 man:printf[3]를 디버깅하여 재개 기능의 어느 부분에서 중단되는지 추적할 수 있습니다.

마지막으로 ACPI를 비활성화하고 대신 APM을 활성화해 보세요. 일시 중단/재개가 APM과 함께 작동하는 경우, 특히 구형 하드웨어(2000년 이전)에서는 APM을 계속 사용하세요. 공급업체가 ACPI를 올바르게 지원하는 데 시간이 걸렸고 구형 하드웨어는 ACPI와 관련된 BIOS 문제가 있을 가능성이 더 높습니다.

==== 시스템 멈춤

대부분의 시스템 중단은 인터럽트 손실 또는 인터럽트 폭풍으로 인해 발생합니다. 칩셋은 부팅, BIOS에서 인터럽트를 구성하는 방법, APIC(MADT) 테이블의 정확성, 시스템 제어 인터럽트(SCI)의 라우팅에 따라 문제가 발생할 수 있습니다.

인터럽트 폭풍은 `vmstat -i` 의 출력을 확인하고 `acpi0` 이 있는 줄을 확인하여 손실된 인터럽트와 구별할 수 있습니다. 카운터가 초당 두 개 이상 증가하면 인터럽트 폭풍이 발생한 것입니다. 시스템이 중단된 것처럼 보이면 DDB(콘솔에서 kbd:[CTRL+ALT+ESC])로 이동하여 `show interrupts` 를 입력해 보세요.

인터럽트 문제를 해결할 때는 [.filename]#/boot/loader.conf# 에서 `hint.apic.0.disabled="1"` 을 사용하여 APIC 지원을 비활성화해 보세요.

==== 패닉

패닉은 ACPI에서 비교적 드물게 발생하나 최우선적으로 해결해야 할 문제입니다. 첫 번째 단계는 가능한 경우 패닉을 재현하는 단계를 분리하고 백트레이스를 확보하는 것입니다. crossref:serialcomms[serialconsole-ddb,“Entering the DDB Debugger from the Serial Line”] 또는 덤프 파티션 설정에서 `options DDB` 를 활성화하고 시리얼 콘솔을 설정하는 방법에 대한 조언을 따르세요. DDB에서 백트레이스를 얻으려면 `tr` 을 사용합니다. 백트레이스를 손으로 기록할 때는 최소한 추적의 마지막 다섯 줄과 상위 다섯 줄을 가져와야 합니다.

그런 다음 ACPI를 비활성화한 상태로 부팅하여 문제를 격리해 보세요. 문제가 해결되면 `debug.acpi.disable` 의 다양한 값을 사용하여 ACPI 하위 시스템을 격리합니다. 몇 가지 예는 man:acpi[4]를 참조하세요.

==== 일시 중단 또는 종료 후 시스템 전원 켜짐

먼저, [.filename]#/boot/loader.conf# 에서 `hw.acpi.disable_on_poweroff="0"` 을 설정해 보세요. 이렇게 하면 종료 프로세스 중에 ACPI가 다양한 이벤트를 비활성화하지 않습니다. 일부 시스템에서는 같은 이유로 이 값을 `1` (기본값)로 설정해야 합니다. 이렇게 하면 일반적으로 일시 중단 또는 전원 끄기 후 시스템이 저절로 전원이 켜지는 문제가 해결됩니다.

[[ACPI-aslanddump]]
==== 버기 바이트코드가 포함된 BIOS

일부 BIOS 공급업체는 부정확하거나 버그가 있는 바이트코드를 제공합니다. 이는 일반적으로 다음과 같은 커널 콘솔 메시지로 나타납니다:

[source, shell]
....
ACPI-1287: *** Error: Method execution failed [\\_SB_.PCI0.LPC0.FIGD._STA] \\
(Node 0xc3f6d160), AE_NOT_FOUND
....

대개 이러한 문제는 BIOS를 최신 버전으로 업데이트하면 해결될 수 있습니다. 대부분의 콘솔 메시지는 무해하지만 배터리 상태가 작동하지 않는 등의 다른 문제가 있는 경우 이러한 메시지를 통해 문제를 찾아보는 것이 좋습니다.

=== 기본 AML 재정의하기

ACPI 기계어(AML)로 알려진 BIOS 바이트 코드는 ACPI 소스 언어(ASL)라는 소스 언어에서 컴파일됩니다. AML은 차별화 시스템 설명 테이블(Differentiated System Description Table, DSDT)이라는 테이블에서 찾을 수 있습니다.

FreeBSD의 목표는 모든 사람이 사용자 개입 없이 작동하는 ACPI를 사용하는 것입니다. BIOS 공급업체가 흔히 저지르는 실수에 대한 해결 방법은 여전히 개발 중입니다. Microsoft(R) 인터프리터( [.filename]#acpi.sys# 및 [.filename]#acpiec.sys# )는 표준 준수 여부를 엄격하게 검사하지 않기 때문에, Windows(R)에서만 ACPI를 테스트하는 많은 BIOS 벤더들은 그들의 ASL을 수정하지 않습니다. FreeBSD 개발자들은 Microsoft(R)의 인터프리터가 허용하는 비표준 동작을 지속적으로 식별하고 문서화하여 사용자가 ASL을 수정하지 않고도 FreeBSD가 작동할 수 있도록 복제하고 있습니다.

버그가 있는 동작을 식별하고 수동으로 수정하는 데 도움이 되도록 시스템의 ASL을 복사할 수 있습니다. 시스템의 ASL을 지정된 파일 이름으로 복사하려면 `acpidump` 에 고정 테이블의 내용을 표시하는 `-t` 와 AML을 분해하는 `-d` 를 함께 사용합니다:

[source, shell]
....
# acpidump -td > my.asl
....

일부 AML 버전은 사용자가 Windows(R)를 실행하고 있다고 가정합니다. 이를 재정의하려면 ASL에 나열된 가장 최신 Windows(R) 버전을 사용하여 [.filename]#/boot/loader.conf# 에 `hw.acpi.osname=_"Windows 2009"_` 를 설정하세요.

다른 해결 방법을 사용하려면 [.filename]#my.asl# 을 사용자 지정해야 할 수도 있습니다. 이 파일을 편집한 경우 다음 명령을 사용하여 새 ASL을 컴파일합니다. 경고는 일반적으로 무시할 수 있지만 오류는 일반적으로 ACPI가 올바르게 작동하지 못하게 하는 버그입니다.

[source, shell]
....
# iasl -f my.asl
....

`-f` 를 포함하면 컴파일 중에 오류가 있더라도 AML을 강제로 생성합니다. 누락된 반환문과 같은 일부 오류는 FreeBSD 인터프리터가 자동으로 해결합니다.

`iasl` 의 기본 출력 파일 이름은 [.filename]#DSDT.aml# 입니다. 플래시 메모리에 여전히 존재하는 BIOS의 버그 복사본 대신 이 파일을 로드하려면 [.filename]#/boot/loader.conf# 를 다음과 같이 편집합니다:

[.programlisting]
....
acpi_dsdt_load="YES"
acpi_dsdt_name="/boot/DSDT.aml"
....

Be sure to copy [.filename]#DSDT.aml# to [.filename]#/boot#, then reboot the system. If this fixes the problem, send a man:diff[1] of the old and new ASL to the {freebsd-acpi} so that developers can work around the buggy behavior in [.filename]#acpica#.

[[ACPI-submitdebug]]
=== 디버깅 정보 얻기 및 제출하기

ACPI 드라이버에는 유연한 디버깅 기능이 있습니다. 하위 시스템 세트와 상세 수준을 지정할 수 있습니다. 디버깅할 서브시스템은 레이어로 지정되며 컴포넌트( `ACPI_ALL_COMPONENTS` )와 ACPI 하드웨어 지원( `ACPI_ALL_DRIVERS` )으로 구분됩니다. 디버깅 출력의 상세도는 레벨로 지정되며, 오류만 보고하는 것( `ACPI_LV_ERROR` )부터 모든 것을 보고하는 것( `ACPI_LV_VERBOSE` )까지 다양합니다. 레벨은 비트마스크이므로 공백으로 구분하여 여러 옵션을 한 번에 설정할 수 있습니다. 실제로는 직렬 콘솔을 사용하여 출력을 기록해야 콘솔 메시지 버퍼가 플러시될 때 손실되지 않습니다. 개별 레이어와 레벨의 전체 목록은 man:acpi[4]에서 확인할 수 있습니다.

디버깅 출력은 기본적으로 활성화되어 있지 않습니다. 활성화하려면 ACPI가 커널로 컴파일된 경우 커스텀 커널 구성 파일에 `options ACPI_DEBUG` 를 추가합니다. 전역으로 활성화하려면 [.filename]#/etc/make.conf# 에 `ACPI_DEBUG=1` 을 추가합니다. 커스텀 커널 대신 모듈을 사용하는 경우 다음과 같이 [.filename]#acpi.ko# 모듈만 다시 컴파일하세요:

[source, shell]
....
# cd /sys/modules/acpi/acpi && make clean && make ACPI_DEBUG=1
....

컴파일된 [.filename]#acpi.ko# 를 [.filename]#/boot/kernel# 에 복사하고 원하는 레벨과 레이어를 [.filename]#/boot/loader.conf# 에 추가합니다. 이 예제의 항목은 모든 ACPI 구성 요소 및 하드웨어 드라이버에 대한 디버그 메시지를 활성화하고 최소 상세 수준에서 오류 메시지를 출력합니다:

[.programlisting]
....
debug.acpi.layer="ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS"
debug.acpi.level="ACPI_LV_ERROR"
....

일시 중단 후 재개와 같은 특정 이벤트에 의해 필요한 정보가 트리거되는 경우 [.filename]#/boot/loader.conf# 를 수정하지 마세요. 대신, 부팅 후 특정 이벤트에 대비하여 시스템을 준비한 후 `sysctl` 을 사용하여 레이어와 레벨을 지정하세요. `sysctl` 을 사용하여 설정할 수 있는 변수의 이름은 [.filename]#/boot/loader.conf# 의 튜너블과 동일합니다.

Once the debugging information is gathered, it can be sent to the {freebsd-acpi} so that it can be used by the FreeBSD ACPI maintainers to identify the root cause of the problem and to develop a solution.

[NOTE]
====
이 메일링 리스트에 디버깅 정보를 제출하기 전에 최신 BIOS 버전이 설치되어 있는지, 가능한 경우 임베디드 컨트롤러 펌웨어 버전이 설치되어 있는지 확인합니다.
====

문제 보고서를 제출할 때는 다음 정보를 포함하세요:

* 시스템 유형, 모델, 버그를 발생시킨 원인 등 버그가 발생한 동작에 대한 설명입니다. 새로운 버그인 경우 버그가 언제 발생하기 시작했는지 가능한 한 정확하게 기록하세요.
* `boot -v` 를 실행한 후 `dmesg` 의 출력(버그로 인해 생성된 오류 메시지 포함).
* ACPI를 비활성화하여 문제를 해결하는 데 도움이 되는 경우, ACPI를 비활성화한 상태에서 `boot -v` 의 `dmesg` 출력을 확인합니다.
* `sysctl hw.acpi` 의 출력. 시스템이 제공하는 기능을 나열합니다.
* 붙여넣은 버전의 시스템 ASL에 대한 URL. ASL은 매우 클 수 있으므로 목록에 직접 _보내지 마세요_ . 이 명령을 실행하여 ASL의 복사본을 생성합니다:
+
[source, shell]
....
# acpidump -dt > name-system.asl
....
+
로그인 이름을 _이름_ 으로, 제조사/모델을 _시스템_ 으로 대체합니다. 예를 들어 [.filename]#njl-FooCo6000.asl# 을 사용합니다.

Most FreeBSD developers watch the {freebsd-current}, but one should submit problems to the {freebsd-acpi} to be sure it is seen. Be patient when waiting for a response. If the bug is not immediately apparent, submit a bug report. When entering a PR, include the same information as requested above. This helps developers to track the problem and resolve it. Do not send a PR without emailing the {freebsd-acpi} first as it is likely that the problem has been reported before.

[[ACPI-References]]
=== 참조

ACPI에 대한 자세한 정보는 다음 위치에서 확인할 수 있습니다:

* Archives at https://lists.freebsd.org/pipermail/freebsd-acpi/[] and more recent https://lists.freebsd.org/archives/freebsd-acpi/[]
* The https://uefi.org/specifications#ACPI[ACPI Specification]
* man:acpi[4], man:acpi_thermal[4], man:acpidump[8], man:iasl[8], man:acpidb[8]
