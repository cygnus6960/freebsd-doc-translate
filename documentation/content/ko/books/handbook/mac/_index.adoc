---
description: '이 장에서는 다양한 보안 메커니즘을 활성화하기 위해 FreeBSD가 제공하는 MAC 프레임워크와 플러그 가능한 보안 정책 모듈 세트에 중점을 둡니다'
next: books/handbook/audit
part: '파트 III. 시스템 관리'
path: /books/handbook/
prev: books/handbook/jails
showBookMenu: 'true'
tags: ["MAC", "labels", "security", "configuration", "nagios"]
title: '17장. 필수 액세스 제어 (Mandatory Access Control)'
weight: 21
---

[[mac]]
= Mandatory Access Control
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 17
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/mac/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[mac-synopsis]]
== 요약

FreeBSD는 POSIX(R).1e 초안에 기반한 보안 확장을 지원합니다. 이러한 보안 메커니즘에는 파일 시스템 접근 제어 목록(crossref:security[fs-acl,“Access Control Lists”])과 필수 접근 제어(MAC)가 포함됩니다. MAC을 사용하면 보안 정책을 구현하기 위해 액세스 제어 모듈을 로드할 수 있습니다. 일부 모듈은 시스템의 좁은 하위 집합에 대한 보호 기능을 제공하여 특정 서비스를 강화합니다. 다른 모듈은 모든 주체와 객체에 대해 포괄적인 레이블이 지정된 보안을 제공합니다. 정의의 필수 부분은 제어의 시행이 관리자와 운영 체제에 의해 수행됨을 나타냅니다. 이는 시행이 사용자의 재량에 맡겨지는 DAC(임의 액세스 제어)의 기본 보안 메커니즘과 대조적입니다.

이 장에서는 MAC 프레임워크와 다양한 보안 메커니즘을 활성화하기 위해 FreeBSD가 제공하는 플러그 가능한 보안 정책 모듈 세트에 중점을 둡니다.

이 장을 읽고 나면 다음을 알 수 있습니다:

* MAC 프레임워크와 관련된 용어.
* MAC 보안 정책 모듈의 능력과 레이블이 지정된 정책과 레이블이 지정되지 않은 정책의 차이점.
* MAC 프레임워크를 사용하도록 시스템을 구성하기 전에 고려해야 할 사항.
* FreeBSD에 포함된 MAC 보안 정책 모듈과 이를 구성하는 방법.
* MAC 프레임워크를 사용하여 더욱 안전한 환경을 구현하는 방법.
* 프레임워크가 제대로 구현되었는지 확인하기 위해 MAC 구성을 테스트하는 방법.

이 챕터를 읽기 전에 알아두어야 할 사항입니다:

* UNIX(R) 및 FreeBSD 기본 사항을 이해합니다(crossref:basics[basics,FreeBSD Basics]).
* 보안과 그것이 FreeBSD와 어떻게 관련되어 있는지 어느 정도 알고 있어야 합니다(crossref:security[security,Security]).

[WARNING]
====
부적절한 MAC 구성은 시스템 액세스 손실, 사용자 성능 저하 또는 Xorg가 제공하는 기능에 대한 액세스 불능을 초래할 수 있습니다. 더 중요한 것은 MAC이 시스템을 완전히 보호하는 데 의존해서는 안 된다는 것입니다. MAC 프레임워크는 기존 보안 정책을 보강할 뿐입니다. 건전한 보안 관행과 정기적인 보안 점검 없이는 시스템을 완벽하게 보호할 수 없습니다.

이 장에 포함된 예제는 데모용이며 예제 설정은 프로덕션 시스템에서 구현해서는 _안 됩니다_ . 보안 정책을 구현하려면 많은 이해와 적절한 설계, 철저한 테스트가 필요합니다.
====

이 장에서는 MAC 프레임워크와 관련된 광범위한 보안 문제를 다루지만, 새로운 MAC 보안 정책 모듈의 개발은 다루지 않습니다. MAC 프레임워크에 포함된 여러 보안 정책 모듈에는 테스트와 새 모듈 개발 모두를 위해 제공되는 특성이 있습니다. 이러한 보안 정책 모듈과 이 모듈이 제공하는 다양한 메커니즘에 대한 자세한 내용은 man:mac_test[4], man:mac_stub[4] 및 man:mac_none[4]을 참조하세요.

[[mac-inline-glossary]]
== 핵심 용어

MAC 프레임워크를 언급할 때 사용되는 주요 용어는 다음과 같습니다:

* _compartment_ : 분할 또는 분리할 프로그램과 데이터의 집합으로, 사용자에게 시스템의 특정 구성 요소에 대한 명시적 액세스 권한이 부여됩니다. 구획은 작업 그룹, 부서, 프로젝트 또는 주제와 같은 그룹을 나타냅니다. 구획을 사용하면 알아야 할 필요 기반 보안 정책을 구현할 수 있습니다.
* _integrity_ : 데이터에 대해 신뢰할 수 있는 수준. 데이터의 무결성이 높아질수록 해당 데이터의 신뢰도도 높아집니다.
* _level_ : 보안 속성의 증가 또는 감소된 설정입니다. 레벨이 높아지면 보안도 높아지는 것으로 간주합니다.
* _label_ : 시스템의 파일, 디렉터리 또는 기타 항목에 적용할 수 있는 보안 속성입니다. 기밀성 스탬프로 간주할 수 있습니다. 파일에 레이블을 지정하면 해당 파일의 보안 속성을 설명하며 유사한 보안 설정을 가진 파일, 사용자 및 리소스에 대해서만 액세스를 허용합니다. 레이블 값의 의미와 해석은 정책 구성에 따라 다릅니다. 일부 정책에서는 레이블을 개체의 무결성 또는 기밀성을 나타내는 것으로 취급하는 반면, 다른 정책에서는 레이블을 사용하여 액세스 규칙을 정할 수 있습니다.
* _multilabel_ : 이 속성은 단일 사용자 모드에서 man:tunefs[8]를 사용하거나, 부팅 중에 man:fstab[5]을 사용하거나, 새 파일 시스템을 생성하는 동안 설정할 수 있는 파일 시스템 옵션입니다. 이 옵션을 사용하면 관리자가 여러 개체에 서로 다른 MAC 레이블을 적용할 수 있습니다. 이 옵션은 라벨링을 지원하는 보안 정책 모듈에만 적용됩니다.
* _single label_ : 전체 파일 시스템에서 하나의 레이블을 사용하여 데이터 흐름에 대한 액세스 제어를 적용하는 정책입니다. `multilabel` 을 설정하지 않으면 모든 파일이 동일한 레이블 설정을 따르게 됩니다.
* _object_ : _주체_ 의 지시에 따라 정보가 흐르는 개체를 말합니다. 여기에는 디렉터리, 파일, 필드, 화면, 키보드, 메모리, 자기 저장 장치, 프린터 또는 기타 데이터 저장 또는 이동 장치가 포함됩니다. 객체는 데이터 컨테이너 또는 시스템 리소스입니다. 객체에 대한 액세스는 사실상 해당 데이터에 대한 액세스를 의미합니다.
* _subject_ : 사용자, 사용자 프로세스 또는 시스템 프로세스와 같은 _객체_ 간에 정보를 흐르게 하는 모든 활성 엔티티입니다. FreeBSD에서는 거의 항상 사용자를 대신하여 프로세스에서 작동하는 스레드가 해당됩니다.
* _policy_ : 목표를 달성하는 방법을 정의하는 규칙 모음입니다. 정책은 일반적으로 특정 항목을 처리하는 방법을 문서화합니다. 이 장에서는 정책을 데이터와 정보의 흐름을 제어하고 해당 데이터와 정보에 액세스할 수 있는 사용자를 정의하는 규칙 모음으로 간주합니다.
* _high-watermark_ : 이 유형의 정책은 더 높은 수준의 정보에 액세스할 목적으로 보안 수준을 높일 수 있도록 허용합니다. 대부분의 경우, 프로세스가 완료된 후 원래 수준으로 복원됩니다. 현재 FreeBSD MAC 프레임워크에는 이 유형의 정책이 포함되어 있지 않습니다.
* _low-watermark_ : 이 유형의 정책은 보안 수준이 낮은 정보에 액세스할 목적으로 보안 수준을 낮추는 것을 허용합니다. 대부분의 경우, 프로세스가 완료된 후 사용자의 원래 보안 수준이 복원됩니다. 이를 사용할 수 있는 FreeBSD의 유일한 보안 정책 모듈은 man:mac_lomac[4]입니다.
* _sensitivity_ : 일반적으로 다단계 보안(Multilevel Security, MLS)을 논의할 때 사용됩니다. 민감도 수준은 데이터가 얼마나 중요하거나 비밀이어야 하는지를 설명합니다. 민감도 수준이 높아질수록 데이터의 비밀성 또는 기밀성의 중요성도 높아집니다.

[[mac-understandlabel]]
== MAC 레이블 이해하기

MAC 레이블은 시스템 전체의 주체와 객체에 적용될 수 있는 보안 속성입니다. 레이블을 설정할 때 관리자는 시스템의 예기치 않거나 원치 않는 동작을 방지하기 위해 그 의미를 이해해야 합니다. 정책 모듈은 각기 다른 방식으로 속성을 해석하므로 개체에 사용할 수 있는 속성은 로드된 정책 모듈에 따라 달라집니다.

개체의 보안 레이블은 정책에 의한 보안 액세스 제어 결정의 일부로 사용됩니다. 일부 정책에서는 레이블에 결정을 내리는 데 필요한 모든 정보가 포함되어 있습니다. 다른 정책에서는 레이블이 더 큰 규칙 집합의 일부로 처리될 수 있습니다.

레이블 정책에는 단일 레이블과 다중 레이블의 두 가지 유형이 있습니다. 기본적으로 시스템은 단일 레이블을 사용합니다. 관리자는 시스템 보안 모델의 요구 사항을 충족하는 정책을 구현하기 위해 각각의 장단점을 알고 있어야 합니다.

단일 레이블 보안 정책은 모든 대상 또는 개체에 대해 하나의 레이블만 사용할 수 있도록 허용합니다. 단일 레이블 정책은 전체 시스템에 하나의 액세스 권한 세트를 적용하므로 관리 오버헤드가 줄어들지만 레이블을 지원하는 정책의 유연성이 떨어집니다. 그러나 많은 환경에서는 단일 레이블 정책으로 충분할 수도 있습니다.

단일 레이블 정책은 사용자가 적절한 카테고리와 액세스 수준에 배치되도록 정책을 구성하기 때문에 DAC와 다소 유사합니다. 주목할 만한 차이점은 많은 정책 모듈이 `root` 를 제한할 수도 있다는 것입니다. 그러면 개체에 대한 기본 제어 권한이 그룹으로 풀리지만 `root` 는 언제든지 설정을 취소하거나 수정할 수 있습니다.

적절한 경우, man:tunefs[8]에 `multilabel` 을 전달하여 UFS 파일 시스템에 다중 레이블 정책을 설정할 수 있습니다. 다중 레이블 정책을 사용하면 각 주체 또는 오브젝트가 독립적인 MAC 레이블을 가질 수 있습니다. 다중 레이블 또는 단일 레이블 정책을 사용할지 여부는 `biba`, `lomac`, `mls` 와 같은 레이블 기능을 구현하는 정책에만 필요합니다. `seeotheruids`, `portacl`, `partition` 과 같은 일부 정책은 레이블을 전혀 사용하지 않습니다.

파티션에 다중 레이블 정책을 사용하고 다중 레이블 보안 모델을 설정하면 해당 파일 시스템의 모든 항목에 레이블이 지정되므로 관리 오버헤드가 증가할 수 있습니다. 여기에는 디렉터리, 파일, 심지어 장치 노드까지 포함됩니다.

다음 명령은 지정된 UFS 파일 시스템에 `멀티레이블` 을 설정합니다. 이 작업은 단일 사용자 모드에서만 수행할 수 있으며 스왑 파일 시스템에 대한 요구 사항은 아닙니다:

[source, shell]
....
# tunefs -l enable /
....

[NOTE]
====
일부 사용자는 루트 파티션에서 `멀티 레이블` 플래그를 설정하는 데 문제가 발생했습니다. 이 경우 <<mac-troubleshoot>> 을 검토하세요.
====

다중 레이블 정책은 파일 시스템 단위로 설정되므로 파일 시스템 레이아웃이 잘 설계된 경우 다중 레이블 정책이 필요하지 않을 수 있습니다. FreeBSD 웹 서버의 보안 MAC 모델을 예로 들어보겠습니다. 이 머신은 기본 파일 시스템의 모든 항목에 단일 레이블인 `biba/high` 를 사용합니다. 쓰기 기능을 방지하기 위해 웹 서버를 `biba/low` 에서 실행해야 하는 경우, `biba/low` 로 설정된 별도의 UFS [.filename]#/usr/local# 파일 시스템에 웹 서버를 설치할 수 있습니다.

=== 레이블 구성

레이블 정책 모듈 구성의 거의 모든 측면은 기본 시스템 유틸리티를 사용하여 수행됩니다. 이러한 명령은 개체 또는 대상 구성 또는 구성의 조작 및 확인을 위한 간단한 인터페이스를 제공합니다.

모든 구성은 시스템 개체의 MAC 레이블을 설정하는 데 사용되는 `setfmac` 과 시스템 주체의 레이블을 설정하는 데 사용되는 `setpmac` 을 사용하여 수행할 수 있습니다. 예를 들어, [.filename]#test# 에 `biba` MAC 레이블을 `high` 로 설정합니다:

[source, shell]
....
# setfmac biba/high test
....

구성이 성공하면 오류 없이 프롬프트가 반환됩니다. 일반적인 오류는 `Permission denied` 로, 일반적으로 제한된 객체에 레이블을 설정하거나 수정할 때 발생합니다. 다른 조건에서는 다른 오류가 발생할 수 있습니다. 예를 들어, 개체에 레이블을 다시 지정하려는 사용자가 파일을 소유하고 있지 않거나, 개체가 존재하지 않거나, 개체가 읽기 전용일 수 있습니다. 필수 정책은 파일의 속성, 프로세스의 속성 또는 제안된 새 레이블 값의 속성 때문에 프로세스가 파일에 레이블을 다시 지정하는 것을 허용하지 않을 수 있습니다. 예를 들어, 낮은 무결성으로 실행 중인 사용자가 높은 무결성 파일의 레이블을 변경하려고 하거나 낮은 무결성으로 실행 중인 사용자가 낮은 무결성 파일의 레이블을 높은 무결성 레이블로 변경하려고 하는 경우 이러한 작업은 실패합니다.

시스템 관리자는 `setpmac` 을 사용하여 호출된 프로세스에 다른 레이블을 할당하여 정책 모듈의 설정을 재정의할 수 있습니다:

[source, shell]
....
# setfmac biba/high test
Permission denied
# setpmac biba/low setfmac biba/high test
# getfmac test
test: biba/high
....

sendmail과 같이 현재 실행 중인 프로세스의 경우 일반적으로 `getpmac` 이 대신 사용됩니다. 이 명령은 명령 이름 대신 프로세스 ID(PID)를 사용합니다. 사용자가 로드된 정책 모듈의 규칙에 따라 액세스 권한이 없는 파일을 조작하려고 하면 `Operation not permitted` 오류가 표시됩니다.

=== 사전 정의된 레이블

라벨링 기능을 지원하는 몇몇 FreeBSD 정책 모듈은 세 가지 사전 정의된 레이블을 제공합니다: `low`, `equal`, `high` 의 세 가지 레이블을 제공합니다:

* `low` 은 개체나 주체가 가질 수 있는 가장 낮은 레이블 설정으로 간주됩니다. 개체나 주체에 이 설정을 지정하면 높게 표시된 개체나 주체에 대한 액세스가 차단됩니다.
* `equal` 은 주체 또는 객체를 비활성화하거나 영향을 받지 않도록 설정하며 정책에서 제외되는 것으로 간주되는 객체에만 배치해야 합니다.
* `high` 는 개체 또는 주체에 Biba 및 MLS 정책 모듈에서 사용할 수 있는 가장 높은 설정을 부여합니다.

이러한 정책 모듈에는 man:mac_biba[4], man:mac_mls[4] 및 man:mac_lomac[4]이 있습니다. 미리 정의된 각 레이블은 서로 다른 정보 흐름 지시문을 설정합니다. 일반 레이블 구성의 특성을 확인하려면 모듈의 설명서 페이지를 참조하세요.

=== 숫자 레이블

Biba 및 MLS 정책 모듈은 계층적 제어의 정확한 수준을 나타내도록 설정할 수 있는 숫자 레이블을 지원합니다. 이 숫자 수준은 정보를 여러 분류 그룹으로 분할하거나 정렬하는 데 사용되며, 해당 그룹 또는 상위 그룹 수준에 대한 액세스만 허용합니다. 예를 들면 다음과 같습니다:

[.programlisting]
....
biba/10:2+3+6(5:2+3-20:2+3+4+5+6)
....

"Biba Policy Label/Grade 10:Compartments 2, 3 and 6: (grade 5 ...)"으로 해석될 수 있습니다

이 예에서 첫 번째 등급은 유효 구획이 있는 유효 등급, 두 번째 등급은 낮은 등급, 마지막 등급은 높은 등급으로 간주됩니다. 대부분의 구성에서는 고급 구성으로 간주되므로 이러한 세분화된 설정은 필요하지 않습니다.

시스템 객체에는 현재 등급과 구획만 있습니다. 시스템 주체는 시스템에서 사용 가능한 권한의 범위와 액세스 제어에 사용되는 네트워크 인터페이스를 반영합니다.

주제와 객체 쌍의 등급과 구획은 주체가 객체를 지배하거나, 객체가 주체를 지배하거나, 어느 쪽도 다른 쪽을 지배하지 않거나, 둘 다 서로를 지배하는 _우위(dominance)_ 라는 관계를 구성하는 데 사용됩니다. "both dominate"의 경우는 두 레이블이 동일할 때 발생합니다. Biba의 정보 흐름 특성으로 인해 사용자는 프로젝트에 해당할 수 있는 일련의 구획에 대한 권한을 가지지만, 객체에도 일련의 구획이 있습니다. 사용자가 제한되지 않는 구획의 개체에 액세스하려면 `su` 또는 `setpmac` 을 사용하여 권한을 하위 설정해야 할 수 있습니다.

=== 사용자 레이블

사용자는 파일 및 프로세스가 시스템에 정의된 보안 정책과 올바르게 상호 작용할 수 있도록 레이블이 있어야 합니다. 이는 로그인 클래스를 사용하여 [.filename]#/etc/login.conf# 에서 구성됩니다. 레이블을 사용하는 모든 정책 모듈은 사용자 클래스 설정을 구현합니다.

MAC에서 적용할 사용자 클래스 기본 레이블을 설정하려면 `label` 항목을 추가합니다. 모든 정책 모듈을 포함하는 `label` 항목의 예가 아래에 나와 있습니다. 실제 구성에서는 관리자가 모든 정책 모듈을 활성화하지 않을 것입니다. 구성을 구현하기 전에 이 장의 나머지 부분을 검토하는 것이 좋습니다.

[.programlisting]
....
default:\
	:copyright=/etc/COPYRIGHT:\
	:welcome=/etc/motd:\
	:setenv=MAIL=/var/mail/$,BLOCKSIZE=K:\
	:path=~/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:\
	:manpath=/usr/share/man /usr/local/man:\
	:nologin=/usr/sbin/nologin:\
	:cputime=1h30m:\
	:datasize=8M:\
	:vmemoryuse=100M:\
	:stacksize=2M:\
	:memorylocked=4M:\
	:memoryuse=8M:\
	:filesize=8M:\
	:coredumpsize=8M:\
	:openfiles=24:\
	:maxproc=32:\
	:priority=0:\
	:requirehome:\
	:passwordtime=91d:\
	:umask=022:\
	:ignoretime@:\
	:label=partition/13,mls/5,biba/10(5-15),lomac/10[2]:
....

사용자는 기본값을 수정할 수 없지만, 로그인 후 정책의 제약 조건에 따라 레이블을 변경할 수 있습니다. 위의 예는 프로세스의 최소 무결성은 `5`, 최대 무결성은 `15`, 기본 유효 레이블은 `10` 이라고 Biba 정책에 알려줍니다. 프로세스는 사용자가 `setpmac` 을 사용하기 때문에 라벨을 변경할 때까지 `10` 에서 실행되며, 이는 Biba에 의해 구성된 범위로 제한됩니다.

[.filename]#login.conf# 를 변경한 후에는 `cap_mkdb` 를 사용하여 로그인 클래스 기능 데이터베이스를 다시 빌드해야 합니다.

많은 장소에는 여러 가지 사용자 클래스가 필요한 많은 사용자가 있습니다. 관리가 어려워질 수 있으므로 심도 있는 계획이 필요합니다.

=== 네트워크 인터페이스 레이블

네트워크 인터페이스에 레이블을 설정하여 네트워크 전반의 데이터 흐름을 제어할 수 있습니다. 네트워크 인터페이스 레이블을 사용하는 정책은 객체에 대한 정책과 동일한 방식으로 작동합니다. 예를 들어, Biba에서 높은 설정의 사용자는 `low` 라는 레이블이 있는 네트워크 인터페이스에 액세스할 수 없습니다.

네트워크 인터페이스에서 MAC 레이블을 설정할 때 `maclabel` 을 `ifconfig` 에 전달할 수 있습니다:

[source, shell]
....
# ifconfig bge0 maclabel biba/equal
....

이 예는 `bge0` 인터페이스에서 `biba/equal` 의 MAC 레이블을 설정합니다. biba/high(low-high)` 와 유사한 설정을 사용하는 경우 오류가 반환되지 않도록 전체 레이블을 따옴표로 묶어야 합니다.

라벨링을 지원하는 각 정책 모듈에는 네트워크 인터페이스에서 MAC 라벨을 비활성화하는 데 사용할 수 있는 튜너블이 있습니다. 레이블을 `equal` 로 설정해도 비슷한 효과가 있습니다. 이러한 튜너블에 대한 자세한 내용은 `sysctl` 의 출력, 정책 매뉴얼 페이지 및 이 장의 나머지 부분에 있는 정보를 검토하세요.

[[mac-planning]]
== 보안 구성 계획하기

MAC 정책을 구현하기 전에 계획 단계를 수행하는 것이 좋습니다. 계획 단계에서 관리자는 다음과 같은 구현 요구 사항 및 목표를 고려해야 합니다:

* 대상 시스템에서 사용 가능한 정보 및 리소스를 분류하는 방법.
* 적용해야 하는 제한 유형과 함께 액세스를 제한할 정보 또는 리소스.
* 이 목표를 달성하기 위해 어떤 MAC 모듈이 필요할지.

프로덕션 시스템에서 MAC 구현을 사용하기 전에 신뢰할 수 있는 시스템과 해당 구성을 시험 실행해야 합니다. 환경마다 필요와 요구 사항이 다르기 때문에 완전한 보안 프로필을 설정하면 시스템이 가동된 후 변경할 필요성을 줄일 수 있습니다.

MAC 프레임워크로 시스템 전반의 보안을 강화하는 방법을 고려하세요. MAC 프레임워크에서 제공하는 다양한 보안 정책 모듈을 사용하여 네트워크 및 파일 시스템을 보호하거나 사용자가 특정 포트 및 소켓에 액세스하지 못하도록 차단할 수 있습니다. 정책 모듈을 가장 잘 활용하는 방법은 한 번에 여러 보안 정책 모듈을 로드하여 MLS 환경을 제공하는 것입니다. 이 접근 방식은 일반적으로 특정 용도로만 사용되는 시스템 요소를 강화하는 강화 정책과는 다릅니다. MLS의 단점은 관리 오버헤드가 증가한다는 것입니다.

오버헤드는 특정 구성에 필요한 정책을 선택할 수 있는 기능을 제공하고 성능 오버헤드를 낮추는 프레임워크의 지속적인 효과와 비교하면 미미합니다. 불필요한 정책에 대한 지원을 줄이면 시스템의 전반적인 성능이 향상될 뿐만 아니라 선택의 유연성을 제공할 수 있습니다. 올바른 구현은 전반적인 보안 요구 사항을 고려하고 프레임워크에서 제공하는 다양한 보안 정책 모듈을 효과적으로 구현하는 것입니다.

MAC을 사용하는 시스템은 사용자가 보안 속성을 마음대로 변경할 수 없도록 보장합니다. 모든 사용자 유틸리티, 프로그램 및 스크립트는 선택한 보안 정책 모듈에서 제공하는 액세스 규칙의 제약 내에서 작동해야 하며, MAC 액세스 규칙의 제어는 시스템 관리자의 손에 달려 있습니다.

올바른 보안 정책 모듈을 신중하게 선택하는 것은 시스템 관리자의 의무입니다. 네트워크를 통한 접근 제어를 제한해야 하는 환경의 경우 man:mac_portacl[4], man:mac_ifoff[4] 및 man:mac_biba[4] 정책 모듈이 좋은 출발점이 될 수 있습니다. 파일 시스템 개체에 대한 엄격한 기밀성이 필요한 환경에서는 man:mac_bsdextended[4] 및 man:mac_mls[4] 정책 모듈을 고려하세요.

네트워크 구성에 따라 정책을 결정할 수 있습니다. 특정 사용자에게만 man:ssh[1]에 대한 액세스를 허용해야 하는 경우 man:mac_portacl[4] 정책 모듈을 사용하는 것이 좋습니다. 파일 시스템의 경우 일부 사용자에게는 개체에 대한 액세스가 기밀로 간주될 수 있지만 다른 사용자에게는 기밀로 간주되지 않을 수 있습니다. 예를 들어, 대규모 개발 팀이 소규모 프로젝트로 나뉘어 프로젝트 A의 개발자는 프로젝트 B의 개발자가 작성한 개체에 액세스할 수 없지만 두 프로젝트 모두 프로젝트 C의 개발자가 만든 개체에 액세스해야 할 수 있습니다. MAC 프레임워크에서 제공하는 다양한 보안 정책 모듈을 사용하여 사용자를 이러한 그룹으로 구분한 다음 적절한 개체에 대한 액세스 권한을 부여할 수 있습니다.

각 보안 정책 모듈은 시스템의 전반적인 보안을 처리하는 고유한 방식을 가지고 있습니다. 모듈 선택은 수정 및 재구현이 필요할 수 있는 신중한 보안 정책을 기반으로 해야 합니다. MAC 프레임워크에서 제공하는 다양한 보안 정책 모듈을 이해하면 관리자가 상황에 가장 적합한 정책을 선택하는 데 도움이 됩니다.

이 장의 나머지 부분에서는 사용 가능한 모듈을 다루고, 사용 및 구성을 설명하며, 경우에 따라 적용 가능한 상황에 대한 인사이트를 제공합니다.

[CAUTION]
====
MAC을 구현하는 것은 방화벽을 구현하는 것과 매우 유사하므로 시스템에서 완전히 잠기지 않도록 주의를 기울여야 합니다. 이전 구성으로 되돌릴 수 있는 기능을 고려해야 하며 원격 연결을 통한 MAC 구현은 매우 신중하게 수행해야 합니다.
====

[[mac-policies]]
== 사용 가능한 MAC 정책

기본 FreeBSD 커널에는 `options MAC` 이 포함되어 있습니다. 즉, MAC 프레임워크에 포함된 모든 모듈은 런타임 커널 모듈로 `kldload` 를 사용하여 로드할 수 있습니다. 모듈을 테스트한 후 부팅 중에 로드될 수 있도록 [.filename]#/boot/loader.conf# 에 모듈 이름을 추가합니다. 각 모듈은 자체 커널을 컴파일하려는 관리자를 위한 커널 옵션도 제공합니다.

FreeBSD에는 대부분의 보안 요구사항을 충족시킬 수 있는 정책 그룹이 포함되어 있습니다. 각 정책은 아래에 요약되어 있습니다. 마지막 세 가지 정책은 세 가지 기본 레이블 대신 정수 설정을 지원합니다.

[[mac-seeotheruids]]
=== MAC See Other UIDs 정책

모듈 이름: [.filename]#mac_seeotheruids.ko#

커널 구성 줄: `options MAC_SEEOTHERUIDS`

부팅 옵션: `mac_seeotheruids_load="YES"`

man:mac_seeotheruids[4] 모듈은 `security.bsd.see_other_uids` 및 `security.bsd.see_other_gids sysctl` 튜너블을 확장합니다. 이 옵션은 구성 전에 레이블을 설정할 필요가 없으며 다른 모듈과 함께 투명하게 작동할 수 있습니다.

모듈을 로드한 후 다음 `sysctl` 튜너블을 사용하여 모듈의 기능을 제어할 수 있습니다:

* `security.mac.seeotheruids.enabled` 는 모듈을 활성화하고 사용자가 다른 사용자가 소유한 프로세스 및 소켓을 볼 수 없도록 하는 기본 설정을 구현합니다.
* `security.mac.seeotheruids.specificgid_enabled` 를 사용하면 지정된 그룹이 이 정책에서 면제될 수 있습니다. 특정 그룹을 면제하려면 `security.mac.seeotheruids.specificgid=_XXX_ sysctl` 튜너블을 사용하여 _XXX_ 를 면제할 숫자 그룹 ID로 바꾸면 됩니다.
* `security.mac.seeotheruids.primarygroup_enabled` 는 특정 주 그룹을 이 정책에서 제외하는 데 사용됩니다. 이 튜너블을 사용하는 경우 `security.mac.seeotheruids.specificgid_enabled` 가 설정되지 않을 수 있습니다.

[[mac-bsdextended]]
=== MAC BSD Extended 정책

모듈 이름: [.filename]#mac_bsdextended.ko#

커널 구성 줄: `options MAC_BSDEXTENDED`

부팅 옵션: `mac_bsdextended_load="YES"`

man:mac_bsdextended[4] 모듈은 파일 시스템 방화벽에 적용됩니다. 이 모듈은 표준 파일 시스템 권한 모델에 대한 확장을 제공하여 관리자가 파일 시스템 계층 구조에서 파일, 유틸리티 및 디렉터리를 보호하기 위해 방화벽과 유사한 규칙 집합을 만들 수 있도록 합니다. 파일 시스템 개체에 대한 액세스가 시도되면 일치하는 규칙을 찾거나 끝 부분에 도달할 때까지 규칙 목록이 반복됩니다. 이 동작은 `security.mac.bsdextended.firstmatch_enabled` 를 사용하여 변경할 수 있습니다. FreeBSD의 다른 방화벽 모듈과 유사하게, 접근 제어 규칙이 포함된 파일은 부팅 시 man:rc.conf[5] 변수를 사용하여 시스템에서 생성하고 읽을 수 있습니다.

규칙 목록은 man:ipfw[8]와 유사한 구문을 가진 man:ugidfw[8]를 사용하여 입력할 수 있습니다. man:libugidfw[3] 라이브러리에 있는 함수를 사용하여 더 많은 도구를 작성할 수 있습니다.

man:mac_bsdextended[4] 모듈을 로드한 후 다음 명령을 사용하여 현재 규칙 구성을 나열할 수 있습니다:

[source, shell]
....
# ugidfw list
0 slots, 0 rules
....

기본적으로 규칙이 정의되어 있지 않으며 모든 항목에 완전히 액세스할 수 있습니다. 사용자의 모든 액세스를 차단하지만 `root` 는 영향을 받지 않는 규칙을 만들려면 다음과 같이 하세요:

[source, shell]
....
# ugidfw add subject not uid root new object not uid root mode n
....

이 규칙은 구현하기는 간단하지만 모든 사용자가 명령을 실행하지 못하도록 차단하므로 매우 나쁜 아이디어입니다. 보다 현실적인 예는 ``_user1`` 의 홈 디렉터리에 대한 디렉토리 목록을 포함한 모든 액세스를 ``_user2_`` 에서 차단하는 것입니다:

[source, shell]
....
# ugidfw set 2 subject uid user1 object uid user2 mode n
# ugidfw set 3 subject uid user1 object gid user2 mode n
....

모든 사용자에게 동일한 접근 제한을 적용하기 위해 `user1` 대신 `not uid _user2_` 를 사용할 수 있습니다. 그러나 `root` 사용자는 이러한 규칙의 영향을 받지 않습니다.

[NOTE]
====
이 모듈을 잘못 사용하면 파일 시스템의 특정 부분에 대한 액세스가 차단될 수 있으므로 이 모듈로 작업할 때는 각별한 주의를 기울여야 합니다.
====

[[mac-ifoff]]
=== MAC Interface Silencing 정책

모듈 이름: [.filename]#mac_ifoff.ko#

커널 구성 줄: `options MAC_IFOFF`

부팅 옵션: `mac_ifoff_load="YES"`

man:mac_ifoff[4] 모듈은 네트워크 인터페이스를 즉시 비활성화하고 시스템 부팅 중에 네트워크 인터페이스가 나타나지 않도록 하는 데 사용됩니다. 이 모듈은 레이블을 사용하지 않으며 다른 MAC 모듈에 의존하지 않습니다.

이 모듈의 제어는 대부분 이 `sysctl` 튜너블을 통해 수행됩니다:

* `security.mac.ifoff.lo_enabled` 는 루프백, man:lo[4], 인터페이스의 모든 트래픽을 활성화 또는 비활성화합니다.
* `security.mac.ifoff.bpfrecv_enabled` 는 버클리 패킷 필터 인터페이스의 모든 트래픽을 활성화 또는 비활성화합니다(man:bpf[4]).
* `security.mac.ifoff.other_enabled` 는 다른 모든 인터페이스의 트래픽을 활성화 또는 비활성화합니다.

man:mac_ifoff[4]의 가장 일반적인 용도 중 하나는 부팅 시퀀스 중에 네트워크 트래픽이 허용되지 않아야 하는 환경에서 네트워크 모니터링입니다. 또 다른 용도로는 package:security/aide[] 같은 애플리케이션을 사용하여 보호된 디렉터리에서 새 파일이나 변경된 파일을 발견하면 네트워크 트래픽을 자동으로 차단하는 스크립트를 작성할 수 있습니다.

[[mac-portacl]]
=== MAC Port Access Control List 정책

모듈 이름: [.filename]#mac_portacl.ko#

커널 구성 줄: `MAC_PORTACL`

부팅 옵션: `mac_portacl_load="YES"`

man:mac_portacl[4] 모듈은 로컬 TCP 및 UDP 포트로 바인딩을 제한하는 데 사용되며, `root` 가 아닌 사용자가 1024 미만의 지정된 권한 포트에 바인딩하도록 허용할 수 있습니다.

이 모듈이 로드되면 모든 소켓에서 MAC 정책을 활성화합니다. 다음과 같은 튜너블을 사용할 수 있습니다:

* `security.mac.portacl.enabled` 는 정책을 완전히 활성화 또는 비활성화합니다.
* `security.mac.portacl.port_high` 는 man:mac_portacl[4]이 보호하는 가장 높은 포트 번호를 설정합니다.
* `security.mac.portacl.suser_exempt` 를 0이 아닌 값으로 설정하면 이 정책에서 `root` 사용자를 면제합니다.
* `security.mac.portacl.rules` 는 정책을 `규칙[,규칙,...]` 형식의 텍스트 문자열로 지정하며, 필요한 만큼의 규칙을 포함하며, 각 규칙은 `idtype:id:protocol:port` 형식입니다. `idtype` 은 `uid` 또는 `gid` 입니다. `protocol` 매개변수는 `tcp` 또는 `udp` 일 수 있습니다. `port` 매개변수는 지정된 사용자 또는 그룹이 바인딩할 수 있는 포트 번호입니다. 사용자 ID, 그룹 ID 및 포트 매개변수에는 숫자 값만 사용할 수 있습니다.

기본적으로 1024 미만의 포트는 `root` 로 실행되는 권한 있는 프로세스만 사용할 수 있습니다. 권한이 없는 프로세스가 1024 미만의 포트에 바인딩할 수 있게 하려면 man:mac_portacl[4]에 다음과 같이 튜너블을 설정하세요:

[source, shell]
....
# sysctl security.mac.portacl.port_high=1023
# sysctl net.inet.ip.portrange.reservedlow=0
# sysctl net.inet.ip.portrange.reservedhigh=0
....

`root` 사용자가 이 정책의 영향을 받지 않도록 하려면 `security.mac.portacl.suser_exempt` 를 0이 아닌 값으로 설정하세요.

[source, shell]
....
# sysctl security.mac.portacl.suser_exempt=1
....

UID 80을 가진 `www` 사용자가 `root` 권한 없이도 포트 80에 바인딩할 수 있도록 허용합니다:

[source, shell]
....
# sysctl security.mac.portacl.rules=uid:80:tcp:80
....

다음 예에서는 UID가 1001인 사용자가 TCP 포트 110(POP3) 및 995(POP3s)에 바인딩할 수 있도록 허용합니다:

[source, shell]
....
# sysctl security.mac.portacl.rules=uid:1001:tcp:110,uid:1001:tcp:995
....

[[mac-partition]]
=== MAC Partition 정책

모듈 이름: [.filename]#mac_partition.ko#

커널 구성 줄: `options MAC_PARTITION`

부팅 옵션: `mac_partition_load="YES"`

man:mac_partition[4] 정책은 프로세스를 MAC 레이블에 따라 특정 "파티션"으로 드롭합니다. 이 정책에 대한 대부분의 구성은 man:setpmac[8]을 사용하여 수행됩니다. 이 정책에는 하나의 `sysctl` 튜너블을 사용할 수 있습니다:

* `security.mac.partition.enabled` 는 MAC 프로세스 파티션의 적용을 활성화합니다.

이 정책을 활성화하면 사용자는 자신의 프로세스와 파티션 내의 다른 프로세스를 볼 수 있지만 이 파티션의 범위를 벗어난 유틸리티로 작업할 수 없습니다. 예를 들어, `insecure` 클래스의 사용자는 프로세스를 생성해야 하는 다른 많은 명령뿐만 아니라 `top` 에도 액세스할 수 없습니다.

이 예에서는 `insecure` 클래스의 사용자에 설정된 레이블에 `top` 을 추가합니다. `insecure` 클래스의 사용자에 의해 생성된 모든 프로세스는 `partition/13` 레이블에 유지됩니다.

[source, shell]
....
# setpmac partition/13 top
....

이 명령은 파티션 레이블과 프로세스 목록을 표시합니다:

[source, shell]
....
# ps Zax
....

이 명령은 다른 사용자의 프로세스 파티션 레이블과 해당 사용자의 현재 실행 중인 프로세스를 표시합니다:

[source, shell]
....
# ps -ZU trhodes
....

[NOTE]
====
man:mac_seeotheruids[4] 정책이 로드되지 않는 한 사용자는 ``root`` 의 레이블에서 프로세스를 볼 수 있습니다.
====

[[mac-mls]]
=== MAC Multi-Level Security 모듈

모듈 이름: [.filename]#mac_mls.ko#

커널 구성 줄: `options MAC_MLS`

부팅 옵션: `mac_mls_load="YES"`

man:mac_mls[4] 정책은 엄격한 정보 흐름 정책을 적용하여 시스템에서 주체와 객체 간의 액세스를 제어합니다.

MLS 환경에서는 구획과 함께 각 주체 또는 개체의 라벨에 "클리어런스" 레벨이 설정됩니다. 이러한 클리어런스 수준은 수천 개가 넘는 숫자에 달할 수 있으므로 모든 주체 또는 개체를 철저하게 구성하는 것은 어려운 작업입니다. 이러한 관리 부담을 덜어주기 위해 이 정책에는 세 가지 레이블이 포함되어 있습니다: 'mls/low', 'mls/equal', 'mls/high' 입니다:

* `mls/low` 로 레이블이 지정된 모든 항목은 낮은 권한 수준을 가지며 더 높은 수준의 정보에 액세스할 수 없습니다. 또한 이 레이블은 더 높은 수준의 개체가 더 낮은 수준의 개체에 정보를 쓰거나 전달할 수 없도록 차단합니다.
* 정책에서 제외되어야 하는 객체에는 `mls/equal` 을 설정해야 합니다.
* `mls/high` 는 가능한 가장 높은 수준의 클리어런스입니다. 이 레이블이 할당된 개체는 시스템의 다른 모든 개체보다 우월한 권한을 갖지만, 하위 클래스의 개체에 대한 정보 유출은 허용하지 않습니다.

MLS는 다음을 제공합니다:

* 계층적 보안 수준과 비계층적 카테고리 집합이 포함된 계층적 보안 수준.
* '상향 읽기 금지, 하향 쓰기 금지'의 고정된 규칙. 즉, 주체는 자신의 레벨 이하에 있는 객체에 대한 읽기 액세스 권한을 가질 수 있지만 그 위에는 액세스할 수 없습니다. 마찬가지로, 주체는 자신의 레벨 또는 그 위에 있는 객체에 대한 쓰기 액세스 권한을 가질 수 있지만 그 아래에는 액세스할 수 없습니다.
* 비밀 유지 또는 부적절한 데이터 공개 방지.
* 비밀과 기밀 사이의 정보 유출 없이 여러 민감도 수준의 데이터를 동시에 처리하는 시스템 설계를 위한 기반.

다음과 같은 `sysctl` 튜너블을 사용할 수 있습니다:

* `security.mac.mls.enabled` 는 MLS 정책을 활성화 또는 비활성화하는 데 사용됩니다.
* `security.mac.mls.ptys_equal` 은 생성하는 동안 모든 man:pty[4] 디바이스를 `mls/equal` 로 레이블을 지정합니다.
* `security.mac.mls.revocation_enabled` 는 레이블이 더 낮은 등급의 레이블로 변경시킨 후 개체에 대한 액세스를 취소합니다.
* `security.mac.mls.max_compartments` 는 시스템에서 허용되는 최대 구획 레벨 수를 설정합니다.

MLS 레이블을 조작하려면 man:setfmac[8]을 사용합니다. 객체에 레이블을 할당하려면:

[source, shell]
....
# setfmac mls/5 test
....

[.filename]#test# 파일에 대한 MLS 레이블을 가져오려면:

[source, shell]
....
# getfmac test
....

또 다른 접근 방식은 [.filename]#/etc/# 에 MLS 정책 정보를 지정하는 마스터 정책 파일을 만들고 해당 파일을 `setfmac` 에 제공하는 것입니다.

MLS 정책 모듈을 사용할 때 관리자는 민감한 정보의 흐름을 제어할 계획을 합니다. 기본 '블록 읽기 블록 쓰기' 는 모든 것을 낮은 상태로 설정합니다. 모든 항목에 액세스할 수 있으며 관리자는 정보의 기밀성을 서서히 강화합니다.

세 가지 기본 라벨 옵션 외에도 관리자는 필요에 따라 사용자 및 그룹을 그룹화하여 사용자 간의 정보 흐름을 차단할 수 있습니다. `Confidential`, `Secret`, `Top Secret` 과 같은 분류를 사용하면 정보를 등급별로 보기가 더 쉬워질 수 있습니다. 대신 일부 관리자는 프로젝트 레벨에 따라 다른 그룹을 만들기도 합니다. 어떤 분류 방법을 사용하든, 제한적인 정책을 시행하기 전에 신중한 계획이 있어야 합니다.

MLS 정책 모듈의 몇 가지 예시 상황에는 전자상거래 웹 서버, 중요한 회사 정보를 보관하는 파일 서버, 금융 기관 환경 등이 있습니다.

[[mac-biba]]
=== MAC Biba 모듈

모듈 이름: [.filename]#mac_biba.ko#

커널 구성 줄: `options MAC_BIBA`

부팅 옵션: `mac_biba_load="YES"`

man:mac_biba[4] 모듈은 MAC Biba 정책을 로드합니다. 이 정책은 정보 흐름에 대한 규칙이 약간 뒤바뀐다는 점을 제외하면 MLS 정책과 유사합니다. 이는 MLS 정책이 민감한 정보의 하향 흐름을 방지하는 반면, 민감한 정보의 상향 흐름을 방지하기 위한 것입니다.

Biba 환경에서는 각 주제 또는 객체에 "integrity" 레이블이 설정됩니다. 이러한 레이블은 계층적 성적과 비계층적 구성 요소로 구성됩니다. 등급이 올라갈수록 무결성도 높아집니다.

지원되는 레이블은 `biba/low`, `biba/equal`, `biba/high` 이며, 여기서:

* `biba/low` 는 객체 또는 주체가 가질 수 있는 가장 낮은 무결성으로 간주됩니다. 객체 또는 주체에 이 값을 설정하면 `biba/high` 로 표시된 객체 또는 주체에 대한 쓰기 액세스가 차단되지만 읽기 액세스는 차단되지 않습니다.
* `biba/equal` 는 정책에서 제외되는 것으로 간주되는 객체에만 배치해야 합니다.
* `biba/high` 는 하위 레이블로 설정된 개체에 대한 쓰기는 허용하지만 해당 개체에 대한 읽기는 허용하지 않습니다. 이 레이블은 전체 시스템의 무결성에 영향을 미치는 개체에 설정하는 것이 좋습니다.

Biba는 다음을 제공합니다:

* 계층적 무결성 수준과 비계층적 무결성 카테고리가 포함된 계층적 무결성 수준.
* '상향 쓰기 금지, 하향 읽기 금지'의 고정된 규칙, MLS와 반대입니다. 주체는 자신의 수준 이하에 있는 개체에 대한 쓰기 권한을 가질 수 있지만 그 위에는 접근할 수 없습니다. 마찬가지로 주체는 자신의 수준 또는 그 위에 있는 객체에 대한 읽기 액세스 권한을 가질 수 있지만 그 아래에는 액세스할 수 없습니다.
* 데이터의 부적절한 수정을 방지하여 무결성을 유지.
* MLS 민감도 수준 대신 무결성 수준.

다음 튜너블을 사용하여 Biba 정책을 조작할 수 있습니다:

* `security.mac.biba.enabled` 는 대상 머신에서 비바 정책의 적용을 활성화 또는 비활성화하는 데 사용됩니다.
* `security.mac.biba.ptys_equal` 은 man:pty[4] 장치에서 Biba 정책을 비활성화하는 데 사용됩니다.
* `security.mac.biba.revocation_enabled` 는 레이블이 주체를 지배하도록 변경한 경우 개체에 대한 액세스 권한을 강제로 취소합니다.

시스템 개체의 Biba 정책 설정에 액세스하려면 `setfmac` 및 `getfmac` 을 사용합니다:

[source, shell]
....
# setfmac biba/low test
# getfmac test
test: biba/low
....

민감도와는 다른 무결성은, 신뢰할 수 없는 당사자가 정보를 조작하지 못하도록 보장하는 데 사용됩니다. 여기에는 주체와 객체 간에 전달되는 정보가 포함됩니다. 이는 사용자가 명시적으로 액세스 권한이 부여된 정보만 수정하거나 액세스할 수 있도록 보장합니다. 관리자는 man:mac_biba[4] 보안 정책 모듈을 사용하여 사용자가 보고 호출할 수 있는 파일과 프로그램을 구성하는 동시에 해당 사용자를 위해 시스템에서 해당 프로그램과 파일을 신뢰할 수 있도록 보장할 수 있습니다.

초기 계획 단계에서 관리자는 사용자를 등급, 수준 및 영역으로 분할할 준비가 되어 있어야 합니다. 이 정책 모듈이 활성화되면 시스템은 기본적으로 높은 레이블로 설정되며, 사용자에 대한 다양한 등급 및 레벨을 구성하는 것은 관리자의 몫입니다. 권한 수준을 사용하는 대신 주제를 포함하는 것도 좋은 계획 방법이 될 수 있습니다. 예를 들어 개발자에게만 소스 코드 리포지토리, 소스 코드 컴파일러 및 기타 개발 유틸리티에 대한 수정 액세스 권한을 허용할 수 있습니다. 다른 사용자는 테스터, 디자이너 또는 최종 사용자와 같은 다른 카테고리로 그룹화하여 읽기 액세스 권한만 허용할 수 있습니다.

무결성이 낮은 주체는 무결성이 높은 주체에 쓰기를 할 수 없으며, 무결성이 높은 주체는 무결성이 낮은 객체를 나열하거나 읽을 수 없습니다. 레이블을 가능한 가장 낮은 등급으로 설정하면 주체가 해당 레이블에 접근할 수 없게 될 수 있습니다. 이 보안 정책 모듈을 구현할 수 있는 환경으로는 제한된 웹 서버, 개발 및 테스트 머신, 소스 코드 리포지토리 등이 있습니다. 덜 유용한 구현으로는 개인 워크스테이션, 라우터로 사용되는 컴퓨터 또는 네트워크 방화벽이 있습니다.

[[mac-lomac]]
=== MAC Low-watermark 모듈

모듈 이름: [.filename]#mac_lomac.ko#

커널 구성 줄: `options MAC_LOMAC`

부팅 옵션: `mac_lomac_load="YES"`

MAC Biba 정책과 달리, man:mac_lomac[4] 정책은 무결성 규칙을 방해하지 않도록 무결성 수준을 낮춘 후에만 낮은 무결성 개체에 대한 액세스를 허용합니다.

Low-watermark 무결성 정책은 보조 등급 칸을 통해 주체 강등을 지원하기 위한 플로팅 레이블을 사용하는 것을 제외하고는 Biba와 거의 동일하게 작동합니다. 이 보조 구획은 `[auxgrade]` 형식을 취합니다. 보조 등급이 있는 정책을 할당할 때는 `lomac/10[2]` 구문을 사용하며, 여기서 `2` 는 보조 등급입니다.

이 정책은 모든 시스템 개체에 무결성 레이블을 유비쿼터스 레이블로 지정하여 주체가 낮은 무결성 개체를 읽을 수 있도록 허용한 다음 주체의 레이블을 다운그레이드하여 향후 '[auxgrade]` 를 사용하여 높은 무결성 오브젝트에 쓰지 못하도록 하는 방식입니다. 이 정책은 Biba보다 호환성이 더 뛰어나고 초기 구성이 덜 필요할 수 있습니다.

Biba 및 MLS 정책과 마찬가지로 `setfmac` 및 `setpmac` 은 시스템 개체에 레이블을 배치하는 데 사용됩니다:

[source, shell]
....
# setfmac /usr/home/trhodes lomac/high[low]
# getfmac /usr/home/trhodes lomac/high[low]
....

보조 등급 `low` 은 MACLOMAC 정책으로만 제공되는 기능입니다.

[[mac-userlocked]]
== 사용자 잠금

이 예에서는 사용자가 50명 미만인 비교적 작은 스토리지 시스템을 고려합니다. 사용자에게는 로그인 기능이 있으며 데이터를 저장하고 리소스에 액세스할 수 있습니다.

이 시나리오의 경우, 사용자 프로세스를 숨기면서 시스템 오브젝트에 대한 액세스를 차단하는 man:mac_bsdextended[4] 및 man:mac_seeotheruids[4] 정책 모듈이 공존하여 시스템 오브젝트에 대한 액세스를 차단할 수 있습니다.

[.filename]#/boot/loader.conf# 에 다음 줄을 추가하여 시작합니다:

[.programlisting]
....
mac_seeotheruids_load="YES"
....

man:mac_bsdextended[4] 보안 정책 모듈은 [.filename]#/etc/rc.conf# 에 이 줄을 추가하여 활성화할 수 있습니다:

[.programlisting]
....
ugidfw_enable="YES"
....

[.filename]#/etc/rc.bsdextended# 에 저장된 기본 규칙은 시스템 초기화 시 로드됩니다. 그러나 기본 항목은 수정이 필요할 수 있습니다. 이 머신은 사용자에게만 서비스를 제공할 것으로 예상되므로 기본적으로 사용자 소유의 시스템 객체를 강제로 로드하기 위해 마지막 두 줄을 제외한 모든 항목을 주석 처리하지 않을 수 있습니다.

이 머신에 필요한 사용자를 추가하고 재부팅합니다. 테스트를 위해 두 콘솔에서 다른 사용자로 로그인해 보세요. `ps aux` 를 실행하여 다른 사용자의 프로세스가 표시되는지 확인합니다. 다른 사용자의 홈 디렉터리에서 man:ls[1]를 실행해도 실패하는지 확인합니다.

슈퍼 유저의 접근을 차단하기 위해 특정 ``sysctl`` 을 수정하지 않는 한 `root` 사용자로 테스트하지 마세요.

[NOTE]
====
새 사용자가 추가되면 해당 사용자의 man:mac_bsdextended[4] 규칙은 규칙 집합 목록에 없습니다. 규칙 집합을 빠르게 업데이트하려면 보안 정책 모듈을 언로드한 후 man:kldunload[8] 및 man:kldload[8]을 사용하여 다시 로드하세요.
====

[[mac-implementing]]
== MAC Jail안의 Nagios

이 섹션에서는 MAC 환경에서 Nagios 네트워크 모니터링 시스템을 구현하는 데 필요한 단계를 설명합니다. 이는 프로덕션 환경에서 사용하기 전에 구현된 정책이 네트워크의 보안 요구 사항을 충족하는지 관리자가 테스트해야 하는 예시입니다.

이 예제에서는 각 파일 시스템에 `multilabel` 을 설정해야 합니다. 또한 MAC 프레임워크에 통합을 시도하기 전에 package:net-mgmt/nagios-plugins[], package:net-mgmt/nagios[] 및 package:www/apache22[]가 모두 설치, 구성 및 올바르게 작동하고 있다고 가정합니다.

=== Insecure 사용자 클래스 생성

다음 사용자 클래스를 [.filename]#/etc/login.conf# 에 추가하여 절차를 시작합니다:

[.programlisting]
....
insecure:\
:copyright=/etc/COPYRIGHT:\
:welcome=/etc/motd:\
:setenv=MAIL=/var/mail/$,BLOCKSIZE=K:\
:path=~/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin
:manpath=/usr/share/man /usr/local/man:\
:nologin=/usr/sbin/nologin:\
:cputime=1h30m:\
:datasize=8M:\
:vmemoryuse=100M:\
:stacksize=2M:\
:memorylocked=4M:\
:memoryuse=8M:\
:filesize=8M:\
:coredumpsize=8M:\
:openfiles=24:\
:maxproc=32:\
:priority=0:\
:requirehome:\
:passwordtime=91d:\
:umask=022:\
:ignoretime@:\
:label=biba/10(10-10):
....

그런 다음 기본 사용자 클래스 섹션에 다음 줄을 추가합니다:

[.programlisting]
....
:label=biba/high:
....

편집 내용을 저장하고 다음 명령을 실행하여 데이터베이스를 다시 빌드합니다:

[source, shell]
....
# cap_mkdb /etc/login.conf
....

=== 사용자 구성

다음을 사용하여 `root` 사용자를 기본 클래스로 설정합니다:

[source, shell]
....
# pw usermod root -L default
....

이제 `root` 가 아닌 모든 사용자 계정에 로그인 클래스가 필요합니다. 로그인 클래스가 필요하지 않으면 사용자는 일반 명령에 대한 액세스가 거부됩니다. 다음 `sh` 스크립트를 사용하면 됩니다:

[source, shell]
....
# for x in `awk -F: '($3 >= 1001) && ($3 != 65534) { print $1 }' \
	/etc/passwd`; do pw usermod $x -L default; done;
....

다음으로, `nagios` 및 `www` 계정을 안전하지 않은 클래스로 드롭합니다:

[source, shell]
....
# pw usermod nagios -L insecure
# pw usermod www -L insecure
....

=== 컨텍스트 파일 생성

컨텍스트 파일은 이제 [.filename]#/etc/policy.contexts# 형태로 만들어집니다:

[.programlisting]
....
# This is the default BIBA policy for this system.

# System:
/var/run(/.*)?			biba/equal

/dev/(/.*)?			biba/equal

/var				biba/equal
/var/spool(/.*)?		biba/equal

/var/log(/.*)?			biba/equal

/tmp(/.*)?			biba/equal
/var/tmp(/.*)?			biba/equal

/var/spool/mqueue		biba/equal
/var/spool/clientmqueue		biba/equal

# For Nagios:
/usr/local/etc/nagios(/.*)?	biba/10

/var/spool/nagios(/.*)?		biba/10

# For apache
/usr/local/etc/apache(/.*)?	biba/10
....

이 정책은 정보 흐름에 제한을 설정하여 보안을 강화합니다. 이 특정 구성에서는 `root` 를 포함한 사용자가 Nagios에 액세스할 수 있도록 해서는 안 됩니다. Nagios의 일부인 구성 파일 및 프로세스는 완전히 자체적으로 포함되거나 jail화 됩니다.

이 파일은 모든 파일 시스템에서 `setfsmac` 을 실행한 후에 읽습니다. 이 예에서는 루트 파일 시스템에 대한 정책을 설정합니다:

[source, shell]
....
# setfsmac -ef /etc/policy.contexts /
....

그런 다음 [.filename]#/etc/mac.conf# 의 기본 섹션에 이러한 편집 내용을 추가합니다:

[.programlisting]
....
default_labels file ?biba
default_labels ifnet ?biba
default_labels process ?biba
default_labels socket ?biba
....

=== 로더 구성

구성을 완료하려면 [.filename]#/boot/loader.conf# 에 다음 줄을 추가합니다:

[.programlisting]
....
mac_biba_load="YES"
mac_seeotheruids_load="YES"
security.mac.biba.trust_all_interfaces=1
....

그리고 [.filename]#/etc/rc.conf# 파일의 저장된 네트워크 카드 구성에 다음 줄을 추가합니다. 기본 네트워크 구성이 DHCP를 통해 수행되는 경우 시스템을 부팅할 때마다 수동으로 구성해야 할 수 있습니다:

[.programlisting]
....
maclabel biba/equal
....

=== 구성 테스트하기

먼저, 시스템 초기화 및 재부팅 시 웹 서버와 Nagios가 시작되지 않도록 합니다. `root` 가 Nagios 구성 디렉터리에 있는 파일에 액세스할 수 없는지 확인합니다. `root` 가 [.filename]#/var/spool/nagios# 의 내용을 나열할 수 있다면 문제가 있는 것입니다. 대신 "permission denied" 오류가 반환되어야 합니다.

모든 것이 정상이면 이제 Nagios, Apache 및 Sendmail을 시작할 수 있습니다:

[source, shell]
....
# cd /etc/mail && make stop && \
setpmac biba/equal make start && setpmac biba/10\(10-10\) apachectl start && \
setpmac biba/10\(10-10\) /usr/local/etc/rc.d/nagios.sh forcestart
....

모든 것이 제대로 작동하는지 다시 확인하세요. 그렇지 않은 경우 로그 파일에서 오류 메시지를 확인하세요. 필요한 경우 man:sysctl[8]을 사용하여 man:mac_biba[4] 보안 정책 모듈을 비활성화하고 평소와 같이 모든 것을 다시 시작하세요.

[NOTE]
====
`root` 사용자는 여전히 보안 적용을 변경하고 구성 파일을 편집할 수 있습니다. 다음 명령은 새로 생성된 셸에 대해 보안 정책을 더 낮은 등급으로 낮출 수 있도록 허용합니다:

[source, shell]
....
# setpmac biba/10 csh
....

이런 일이 발생하지 않도록 차단하려면 man:login.conf[5]를 사용하여 사용자를 강제로 범위 안에 넣으세요. man:setpmac[8]이 구획의 범위를 벗어난 명령을 실행하려고 하면 오류가 반환되고 명령이 실행되지 않습니다. 이 경우 루트를 `biba/high(high-high)` 로 설정하세요.
====

[[mac-troubleshoot]]
== MAC 프레임워크 문제 해결

이 섹션에서는 일반적인 구성 오류와 이를 해결하는 방법에 대해 설명합니다.

`multilabel` 플래그가 루트( [.filename]#/# ) 파티션에서 활성화된 상태로 유지되지 않습니다:::
다음 단계를 수행하면 이 일시적인 오류를 해결할 수 있습니다:

[.procedure]
====
. [.filename]#/etc/fstab# 을 편집하고 루트 파티션을 읽기 전용인 `ro` 로 설정합니다.
. 단일 사용자 모드로 재부팅합니다.
. [.filename]#/# 에서 `tunefs -l enable` 을 실행합니다.
. 시스템을 재부팅합니다.
. `mount -urw` [.filename]#/# 를 실행하고 [.filename]#/etc/fstab# 에서 `ro` 를 다시 `rw` 로 변경한 후 시스템을 다시 부팅합니다.
. `mount` 의 출력을 다시 확인하여 `multilabel` 이 루트 파일 시스템에 올바르게 설정되었는지 확인합니다.
====

MAC으로 보안 환경을 설정한 후 Xorg가 더 이상 시작되지 않습니다:::
이는 MAC `partition` 정책 또는 MAC 레이블링 정책 중 하나에서 잘못된 레이블링으로 인해 발생할 수 있습니다. 디버그하려면 다음을 시도해 보세요:

[.procedure]
====
. 오류 메시지를 확인합니다. 사용자가 `insecure` 클래스에 속하는 경우 `partition` 정책이 원인일 수 있습니다. 사용자의 클래스를 `default` 클래스로 다시 설정하고 `cap_mkdb` 로 데이터베이스를 다시 빌드해 보세요. 그래도 문제가 해결되지 않으면 2단계로 이동합니다.
. 레이블 정책이 사용자, Xorg 및 [.filename]#/dev# 항목에 대해 올바르게 설정되었는지 다시 확인합니다.
. 이 두 가지 방법으로도 문제가 해결되지 않으면 오류 메시지와 환경에 대한 설명을 {freebsd-questions} 로 보내세요.
====

`_secure_path: unable to stat .login_conf` 오류가 나타납니다:::
이 오류는 사용자가 시스템에서 `root` 사용자에서 다른 사용자로 전환하려고 할 때 나타날 수 있습니다. 이 메시지는 일반적으로 사용자가 변경하려는 사용자보다 더 높은 레이블 설정을 가지고 있을 때 발생합니다. 예를 들어, `joe` 의 기본 레이블이 `biba/low` 이고 `root` 의 레이블이 `biba/high` 인 경우, `root` 는 `joe` 의 홈 디렉터리를 볼 수 없습니다. 이는 `root` 가 `su` 를 사용하여 `joe` 가 되었는지 여부에 관계없이 발생하며, Biba 무결성 모델은 `root` 가 더 낮은 무결성 수준으로 설정된 개체를 볼 수 있도록 허용하지 않기 때문입니다.

시스템이 더 이상 `root` 를 인식하지 못합니다:::
이 경우 `whoami` 는 `0` 을 반환하고 `su` 는 `who are you?` 를 반환합니다.
+
이 문제는 man:sysctl[8]에 의해 라벨링 정책이 비활성화되었거나 정책 모듈이 언로드된 경우에 발생할 수 있습니다. 정책이 비활성화되어 있으면 로그인 기능 데이터베이스를 다시 구성해야 합니다. [.filename]#/etc/login.conf# 에서 모든 `label` 옵션이 제거되었는지 다시 확인하고 `cap_mkd b`로 데이터베이스를 다시 빌드하세요.
+
정책에서 [.filename]#master.passwd# 에 대한 액세스를 제한하는 경우에도 이 문제가 발생할 수 있습니다. 이는 일반적으로 관리자가 시스템에서 사용 중인 일반 정책과 충돌하는 레이블로 파일을 변경했기 때문에 발생합니다. 이 경우 시스템에서 사용자 정보를 읽고 파일이 새 레이블을 상속받았으므로 액세스가 차단됩니다. man:sysctl[8]을 사용하여 정책을 비활성화하면 모든 것이 정상으로 돌아옵니다.
