---
description: '이 장에서는 FreeBSD에서 직렬 통신을 사용할 수 있는 몇 가지 방법을 다룹니다'
next: books/handbook/ppp-and-slip
part: '파트 IV. 네트워크 통신'
path: /books/handbook/
prev: books/handbook/partiv
showBookMenu: 'true'
tags: ["serial", "communications", "terminal", "modem", "console"]
title: '28장. 직렬 통신'
weight: 33
---

[[serialcomms]]
= 직렬 통신
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 28
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/serialcomms/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[serial-synopsis]]
== 요약

최초의 UNIX(R) 머신은 사용자 입력과 출력을 직렬 회선에 의존했기 때문에 UNIX(R)는 항상 직렬 통신을 지원했습니다. 평균적인 터미널이 초당 10자를 출력하는 직렬 프린터와 키보드로 구성되던 시절과는 상황이 많이 달라졌습니다. 이 장에서는 FreeBSD에서 시리얼 통신을 사용할 수 있는 몇 가지 방법을 다룹니다.

이 장을 읽고 나면 다음을 알 수 있습니다:

* 터미널을 FreeBSD 시스템에 연결하는 방법.
* 모뎀을 사용하여 원격 호스트에 전화를 거는 방법.
* 원격 사용자가 모뎀을 사용하여 FreeBSD 시스템에 로그인할 수 있도록 허용하는 방법.
* 시리얼 콘솔에서 FreeBSD 시스템을 부팅하는 방법.

이 챕터를 읽기 전에 알아두어야 할 사항입니다:

* crossref:kernelconfig[kernelconfig, configure and install a custom kernel] 방법을 알고 있습니다.
* crossref:basics[basics, FreeBSD permissions and processes]을 이해합니다.
* FreeBSD와 함께 사용할 시리얼 하드웨어에 대한 기술 설명서에 접근할 수 있습니다.

[[serial]]
== 직렬 용어 및 하드웨어

직렬 통신에서 자주 사용되는 용어는 다음과 같습니다:

bps::
초당 비트 전송률(bps)은 데이터가 전송되는 속도입니다.

DTE::
데이터 터미널 장비(Data Terminal Equipment, DTE)는 직렬 통신의 두 가지 엔드포인트 중 하나입니다. 예를 들어 컴퓨터를 들 수 있습니다.

DCE::
데이터 통신 장비(Data Communications Equipment, DCE)는 직렬 통신의 다른 엔드포인트입니다. 일반적으로 모뎀 또는 직렬 터미널입니다.

RS-232::
하드웨어 직렬 통신을 정의한 최초의 표준입니다. 이후 TIA-232로 이름이 변경되었습니다.

통신 데이터 속도를 언급할 때 이 섹션에서는 _baud_ 라는 용어를 사용하지 않습니다. Baud는 일정 시간 동안 전기 상태가 전환되는 횟수를 의미하며, bps가 올바른 용어입니다.

직렬 터미널을 FreeBSD 시스템에 연결하려면 컴퓨터의 직렬 포트와 직렬 장치에 연결할 수 있는 적절한 케이블이 필요합니다. 직렬 하드웨어와 케이블에 이미 익숙한 사용자는 이 섹션을 건너뛰어도 됩니다.

[[term-cables-null]]
=== 직렬 케이블과 포트

직렬 케이블에는 여러 가지 종류가 있습니다. 가장 일반적인 두 가지 유형은 널 모뎀 케이블과 표준 RS-232 케이블입니다. 하드웨어 설명서에 필요한 케이블 유형이 설명되어 있어야 합니다.

이 두 가지 유형의 케이블은 전선이 커넥터에 연결되는 방식이 다릅니다. 각 와이어는 신호를 나타내며, 정의된 신호는 <<serialcomms-signal-names>> 에 요약되어 있습니다. 표준 직렬 케이블은 모든 RS-232C 신호를 바로 통과시킵니다. 예를 들어, 케이블 한쪽 끝의 "Transmitted Data" 핀은 다른 쪽 끝의 "Transmitted Data" 핀으로 연결됩니다. 이 케이블은 모뎀을 FreeBSD 시스템에 연결하는 데 사용되는 케이블 유형이며 일부 터미널에도 적합합니다.

널 모뎀 케이블은 한쪽 끝에 있는 커넥터의 "Transmitted Data" 핀을 다른 쪽 끝에 있는 "Received Data" 핀으로 전환합니다. 커넥터는 DB-25 또는 DB-9일 수 있습니다.

널 모뎀 케이블은 <<nullmodem-db25>>, <<nullmodem-db9>>, <<nullmodem-db9-25>> 에 요약된 핀 연결을 사용하여 구성할 수 있습니다. 표준에서는 핀 1에서 핀 1 "Protective Ground" 라인까지 직선 연결을 요구하지만, 종종 생략되는 경우가 있습니다. 일부 터미널은 2, 3, 7번 핀만 사용하여 작동하는 반면, 다른 터미널은 다른 구성이 필요합니다. 확실하지 않은 경우 하드웨어 설명서를 참조하세요.

[[serialcomms-signal-names]]
.RS-232C 신호 명칭
[cols="1,1", frame="none", options="header"]
|===
<| Acronyms
<| Names

|RD
|Received Data

|TD
|Transmitted Data

|DTR
|Data Terminal Ready

|DSR
|Data Set Ready

|DCD
|Data Carrier Detect

|SG
|Signal Ground

|RTS
|Request to Send

|CTS
|Clear to Send
|===

[[nullmodem-db25]]
.DB-25 - DB-25 널 모뎀 케이블
[cols="1,1,1,1,1", frame="none", options="header"]
|===
<| Signal
<| Pin #
| 
<| Pin #
<| Signal

|SG
|7
|connects to
|7
|SG

|TD
|2
|connects to
|3
|RD

|RD
|3
|connects to
|2
|TD

|RTS
|4
|connects to
|5
|CTS

|CTS
|5
|connects to
|4
|RTS

|DTR
|20
|connects to
|6
|DSR

|DTR
|20
|connects to
|8
|DCD

|DSR
|6
|connects to
|20
|DTR

|DCD
|8
|connects to
|20
|DTR
|===

[[nullmodem-db9]]
.DB-9 - DB-9 널 모뎀 케이블
[cols="1,1,1,1,1", frame="none", options="header"]
|===
<| Signal
<| Pin #
| 
<| Pin #
<| Signal

|RD
|2
|connects to
|3
|TD

|TD
|3
|connects to
|2
|RD

|DTR
|4
|connects to
|6
|DSR

|DTR
|4
|connects to
|1
|DCD

|SG
|5
|connects to
|5
|SG

|DSR
|6
|connects to
|4
|DTR

|DCD
|1
|connects to
|4
|DTR

|RTS
|7
|connects to
|8
|CTS

|CTS
|8
|connects to
|7
|RTS
|===

[[nullmodem-db9-25]]
.DB-9 - DB-25 널 모뎀 케이블
[cols="1,1,1,1,1", frame="none", options="header"]
|===
<| Signal
<| Pin #
| 
<| Pin #
<| Signal

|RD
|2
|connects to
|2
|TD

|TD
|3
|connects to
|3
|RD

|DTR
|4
|connects to
|6
|DSR

|DTR
|4
|connects to
|8
|DCD

|SG
|5
|connects to
|7
|SG

|DSR
|6
|connects to
|20
|DTR

|DCD
|1
|connects to
|20
|DTR

|RTS
|7
|connects to
|5
|CTS

|CTS
|8
|connects to
|4
|RTS
|===

[NOTE]
====
한쪽 끝의 핀이 다른 쪽 끝의 핀 쌍에 연결되는 경우, 일반적으로 커넥터의 핀 쌍 사이에는 하나의 짧은 와이어를, 다른 단일 핀에는 긴 와이어를 사용하여 구현합니다.
====

직렬 포트는 FreeBSD 호스트 컴퓨터와 터미널 간에 데이터를 전송하는 장치입니다. 여러 종류의 직렬 포트가 존재합니다. 케이블을 구입하거나 구성하기 전에 터미널과 FreeBSD 시스템의 포트에 맞는지 확인하십시오.

대부분의 단말기에는 DB-25 포트가 있습니다. 개인용 컴퓨터에는 DB-25 또는 DB-9 포트가 있을 수 있습니다. 멀티포트 직렬 카드에는 RJ-12 또는 RJ-45/ 포트가 있을 수 있습니다. 포트 종류에 대한 사양은 하드웨어와 함께 제공된 설명서를 참조하거나 포트 유형을 육안으로 확인하세요.

FreeBSD에서 각 직렬 포트는 [.filename]#/dev# 에 있는 항목을 통해 액세스합니다. 두 가지 종류의 항목이 있습니다:

* Call-in 포트의 이름은 [.filename]#/dev/ttyuN# 이며, 여기서 _N_ 은 0부터 시작하는 포트 번호입니다. 터미널이 첫 번째 직렬 포트( [.filename]#COM1# )에 연결되어 있는 경우 [.filename]#/dev/ttyu0# 을 사용하여 터미널을 참조합니다. 터미널이 두 번째 직렬 포트( [.filename]#COM2# )에 연결되어 있으면 [.filename]#/dev/ttyu1# 등을 사용합니다. 일반적으로 콜인 포트는 터미널에 사용됩니다. Call-in 포트가 올바르게 작동하려면 직렬 회선이 "Data Carrier Detect" 신호를 알려야 합니다.
* Call-out 포트의 이름은 FreeBSD 버전 8.X 이상에서는 [.filename]#/dev/cuauN#, FreeBSD 버전 7.X 이하에서는 [.filename]#/dev/cuadN# 으로 지정됩니다. Call-out 포트는 일반적으로 단말기에는 사용되지 않지만 모뎀에는 사용됩니다. 직렬 케이블이나 터미널이 "Data Carrier Detect" 신호를 지원하지 않는 경우 Call-out 포트를 사용할 수 있습니다.

FreeBSD는 초기화 장치( [.filename]#/dev/ttyuN.init# 및 [.filename]#/dev/cuauN.init# 또는 [.filename]#/dev/cuadN.init# )와 잠금 장치( [.filename]#/dev/ttyuN.lock# 및 [.filename]#/dev/cuauN.lock# 또는 [.filename]#/dev/cuadN.lock# ) 또한 제공하고 있습니다. 초기화 장치는 포트가 열릴 때마다 통신 포트 파라미터를 초기화하는 데 사용됩니다(예: 흐름 제어를 위해 `RTS/CTS` 신호를 사용하는 모뎀의 경우 `crtscts`). 잠금 장치는 사용자나 프로그램이 특정 매개변수를 변경하지 못하도록 포트의 플래그를 잠그는 데 사용됩니다. 터미널 설정, 장치 잠금 및 초기화, 터미널 옵션 설정에 대한 정보는 각각 man:termios[4], man:uart[4], man:stty[1]를 참고하세요.

[[serial-hw-config]]
=== 직렬 포트 구성

기본적으로 FreeBSD는 [.filename]#COM1#, [.filename]#COM2#, [.filename]#COM3#, [.filename]#COM4# 로 알려진 4개의 직렬 포트를 지원합니다. FreeBSD는 또한 BocaBoard 1008 및 2016과 같은 dumb 멀티 포트 직렬 인터페이스 카드뿐만 아니라 Digiboard에서 만든 것과 같은 보다 지능적인 멀티 포트 카드도 지원합니다. 그러나 기본 커널은 표준 [.filename]#COM# 포트만 찾습니다.

시스템이 직렬 포트를 인식하는지 확인하려면 `uart` 로 시작하는 시스템 부팅 메시지를 찾아보세요:

[source, shell]
....
# grep uart /var/run/dmesg.boot
....

시스템이 필요한 직렬 포트를 모두 인식하지 못하는 경우 [.filename]#/boot/device.hints# 에 추가 항목을 추가할 수 있습니다. 이 파일에는 이미 [.filename]#COM1# 에 대한 `hint.uart.0.\*` 항목과 [.filename]#COM2# 에 대한 `hint.uart.1.*` 항목이 포함되어 있습니다. 포트 항목을 추가할 때 [.filename]#COM3# 에는 `0x3E8` 을 사용하고, [.filename]#COM4# 에는 `0x2E8` 을 사용합니다. 일반적인 IRQ 주소는 [.filename]#COM3# 의 경우 `5`, [.filename]#COM4# 의 경우 `9` 입니다.

포트에서 사용하는 터미널 I/O 설정의 기본 집합을 확인하려면 해당 장치 이름을 지정합니다. 이 예에서는 [.filename]#COM2# 의 call-in 포트에 대한 설정을 결정합니다:

[source, shell]
....
# stty -a -f /dev/ttyu1
....

직렬 장치의 시스템 전체 초기화는 [.filename]#/etc/rc.d/serial# 에 의해 제어됩니다. 이 파일은 직렬 장치의 기본 설정에 영향을 줍니다. 장치의 설정을 변경하려면 `stty` 를 사용합니다. 기본적으로 변경된 설정은 장치를 닫을 때까지 적용되며 장치를 다시 열면 기본 설정으로 돌아갑니다. 기본 설정을 영구적으로 변경하려면 초기화 장치의 설정을 열고 조정합니다. 예를 들어, [.filename]#ttyu5# 에 대해 `CLOCAL` 모드, 8비트 통신 및 `XON/XOFF` 흐름 제어를 켜려면 다음과 같이 입력합니다:

[source, shell]
....
# stty -f /dev/ttyu5.init clocal cs8 ixon ixoff
....

애플리케이션에서 특정 설정을 변경하지 못하도록 하려면 잠금 장치를 조정하세요. 예를 들어 [.filename]#ttyu5# 의 속도를 57600bps로 잠그려면 다음과 같이 입력합니다:

[source, shell]
....
# stty -f /dev/ttyu5.lock 57600
....

이제 [.filename]#ttyu5# 를 열고 포트 속도를 변경하려고 시도하는 모든 애플리케이션은 57600bps로 고정됩니다.

[[term]]
== 터미널

터미널은 컴퓨터 콘솔이나 연결된 네트워크에 있지 않을 때 편리하고 저렴한 비용으로 FreeBSD 시스템에 액세스할 수 있는 방법을 제공합니다. 이 섹션에서는 FreeBSD에서 터미널을 사용하는 방법을 설명합니다.

최초의 UNIX(R) 시스템에는 콘솔이 없었습니다. 대신 사용자는 컴퓨터의 직렬 포트에 연결된 터미널을 통해 로그인하고 프로그램을 실행했습니다.

직렬 포트에서 로그인 세션을 설정하는 기능은 FreeBSD를 포함한 오늘날 거의 모든 UNIX(R) 계열 운영체제에 여전히 존재합니다. 사용자는 사용하지 않는 직렬 포트에 연결된 터미널을 사용하여 로그인하고 콘솔 또는 `xterm` 창에서 일반적으로 실행할 수 있는 모든 텍스트 프로그램을 실행할 수 있습니다.

많은 터미널을 FreeBSD 시스템에 연결할 수 있습니다. 구형 예비 컴퓨터를 FreeBSD를 실행하는 더 강력한 컴퓨터에 연결하여 터미널로 사용할 수 있습니다. 이렇게 하면 단일 사용자 컴퓨터가 강력한 다중 사용자 시스템으로 바뀔 수 있습니다.

FreeBSD는 세 가지 유형의 터미널을 지원합니다:

Dumb 터미널::
Dumb 터미널은 직렬 회선을 통해 컴퓨터에 연결되는 특수 하드웨어입니다. 이 단말기는 문자를 표시하고, 보내고, 받을 수 있을 정도의 연산 능력만 가지고 있기 때문에 "dumb"이라고 불립니다. 이러한 장치에서는 어떤 프로그램도 실행할 수 없습니다. 대신, Dumb 터미널은 필요한 프로그램을 실행하는 컴퓨터에 연결합니다.
+
많은 제조업체에서 만든 수백 가지 종류의 dumb 터미널이 있으며, 거의 모든 종류의 터미널이 FreeBSD와 함께 작동합니다. 일부 고급 터미널은 그래픽을 표시할 수도 있지만, 특정 소프트웨어 패키지에서만 이러한 고급 기능을 활용할 수 있습니다.
+
Dumb 터미널은 작업자가 그래픽 애플리케이션에 액세스할 필요가 없는 업무 환경에서 널리 사용됩니다.

터미널 역할을 하는 컴퓨터::
덤 터미널은 문자를 표시하고, 보내고, 받을 수 있는 정도의 기능만 있기 때문에 여분의 컴퓨터는 모두 덤 터미널로 사용할 수 있습니다. 적절한 케이블과 컴퓨터에서 실행할 수 있는 _터미널 에뮬레이션_ 소프트웨어만 있으면 됩니다.
+
이 구성은 유용할 수 있습니다. 예를 들어, 한 사용자가 FreeBSD 시스템의 콘솔에서 작업하느라 바쁘다면 다른 사용자는 FreeBSD 시스템에 터미널로 연결된 성능이 낮은 개인용 컴퓨터에서 텍스트 전용 작업을 동시에 수행할 수 있습니다.
+
FreeBSD의 기본 시스템에는 직렬 연결을 통해 작업하는 데 사용할 수 있는 유틸리티가 최소 두 개 있습니다: man:cu[1] 및 man:tip[1].
+
예를 들어, FreeBSD를 실행하는 클라이언트 시스템에서 다른 시스템의 직렬 연결에 연결할 수 있습니다:
+
[source, shell]
....
# cu -l /dev/cuauN
....
+
포트는 0부터 번호가 매겨집니다. 즉, [.filename]#COM1# 은 [.filename]#/dev/cuau0# 입니다.
+
package:comms/minicom[] 등의 포트 컬렉션을 통해 추가 프로그램을 사용할 수 있습니다.

X 터미널::
X 터미널은 가장 정교한 종류의 터미널입니다. 직렬 포트에 연결하는 대신 일반적으로 이더넷과 같은 네트워크에 연결합니다. 텍스트 전용 애플리케이션으로 제한되는 대신 모든 Xorg 애플리케이션을 표시할 수 있습니다.
+
이 장에서는 X 터미널의 설정, 구성 또는 사용에 대해서는 다루지 않습니다.

[[term-config]]
=== 터미널 구성

이 섹션에서는 직렬 터미널에서 로그인 세션을 활성화하도록 FreeBSD 시스템을 구성하는 방법을 설명합니다. 여기서는 시스템이 터미널에 연결된 직렬 포트를 인식하고 터미널이 올바른 케이블로 연결되어 있다고 가정합니다.

FreeBSD에서 `init` 은 [.filename]#/etc/ttys# 를 읽고 사용 가능한 터미널에서 `getty` 프로세스를 시작합니다. `getty` 프로세스는 로그인 이름을 읽고 `login` 프로그램을 시작합니다. 로그인을 허용하는 FreeBSD 시스템의 포트는 [.filename]#/etc/ttys# 에 나열되어 있습니다. 예를 들어, 첫 번째 가상 콘솔인 [.filename]#ttyv0# 은 이 파일에 콘솔 로그인을 허용하는 항목이 있습니다. 이 파일에는 다른 가상 콘솔, 직렬 포트 및 pseudo-ttys에 대한 항목도 포함되어 있습니다. 유선 터미널의 경우 직렬 포트의 [.filename]#/dev# 항목이 `/dev` 부분 없이 나열됩니다. 예를 들어, [.filename]#/dev/ttyv0# 은 `ttyv0` 으로 표시됩니다.

기본 [.filename]#/etc/ttys# 는 처음 4개의 직렬 포트인 [.filename]#ttyu0# 부터 [.filename]#ttyu3# 에 대한 지원을 구성합니다:

[.programlisting]
....
ttyu0   "/usr/libexec/getty std.9600"   dialup  off secure
ttyu1   "/usr/libexec/getty std.9600"   dialup  off secure
ttyu2   "/usr/libexec/getty std.9600"   dialup  off secure
ttyu3   "/usr/libexec/getty std.9600"   dialup  off secure
....

해당 포트 중 하나에 단말기를 연결할 때 기본 항목을 수정하여 필요한 속도와 단말기 유형을 설정하고, 장치를 `on` 으로 설정하고, 필요한 경우 포트의 `secure` 설정을 변경합니다. 단말기가 다른 포트에 연결되어 있는 경우 해당 포트에 대한 항목을 추가합니다.

<<ex-etc-ttys>> 는 [.filename]#/etc/ttys# 에 두 개의 터미널을 구성합니다. 첫 번째 항목은 [.filename]#COM2# 에 연결된 Wyse-50을 구성합니다. 두 번째 항목은 VT-100 터미널을 에뮬레이트하는 Procomm 터미널 소프트웨어를 실행하는 이전 컴퓨터를 구성합니다. 이 컴퓨터는 멀티 포트 직렬 카드의 여섯 번째 직렬 포트에 연결됩니다.

[example]
[[ex-etc-ttys]]
.터미널 항목 구성하기
====

[.programlisting]
....
ttyu1  "/usr/libexec/getty std.38400"  wy50   on insecure 
ttyu5   "/usr/libexec/getty std.19200"  vt100  on insecure
....

첫 번째 필드는 직렬 터미널의 장치 이름을 지정합니다.

두 번째 필드는 `getty` 에게 회선을 초기화 및 개방하고, 회선 속도를 설정하고, 사용자 이름을 입력한 다음 `login` 프로그램을 실행하도록 지시합니다. 선택 사항인 _getty type_ 은 bps rate 및 패리티와 같은 터미널 회선의 특성을 구성합니다. 사용 가능한 getty 유형은 [.filename]#/etc/gettytab# 에 나열되어 있습니다. 대부분의 경우 `std` 로 시작하는 getty 유형은 패리티를 무시하므로 하드와이어드 터미널에서 작동합니다. 110에서 115200까지의 각 비트 전송률에 대해 `std` 항목이 있습니다. 자세한 내용은 man:gettytab[5] 을 참조하세요. getty 유형을 설정할 때는 단말기에서 사용하는 통신 설정과 일치해야 합니다. 이 예제에서 Wyse-50은 패리티를 사용하지 않고 38400bps로 연결합니다. 컴퓨터는 패리티를 사용하지 않고 19200bps로 연결합니다.

세 번째 필드는 터미널 유형입니다. 전화 접속 포트의 경우 사용자가 거의 모든 유형의 터미널이나 소프트웨어로 전화 접속할 수 있으므로 일반적으로 `unknown` 또는 `dialup` 이 사용됩니다. 유선 터미널의 경우 터미널 유형이 변경되지 않으므로 [.filename]#/etc/termcap# 의 실제 터미널 유형을 지정할 수 있습니다. 이 예제에서는 Wyse-50이 실제 터미널 유형을 사용하는 반면 Procomm을 실행하는 컴퓨터는 VT-100을 에뮬레이트하도록 설정되어 있습니다.

네 번째 필드는 포트를 활성화할지 여부를 지정합니다. 이 포트에서 로그인을 활성화하려면 이 필드를 `on`으로 설정해야 합니다.

마지막 필드는 포트의 보안 여부를 지정하는 데 사용됩니다. 포트를 `secure` 로 표시하면 해당 포트에서 `root` 로그인을 허용할 수 있을 만큼 신뢰할 수 있음을 의미합니다. 안전하지 않은 포트는 `root` 로그인을 허용하지 않습니다. 안전하지 않은 포트에서 사용자는 권한이 없는 계정으로 로그인한 다음 `su` 또는 이와 유사한 메커니즘을 사용하여 수퍼유저 권한을 얻어야 합니다( crossref:basics[users-superuser,“The Superuser Account”] 에 설명된 대로). 보안상의 이유로 이 설정을 `insecure`으로 변경하는 것이 좋습니다.
====

[.filename]#/etc/ttys# 을 변경한 후 `init` 프로세스에 SIGHUP (hangup) 신호를 보내 구성 파일을 강제로 다시 읽도록 합니다:

[source, shell]
....
# kill -HUP 1
....

`init` 는 항상 시스템에서 실행되는 첫 번째 프로세스이므로 항상 프로세스 ID가 `1` 입니다.

모든 것이 올바르게 설정되고 모든 케이블이 제자리에 있으며 터미널의 전원이 켜졌다면 이제 각 터미널에서 `getty` 프로세스가 실행되고 각 터미널에서 로그인 프롬프트를 사용할 수 있어야 합니다.

[[term-debug]]
=== 연결 문제 해결

아무리 세심한 주의를 기울여도 터미널을 설정하는 동안 문제가 발생할 수 있습니다. 다음은 일반적인 증상 목록과 몇 가지 제안된 해결 방법입니다.

로그인 프롬프트가 나타나지 않으면 단말기가 연결되어 있고 전원이 켜져 있는지 확인하세요. 단말기 역할을 하는 개인용 컴퓨터인 경우 올바른 직렬 포트에서 단말기 에뮬레이션 소프트웨어가 실행되고 있는지 확인합니다.

케이블이 터미널과 FreeBSD 컴퓨터 모두에 단단히 연결되어 있는지 확인합니다. 올바른 종류의 케이블인지 확인합니다.

단말기와 FreeBSD의 전송 속도와 패리티 설정이 일치하는지 확인합니다. 비디오 디스플레이 단말기의 경우 contrast 및 brightness 컨트롤이 켜져 있는지 확인합니다. 인쇄 단말기인 경우 용지와 잉크가 충분히 공급되는지 확인하세요.

`ps` 를 사용하여 `getty` 프로세스가 실행 중이고 터미널에 서비스를 제공하고 있는지 확인합니다. 예를 들어, 다음 목록은 두 번째 직렬 포트인 [.filename]#ttyu1# 에서 `getty` 가 실행 중이며 [.filename]#/etc/gettytab# 의 `std.38400` 항목을 사용하고 있음을 보여 줍니다:

[source, shell]
....
# ps -axww|grep ttyu
22189  d1  Is+    0:00.03 /usr/libexec/getty std.38400 ttyu1
....

`getty` 프로세스가 실행 중이 아니라면, [.filename]#/etc/ttys# 에서 포트가 활성화되어 있는지 확인하세요. [.filename]#/etc/ttys# 를 수정한 후 `kill -HUP 1` 을 실행하는 것을 잊지 마세요.

`getty` 프로세스가 실행 중이지만 터미널에 여전히 로그인 프롬프트가 표시되지 않거나 프롬프트가 표시되지만 입력된 입력을 허용하지 않는 경우 터미널 또는 케이블이 하드웨어 핸드셰이킹을 지원하지 않는 것일 수 있습니다. [.filename]#/etc/ttys# 의 항목을 `std.38400` 에서 `3wire.38400` 으로 변경한 다음, `kill -HUP 1` 을 실행한 후 [.filename]#/etc/ttys# 를 수정해 보세요. `3wire` 항목은 `std` 와 유사하지만 하드웨어 핸드셰이킹을 무시합니다. 버퍼 오버플로우를 방지하기 위해 `3wire` 를 사용할 때 bps를 줄이거나 소프트웨어 흐름 제어를 활성화해야 할 수도 있습니다.

로그인 프롬프트 대신 가비지가 나타나면, 터미널과 FreeBSD가 전송 속도와 패리티 설정에 동의하는지 확인하세요. `getty` 프로세스를 확인하여 올바른 _getty_ 유형이 사용 중인지 확인합니다. 그렇지 않은 경우, [.filename]#/etc/ttys# 를 수정하고 `kill -HUP 1` 을 실행하세요.

문자가 이중으로 표시되고 비밀번호를 입력할 때 비밀번호가 표시되면 단말기 또는 단말기 에뮬레이션 소프트웨어를 "half duplex" 또는 "local echo"에서 "full duplex"로 전환하세요.

[[dialup]]
== Dial-in 서비스

전화 접속 서비스를 위해 FreeBSD 시스템을 구성하는 것은 터미널 장치 대신 모뎀을 사용한다는 점을 제외하면 터미널을 구성하는 것과 비슷합니다. FreeBSD는 외부 및 내부 모뎀을 모두 지원합니다.

외부 모뎀은 비휘발성 RAM에 저장된 매개변수를 통해 구성할 수 있는 경우가 많고 모뎀이 제대로 작동하는지 여부를 나타내는 중요한 RS-232 신호의 상태를 표시하는 불빛이 들어오는 표시기를 제공하는 경우가 많으므로 더 편리합니다.

내부 모뎀에는 일반적으로 비휘발성 RAM이 없으므로 구성이 DIP 스위치 설정으로 제한될 수 있습니다. 내부 모뎀에 신호 표시등이 있는 경우 시스템 덮개를 덮은 상태에서는 표시등을 확인하기가 어렵습니다.

외부 모뎀을 사용할 때는 적절한 케이블이 필요합니다. 표준 RS-232C 직렬 케이블이면 충분합니다.

FreeBSD는 2400bps 이상의 속도에서 흐름 제어를 위한 RTS 및 CTS 신호, 전화를 받았는지 또는 회선이 끊겼는지 감지하기 위한 CD 신호, 세션이 완료된 후 모뎀을 리셋하기 위한 DTR 신호가 필요합니다. 일부 케이블은 필요한 모든 신호 없이 배선되어 있어 전화가 끊겼을 때 로그인 세션이 사라지지 않으면 케이블에 문제가 있을 수 있습니다. 이러한 신호에 대한 자세한 내용은 <<term-cables-null>> 을 참조하세요.

다른 UNIX(R) 계열 운영체제와 마찬가지로 FreeBSD는 하드웨어 신호를 사용하여 전화를 받았는지 또는 회선이 끊겼는지 확인하고, 통화 후 모뎀을 끊고 재설정합니다. FreeBSD는 모뎀에 명령을 보내거나 모뎀의 상태 보고를 감시하지 않습니다.

FreeBSD는 NS8250, NS16450, NS16550 및 NS16550A 기반 RS-232C(CCITT V.24) 통신 인터페이스를 지원합니다. 8250 및 16450 장치에는 단일 문자 버퍼가 있습니다. 16550 디바이스는 16자 버퍼를 제공하여 시스템 성능을 개선할 수 있습니다. 일반 16550 디바이스의 버그로 인해 16자 버퍼를 사용할 수 없으므로 가능하면 16550A 디바이스를 사용하십시오. 단일 문자 버퍼 디바이스는 16 문자 버퍼 디바이스보다 운영 체제에서 더 많은 작업이 필요하므로 16550A 기반 직렬 인터페이스 카드가 선호됩니다. 시스템에 활성 직렬 포트가 많거나 부하가 많은 경우 16550A 기반 카드가 오류율이 낮은 통신에 더 적합합니다.

이 섹션의 나머지 부분에서는 들어오는 연결을 수신하도록 모뎀을 구성하는 방법, 모뎀과 통신하는 방법 및 몇 가지 문제 해결 팁을 설명합니다.

[[dialup-ttys]]
=== 모뎀 구성

터미널과 마찬가지로 `init` 은 전화 접속 연결에 사용되는 구성된 각 직렬 포트에 대해 `getty` 프로세스를 생성합니다. 사용자가 모뎀의 회선에 전화를 걸고 모뎀이 연결되면 모뎀에서 "Carrier Detect" 신호가 보고됩니다. 커널은 캐리어가 감지되었음을 알아차리고 `getty` 에게 포트를 열고 지정된 초기 회선 속도로 `login:` 프롬프트를 표시하도록 지시합니다. 일반적인 구성에서 모뎀의 연결 속도가 설정된 속도와 달라서 garbage 문자가 수신되면 `getty` 는 적절한 문자를 수신할 때까지 회선 속도를 조정하려고 시도합니다. 사용자가 로그인 이름을 입력하면 `getty` 는 `login` 을 실행하여 사용자의 비밀번호를 묻고 사용자 셸을 시작하여 로그인 프로세스를 완료합니다.

전화 접속 모뎀과 관련하여 두 가지 계열이 있습니다. 한 가지 구성 방법은 원격 사용자가 어떤 속도로 전화를 걸든 전화 접속 RS-232 인터페이스가 고정된 속도로 실행되도록 모뎀과 시스템을 설정하는 것입니다. 이 구성의 장점은 원격 사용자에게 항상 시스템 로그인 프롬프트가 즉시 표시된다는 것입니다. 단점은 시스템이 사용자의 실제 데이터 속도를 알지 못하기 때문에 Emac과 같은 전체 화면 프로그램은 느린 연결에 대한 응답을 개선하기 위해 화면 그리기 방법을 조정하지 않는다는 것입니다.

두 번째 방법은 원격 사용자의 연결 속도에 따라 속도가 달라지도록 RS-232 인터페이스를 구성하는 것입니다. `getty` 는 특정 모뎀의 연결 속도 보고를 이해하지 못하므로 초기 속도에서 `login:` 메시지를 보내고 응답으로 돌아오는 문자를 관찰합니다. 정크가 표시되면 사용자가 인식할 수 있는 프롬프트가 표시될 때까지 kbd:[Enter]를 눌러야 합니다. 데이터 속도가 일치하지 않으면 `getty` 는 사용자가 입력하는 모든 문자를 정크로 간주하고 다음 속도를 시도한 `login:` 프롬프트를 다시 표시합니다. 이 절차는 일반적으로 사용자가 정상 프롬프트를 보기까지 한두 번의 키 입력만 필요합니다. 이 로그인 시퀀스는 속도 고정 방식만큼 깔끔해 보이지는 않지만, 저속 연결 상태의 사용자는 전체 화면 프로그램에서 더 나은 대화형 응답을 받을 수 있습니다.

모뎀의 데이터 통신 속도를 특정 속도로 고정할 때는 [.filename]#/etc/gettytab# 을 변경할 필요가 없습니다. 그러나 일치하는 속도 구성의 경우 모뎀에 사용할 속도를 정의하기 위해 추가 항목이 필요할 수 있습니다. 이 예에서는 8비트, 패리티 없는 연결을 사용하여 최고 인터페이스 속도가 19.2Kbps인 14.4Kbps 모뎀을 구성합니다. 이 예제에서는 V.32bis 연결의 통신 속도를 19.2Kbps로 시작한 다음 9600bps, 2400bps, 1200bps, 300bps를 거쳐 다시 19.2Kbps로 순환하도록 `getty` 를 구성합니다. 통신 속도 사이클링은 `nx=` (다음 표) 기능으로 구현됩니다. 각 줄은 `tc=` (표 계속) 항목을 사용하여 특정 데이터 속도에 대한 나머지 설정을 선택합니다.

[.programlisting]
....
#
# Additions for a V.32bis Modem
#
um|V300|High Speed Modem at 300,8-bit:\
        :nx=V19200:tc=std.300:
un|V1200|High Speed Modem at 1200,8-bit:\
        :nx=V300:tc=std.1200:
uo|V2400|High Speed Modem at 2400,8-bit:\
        :nx=V1200:tc=std.2400:
up|V9600|High Speed Modem at 9600,8-bit:\
        :nx=V2400:tc=std.9600:
uq|V19200|High Speed Modem at 19200,8-bit:\
        :nx=V9600:tc=std.19200:
....

28.8Kbps 모뎀을 사용하거나 14.4Kbps 모뎀에서 압축을 활용하려면 이 예에서 보는 것처럼 더 높은 통신 속도를 사용하십시오:

[.programlisting]
....
#
# Additions for a V.32bis or V.34 Modem
# Starting at 57.6 Kbps
#
vm|VH300|Very High Speed Modem at 300,8-bit:\
        :nx=VH57600:tc=std.300:
vn|VH1200|Very High Speed Modem at 1200,8-bit:\
        :nx=VH300:tc=std.1200:
vo|VH2400|Very High Speed Modem at 2400,8-bit:\
        :nx=VH1200:tc=std.2400:
vp|VH9600|Very High Speed Modem at 9600,8-bit:\
        :nx=VH2400:tc=std.9600:
vq|VH57600|Very High Speed Modem at 57600,8-bit:\
        :nx=VH9600:tc=std.57600:
....

느린 CPU 또는 16550A 기반 직렬 포트가 없는 과부하 시스템의 경우, 이 구성은 57.6Kbps에서 `uart` "silo" 오류가 발생할 수 있습니다.

[.filename]#/etc/ttys# 의 구성은 <<ex-etc-ttys>> 와 유사하지만, `getty` 에 다른 인수가 전달되고 터미널 유형에 `dialup` 이 사용됩니다. _xxx_ 를 `init` 프로세스가 장치에서 실행되는 프로세스로 바꿉니다:

[.programlisting]
....
ttyu0   "/usr/libexec/getty xxx"   dialup on
....

`dialup` 터미널 유형을 변경할 수 있습니다. 예를 들어 `vt102` 를 기본 터미널 유형으로 설정하면 사용자가 원격 시스템에서 VT102 에뮬레이션을 사용할 수 있습니다.

고정속도 구성의 경우 [.filename]#/etc/gettytab# 에 나열된 유효한 유형으로 속도를 지정합니다. 이 예는 포트 속도가 19.2Kbps로 고정된 모뎀에 대한 것입니다:

[.programlisting]
....
ttyu0   "/usr/libexec/getty std.19200"   dialup on
....

일치 속도 구성에서, 항목은 [.filename]#/etc/gettytab# 에서 적절한 시작을 위해 "auto-baud" 항목을 참조해야 합니다. 19.2Kbps에서 시작하는 매칭 속도 모뎀에 대한 예제를 계속하려면 이 항목을 사용합니다:

[.programlisting]
....
ttyu0   "/usr/libexec/getty V19200"   dialup on
....

[.filename]#/etc/ttys# 을 편집한 후 모뎀이 제대로 구성되고 연결될 때까지 기다렸다가 `init` 신호를 보냅니다:

[source, shell]
....
# kill -HUP 1
....

V.32, V.32bis 및 V.34 모뎀과 같은 고속 모뎀은 하드웨어( `RTS/CTS` ) 흐름 제어를 사용합니다. `stty` 를 사용하여 모뎀 포트에 대한 하드웨어 흐름 제어 플래그를 설정합니다. 이 예에서는 [.filename]#COM2# 의 전화 접속 및 전화 걸기 초기화 장치에 `crtscts` 플래그를 설정합니다:

[source, shell]
....
# stty -f /dev/ttyu1.init crtscts
# stty -f /dev/cuau1.init crtscts
....

=== 문제 해결

이 섹션에서는 FreeBSD 시스템에 연결되지 않는 전화 접속 모뎀의 문제를 해결하기 위한 몇 가지 팁을 제공합니다.

모뎀을 FreeBSD 시스템에 연결하고 시스템을 부팅합니다. 모뎀에 상태 표시등이 있는 경우, 시스템 콘솔에 `login:` 프롬프트가 나타날 때 모뎀의 DTR 표시등이 켜지는지 확인합니다. 불이 켜지면, 이는 FreeBSD가 적절한 통신 포트에서 `getty` 프로세스를 시작하고 모뎀이 호출을 수락하기를 기다리고 있다는 것을 의미합니다.

DTR 표시등이 켜지지 않으면 콘솔을 통해 FreeBSD 시스템에 로그인하고 `ps ax` 를 입력하여 FreeBSD가 올바른 포트에서 `getty` 프로세스를 실행 중인지 확인합니다:

[source, shell]
....
  114 ??  I      0:00.10 /usr/libexec/getty V19200 ttyu0
....

두 번째 열에 `??` 대신 `d0` 가 포함되어 있고 모뎀이 아직 호출을 수락하지 않은 경우, 이는 `getty` 가 통신 포트에서 개방을 완료했음을 의미합니다. 이는 케이블에 문제가 있거나 모뎀이 잘못 구성되었음을 나타낼 수 있는데, 모뎀에서 통신사 감지 신호가 확인될 때까지 `getty` 가 통신 포트를 열 수 없어야 하기 때문입니다.

포트 열기를 기다리는 `getty` 프로세스가 없는 경우, 포트에 대한 항목이 [.filename]#/etc/ttys# 에 올바른지 다시 확인합니다. 또한 [.filename]#/var/log/messages# 에서 `init` 또는 `getty` 의 로그 메시지가 있는지 확인합니다.

다음으로 시스템에 전화를 걸어봅니다. 원격 시스템에서는 8비트, 패리티 없음, 스톱 비트 1개를 사용해야 합니다. 프롬프트가 바로 나타나지 않거나 프롬프트에 garbage가 표시되면 kbd:[Enter]를 초당 한 번 정도 눌러 보세요. 그래도 `login:` 프롬프트가 나타나지 않으면 `BREAK` 를 전송해 보세요. 고속 모뎀을 사용하는 경우, 다이얼링 모뎀의 인터페이스 속도를 잠근 후 다시 다이얼을 시도해 보세요.

그래도 `login:` 프롬프트가 표시되지 않으면 [.filename]#/etc/gettytab# 을 다시 확인하고 다시 확인하세요:

* [.filename]#/etc/ttys# 의 항목에 지정된 초기 기능 이름은 [.filename]#/etc/gettytab# 의 기능 이름과 일치합니다.
* 각 `nx=` 항목은 다른 [.filename]#gettytab# 기능 이름과 일치합니다.
* 각 `tc=` 항목은 다른 [.filename]#gettytab# 기능 이름과 일치합니다.

FreeBSD 시스템의 모뎀이 응답하지 않는 경우, 모뎀이 DTR이 설정되었을 때 전화에 응답하도록 구성되어 있는지 확인하세요. 모뎀이 올바르게 구성된 것 같으면 모뎀의 표시등을 확인하여 DTR 회선이 assert 되었는지 확인하세요.

그래도 작동하지 않으면 모뎀과 문제를 설명하는 이메일을 {freebsd-questions}로 보내 보세요.

[[dialout]]
== Dial-out 서비스

다음은 호스트가 모뎀을 통해 다른 컴퓨터에 연결하도록 하기 위한 팁입니다. 이 방법은 원격 호스트와 터미널 세션을 설정하는 데 적합합니다.

이러한 종류의 연결은 PPP를 사용하는 데 문제가 있는 경우 인터넷에서 파일을 가져오는 데 도움이 될 수 있습니다. PPP가 작동하지 않는 경우 터미널 세션을 사용하여 필요한 파일을 FTP로 전송하세요. 그런 다음 zmodem을 사용하여 컴퓨터로 전송합니다.

[[hayes-unsupported]]
=== Stock Hayes 모뎀 사용하기

일반적인 Hayes 다이얼러는 `tip` 에 내장되어 있습니다. [.filename]#/etc/remote# 에 `at=hayes` 를 사용하세요.

Hayes 드라이버는 `BUSY`, `NO DIALTONE` 또는 `CONNECT 115200` 과 같은 최신 모뎀 메시지의 일부 고급 기능을 인식할 만큼 똑똑하지 않습니다. `tip` 을 `ATX0&W` 와 함께 사용할 때는 이러한 메시지를 끄십시오.

`tip` 의 다이얼 타임아웃은 60초입니다. 모뎀은 더 짧은 시간을 사용해야 하며, 그렇지 않으면 `tip` 은 통신에 문제가 있다고 판단합니다. `ATS7=45&W` 를 사용해 보세요.

[[direct-at]]
=== `AT` 명령 사용하기

[.filename]#/etc/remote# 에 "direct" 항목을 만듭니다. 예를 들어 모뎀이 첫 번째 직렬 포트인 [.filename]#/dev/cuau0# 에 연결되어 있는 경우 다음 줄을 사용합니다:

[.programlisting]
....
cuau0:dv=/dev/cuau0:br#19200:pa=none
....

`br` 기능에서 모뎀이 지원하는 가장 높은 bps 속도를 사용합니다. 그런 다음 `tip cuau0` 을 입력하여 모뎀에 연결합니다.

또는 다음 명령과 함께 `root` 로 `cu` 를 사용합니다:

[source, shell]
....
# cu -lline -sspeed
....

_line_ 은 직렬 포트(예: [.filename]#/dev/cuau0# )이고, _speed_ 는 속도(예: `57600` )입니다. AT 명령 입력을 마쳤으면 `~.` 를 입력하여 종료합니다.

[[gt-failure]]
=== `@` 기호를 사용할 수 없음

전화 번호 기능의 `@` 기호는 `tip` 에게 [.filename]#/etc/phones# 에서 전화 번호를 찾으라고 지시합니다. 그러나 `@` 기호는 [.filename]#/etc/remote# 와 같은 기능 파일에서도 특수 문자이므로 백슬래시로 이스케이프 처리해야 합니다:

[.programlisting]
....
pn=\@
....

[[dial-command-line]]
=== 명령줄에서 전화 걸기

[.filename]#/etc/remote# 에 "generic" 항목을 입력합니다. 예를 들어:

[.programlisting]
....
tip115200|Dial any phone number at 115200 bps:\
        :dv=/dev/cuau0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600 bps:\
        :dv=/dev/cuau0:br#57600:at=hayes:pa=none:du:
....

이제 작동합니다:

[source, shell]
....
# tip -115200 5551234
....

`tip` 보다 `cu` 를 선호하는 사용자는 generic `cu` 항목을 사용할 수 있습니다:

[.programlisting]
....
cu115200|Use cu to dial any number at 115200bps:\
        :dv=/dev/cuau1:br#57600:at=hayes:pa=none:du:
....

그리고 입력합니다:

[source, shell]
....
# cu 5551234 -s 115200
....

[[set-bps]]
=== bps 속도 설정하기

`tip1200` 또는 `cu1200` 항목을 입력하되, `br` 기능을 사용하여 적절한 비트 전송률을 사용하십시오. `tip` 은 기본값이 1200bps라고 생각하므로 `tip1200` 항목을 찾습니다. 하지만 반드시 1200bps를 사용할 필요는 없습니다.

[[terminal-server]]
=== 터미널 서버를 통해 여러 호스트에 액세스하기

연결될 때까지 기다렸다가 매번 `CONNECT 호스트` 를 입력하는 대신 ``tip`` 의 `cm` 기능을 사용하세요. 예를 들어, [.filename]#/etc/remote# 에 이러한 항목을 입력하면 `tip pain` 또는 `tip muffin` 을 입력하여 호스트 `pain` 또는 `muffin` 에 연결할 수 있고 `tip deep13` 을 입력하여 터미널 서버에 연결할 수 있습니다.

[.programlisting]
....
pain|pain.deep13.com|Forrester's machine:\
        :cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank's machine:\
        :cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
        :dv=/dev/cuau2:br#38400:at=hayes:du:pa=none:pn=5551234:
....

[[tip-multiline]]
=== `tip` 으로 한 회선 이상 사용하기

한 대학에 모뎀 회선이 여러 개 있고 수천 명의 학생이 모뎀을 사용하려는 경우 이 문제가 자주 발생합니다.

[.filename]#/etc/remote#에 항목을 만든 후 `@` 를 `pn` 기능에 사용합니다:

[.programlisting]
....
big-university:\
        :pn=\@:tc=dialout
dialout:\
        :dv=/dev/cuau3:br#9600:at=courier:du:pa=none:
....

그런 다음 [.filename]#/etc/phones# 에 전화번호를 나열합니다:

[.programlisting]
....
big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114
....

`tip` 은 나열된 순서대로 각 번호를 시도한 다음 포기합니다. 계속 재시도하려면 `tip` 을 `while` 루프에서 실행합니다.

[[multi-controlp]]
=== Force Character 사용하기

kbd:[Ctrl+P]는 기본 "force" 문자로, 다음 문자가 리터럴 데이터임을 `tip` 에게 알리는 데 사용됩니다. force 문자는 `~s` 이스케이프를 사용하여 "set a variable"을 의미하는 다른 문자로 설정할 수 있습니다.

새 줄에 `~sforce=_single-char_` 를 입력합니다. _single-char_ 는 임의의 단일 문자입니다. _single-char_ 를 생략하면 강제 문자는 널 문자이며, 이 문자는 kbd:[Ctrl+2] 또는 kbd:[Ctrl+Space]를 입력하여 액세스할 수 있습니다. _single-char_ 에 가장 적합한 값은 일부 터미널 서버에서만 사용되는 kbd:[Shift+Ctrl+6]입니다.

강제 문자를 변경하려면 [.filename]#~/.tiprc# 에 다음을 지정합니다:

[.programlisting]
....
force=single-char
....

[[uppercase]]
=== 대문자 글자

이것은 kbd:[Ctrl+A]을 눌렀을 때 작동하며 ``tip`` 의 "raise character" 기능으며, caps-lock가 고장난 사용자를 위해 특별히 고안되었습니다. `~s` 를 사용하여 `raisechar` 를 적당한 값으로 설정합니다. 두 기능을 모두 사용하지 않는 경우 강제 문자와 동일하게 설정할 수 있습니다.

다음은 kbd:[Ctrl+2] 및 kbd:[Ctrl+A]를 입력해야 하는 Emacs 사용자를 위한 샘플 [.filename]#~/.tiprc# 입니다:

[.programlisting]
....
force=^^
raisechar=^^
....

`^^` 은 kbd:[Shift+Ctrl+6]입니다.

[[tip-filetransfer]]
=== `tip` 으로 파일 전송

다른 UNIX(R) 계열 운영체제와 대화할 때 `~p` (put)와 `~t` (take)를 사용하여 파일을 주고받을 수 있습니다. 이 명령은 원격 시스템에서 `cat` 과 `echo` 를 실행하여 파일을 수락하고 전송합니다. 구문은 다음과 같습니다: `~p` 로컬-파일 [ 원격-파일 ] `~t` 원격-파일 [ 로컬-파일 ]

오류 확인 기능이 없으므로 zmodem과 같은 다른 프로토콜을 사용해야 할 수도 있습니다.

[[zmodem-tip]]
=== `tip` 과 함께 zmodem을 사용하기?

파일을 받으려면 원격 쪽에서 전송 프로그램을 시작합니다. 그런 다음 `~C rz` 를 입력하여 로컬로 수신을 시작합니다.

파일을 보내려면 원격 쪽에서 수신 프로그램을 시작합니다. 그런 다음 `~C sz _files_` 를 입력하여 원격 시스템으로 파일을 보냅니다.

[[serialconsole-setup]]
== 직렬 콘솔 설정하기

FreeBSD는 직렬 포트의 dumb 터미널을 콘솔로 사용하여 시스템을 부팅할 수 있는 기능이 있습니다. 이 구성은 키보드나 모니터가 연결되지 않은 시스템에 FreeBSD를 설치하려는 시스템 관리자와 커널 또는 장치 드라이버를 디버깅하려는 개발자에게 유용합니다.

crossref:boot[boot,The FreeBSD Booting Process]에 설명된 것처럼, FreeBSD는 3단계 부트스트랩을 사용합니다. 처음 두 단계는 부팅 디스크의 FreeBSD 슬라이스 시작 부분에 저장되는 부트 블록 코드에 있습니다. 그런 다음 부트 블록은 세 번째 단계 코드로서 부트 로더를 로드하고 실행합니다.

직렬 콘솔에서 부팅을 설정하려면 부트 블록 코드, 부트 로더 코드 및 커널을 구성해야 합니다.

[[serialconsole-howto-fast]]
=== 빠른 직렬 콘솔 구성

이 섹션에서는 시리얼 콘솔 설정에 대한 간략한 개요를 제공합니다. 이 절차는 dumb 터미널이 [.filename]#COM1# 에 연결되어 있을 때 사용할 수 있습니다.

[.procedure]
.절차: [.filename]#COM1# 에 직렬 콘솔 구성하기
. 직렬 케이블을 [.filename]#COM1# 과 제어 터미널에 연결합니다.
. 직렬 콘솔에 표시되도록 부팅 메시지를 구성하려면 수퍼유저로 다음 명령을 실행합니다:
+
[source, shell]
....
# echo 'console="comconsole"' >> /boot/loader.conf
....

. [.filename]#/etc/ttys# 을 편집하고 [.filename]#ttyu0# 항목의 `off` 를 `on` 으로, `dialup` 을 `vt100` 으로 변경합니다. 그렇지 않으면 직렬 콘솔을 통해 연결할 때 비밀번호가 필요하지 않으므로 잠재적인 보안 허점이 발생할 수 있습니다.
. 시스템을 재부팅하여 변경 사항이 적용되었는지 확인합니다.

다른 구성이 필요한 경우 다음 섹션에서 보다 자세한 구성 설명을 참조하세요.

[[serialconsole-howto]]
=== 심층적인 직렬 콘솔 구성

이 섹션에서는 FreeBSD에서 직렬 콘솔을 설정하는 데 필요한 단계에 대해 자세히 설명합니다.

[.procedure]
.절차: 직렬 콘솔 구성하기
. 직렬 케이블을 준비합니다.
+
널 모뎀 케이블 또는 표준 직렬 케이블과 널 모뎀 어댑터를 사용합니다. 직렬 케이블에 대한 설명은 <<term-cables-null>> 을 참조하세요.
. 키보드를 분리합니다.
+
많은 시스템이 Power-On Self-Test (POST) 중에 키보드를 검색하고 키보드가 감지되지 않으면 오류를 생성합니다. 일부 시스템은 키보드가 연결될 때까지 부팅을 거부합니다.
+
컴퓨터가 오류에 대해 불평하지만 어쨌든 부팅되는 경우 추가 구성이 필요하지 않습니다.
+
키보드가 연결되지 않은 상태에서 컴퓨터가 부팅을 거부하는 경우, 이 오류를 무시하도록 BIOS를 구성하세요. 자세한 방법은 마더보드 설명서를 참조하세요.
+
[TIP]
====
BIOS에서 키보드를 "Not installed"으로 설정해 보세요. 이 설정은 전원을 켤 때 키보드를 검색하지 않도록 BIOS에 지시하므로 키보드가 없어도 문제가 발생하지 않습니다. BIOS에 해당 옵션이 없는 경우 대신 "Halt on Error" 옵션을 찾아보세요. 이 옵션을 "All but Keyboard" 또는 "No Errors"으로 설정해도 동일한 효과를 얻을 수 있습니다.
====
+
시스템에 PS/2(R) 마우스가 있는 경우 마우스도 분리하세요. PS/2(R) 마우스는 키보드와 일부 하드웨어를 공유하므로 마우스를 연결한 채로 두면 키보드 프로브가 키보드가 그대로 있는 것으로 착각할 수 있습니다.
+
[NOTE]
====
대부분의 시스템은 키보드 없이 부팅되지만, 그래픽 어댑터 없이는 부팅되지 않는 시스템도 상당수 있습니다. 일부 시스템은 BIOS 구성에서 "graphics adapter" 설정을 "Not installed"으로 변경하여 그래픽 어댑터 없이 부팅하도록 구성할 수 있습니다. 일부 시스템은 이 옵션을 지원하지 않으며 시스템에 디스플레이 하드웨어가 없는 경우 부팅이 거부됩니다. 이러한 시스템에서는 고물 모노 보드일지라도 어떤 종류의 그래픽 카드를 연결한 상태로 두세요. 모니터를 연결할 필요는 없습니다.
====

. Dumb 터미널, 모뎀 프로그램이 설치된 구형 컴퓨터 또는 다른 UNIX(R) 장치의 직렬 포트를 직렬 포트에 연결합니다.
. 직렬 포트에 대한 적절한 `hint.uart.*` 항목을 [.filename]#/boot/device.hints# 에 추가합니다. 일부 멀티 포트 카드에는 커널 구성 옵션도 필요합니다. 지원되는 각 직렬 포트에 필요한 옵션 및 장치 힌트는 man:uart[4]를 참조하세요.
. 부팅 드라이브의 `a` 파티션 루트 디렉터리에 [.filename]#boot.config# 를 생성합니다.
+
이 파일은 부트 블록 코드에 시스템 부팅 방법을 지시합니다. 직렬 콘솔을 활성화하려면 다음 옵션 중 하나 이상이 필요합니다. 여러 옵션을 사용하는 경우 모두 같은 줄에 포함시키세요:
+
`-h`:::
내부 콘솔과 직렬 콘솔 사이를 전환합니다. 콘솔 장치를 전환할 때 사용합니다. 예를 들어 내부(비디오) 콘솔에서 부팅하려면 `-h` 를 사용하여 부트 로더와 커널이 직렬 포트를 콘솔 장치로 사용하도록 지시합니다. 또는 직렬 포트에서 부팅하려면 `-h` 를 사용하여 부트 로더와 커널에 비디오 디스플레이를 콘솔로 대신 사용하도록 지시합니다.

`-D`:::
단일 콘솔 구성과 이중 콘솔 구성 사이를 전환합니다. 단일 콘솔 구성에서는 `-h` 상태에 따라 콘솔이 내부 콘솔(비디오 디스플레이) 또는 직렬 포트 중 하나가 됩니다. 이중 콘솔 구성에서는 `-h` 상태에 관계없이 비디오 디스플레이와 직렬 포트가 동시에 콘솔이 됩니다. 그러나 이주 콘솔 구성은 부트 블록이 실행되는 동안에만 적용됩니다. 부트 로더가 제어권을 얻으면 `-h` 로 지정된 콘솔이 유일한 콘솔이 됩니다.

`-P`:::
부트 블록이 키보드를 탐색하도록 합니다. 키보드를 찾지 못하면 `-D` 및 `-h` 옵션이 자동으로 설정됩니다.
+
[NOTE]
====
현재 버전 부트 블록의 공간 제약으로 인해 `-P` 는 확장 키보드만 감지할 수 있습니다. 키가 101개 미만이거나 F11 및 F12 키가 없는 키보드는 감지되지 않을 수 있습니다. 일부 노트북의 키보드는 이 제한으로 인해 제대로 검색되지 않을 수 있습니다. 이 경우 `-P` 를 사용하지 마세요.
====
+
콘솔을 자동으로 선택하려면 `-P` 를, 직렬 콘솔을 활성화하려면 `-h` 를 사용합니다. 자세한 내용은 man:boot[8] 및 man:boot.config[5]를 참조하세요.
+
`-P` 를 제외한 옵션은 부트 로더에 전달됩니다. 부트 로더는 `-h` 의 상태를 검사하여 내부 비디오 또는 직렬 포트가 콘솔이 될지 여부를 결정합니다. 즉, `-D` 가 지정되었지만 `-h` 가 [.filename]#/boot.config# 에 지정되지 않은 경우 부트 로더가 내부 비디오 디스플레이를 콘솔로 사용하므로 부트 블록 중에만 직렬 포트를 콘솔로 사용할 수 있습니다.
. 컴퓨터를 부팅합니다.
+
FreeBSD가 시작되면 부트 블록이 [.filename]#/boot.config# 의 내용을 콘솔에 표시합니다. 예를 들어:
+
[source, shell]
....
/boot.config: -P
Keyboard: no
....
+
두 번째 줄은 `-P` 가 [.filename]#/boot.config# 에 있는 경우에만 나타나며 키보드의 유무를 나타냅니다. 이러한 메시지는 [.filename]#/boot.config# 의 옵션에 따라 직렬 또는 내부 콘솔 중 하나 또는 둘 다에 나타납니다:
+
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
<| Options
<| Message goes to

|none
|internal console

|`-h`
|serial console

|`-D`
|serial and internal consoles

|`-Dh`
|serial and internal consoles

|`-P`, keyboard present
|internal console

|`-P`, keyboard absent
|serial console
|===
+
메시지가 표시된 후 부트 블록이 부트 로더를 계속 로드하기 전과 콘솔에 추가 메시지가 인쇄되기 전에 잠시 일시 중지됩니다. 정상적인 상황에서는 부팅 블록을 중단할 필요가 없지만 올바르게 설정되었는지 확인하기 위해 중단할 수 있습니다.
+
부팅 프로세스를 중단하려면 콘솔에서 kbd:[Enter] 이외의 아무 키나 누릅니다. 그러면 부팅 블록이 추가 작업을 요청하는 메시지를 표시합니다:
+
[source, shell]
....
>> FreeBSD/i386 BOOT
Default: 0:ad(0,a)/boot/loader
boot:
....
+
[.filename]#/boot.config# 의 옵션에 따라 위 메시지가 직렬 또는 내부 콘솔 중 하나 또는 둘 다에 표시되는지 확인합니다. 메시지가 올바른 콘솔에 표시되면 kbd:[Enter]를 눌러 부팅 프로세스를 계속 진행합니다.
+
직렬 터미널에 프롬프트가 나타나지 않으면 설정에 문제가 있는 것입니다. `-h` 를 입력한 다음 kbd:[Enter] 또는 kbd:[Return]을 입력하여 부트 블록(그리고 부트 로더와 커널)에 콘솔용 직렬 포트를 선택하도록 지시합니다. 시스템이 부팅되면 돌아가서 무엇이 잘못되었는지 확인합니다.

부팅 프로세스의 세 번째 단계에서도 부트 로더에서 적절한 환경 변수를 설정하여 내부 콘솔과 직렬 콘솔 사이를 전환할 수 있습니다. 자세한 내용은 man:loader[8]를 참조하세요.

[NOTE]
====
[.filename]#/boot/loader.conf# 또는 [.filename]#/boot/loader.conf.local# 의 다음 내용은 [.filename]#/boot.config# 의 옵션과 관계없이 부트 로더와 커널이 부팅 메시지를 직렬 콘솔로 전송하도록 구성합니다:

[.programlisting]
....
console="comconsole"
....

부팅 메시지가 가능한 한 빨리 직렬 콘솔에 표시되도록 이 줄은 [.filename]#/boot/loader.conf# 의 첫 번째 줄에 있어야 합니다.

해당 줄이 존재하지 않거나 `console="vidconsole"` 로 설정된 경우, 부트 로더와 커널은 부트 블록에서 `-h` 로 표시된 콘솔을 사용합니다. 자세한 내용은 man:loader.conf[5]를 참조하십시오.

현재 부트 로더에는 부트 블록에 `-P` 에 해당하는 옵션이 없으며 키보드의 존재 여부에 따라 내부 콘솔과 직렬 콘솔을 자동으로 선택하는 규정이 없습니다.
====

[TIP]
====
필수는 아니지만 직렬 회선을 통해 `login` 프롬프트를 제공할 수 있습니다. 이를 구성하려면 <<term-config>> 의 지침에 따라 [.filename]#/etc/ttys# 에서 직렬 포트에 대한 항목을 편집합니다. 직렬 포트의 속도가 변경된 경우 `std.9600` 을 새 설정과 일치하도록 변경합니다.
====

=== 더 빠른 직렬 포트의 속도 설정하기

기본적으로 직렬 포트 설정은 9600 전송 속도, 8비트, 패리티 없음, 1스톱 비트입니다. 기본 콘솔 속도를 변경하려면 다음 옵션 중 하나를 사용합니다:

* [.filename]#/etc/make.conf# 을 편집하고 `BOOT_COMCONSOLE_SPEED` 를 새 콘솔 속도로 설정합니다. 그런 다음 부트 블록과 부트 로더를 다시 컴파일하고 설치합니다:
+
[source, shell]
....
# cd /sys/boot
# make clean
# make
# make install
....
+
직렬 콘솔이 `-h` 로 부팅하는 방식이 아닌 다른 방식으로 구성되었거나 커널에서 사용하는 직렬 콘솔이 부팅 블록에서 사용하는 것과 다른 경우, 원하는 속도로 다음 옵션을 사용자 정의 커널 구성 파일에 추가하고 새 커널을 컴파일합니다:
+
[.programlisting]
....
options CONSPEED=19200
....

* [.filename]#/boot.config# 에 `-S__19200__` 부팅 옵션을 추가하고 `_19200_` 을 사용할 속도로 바꿉니다.
* 다음 옵션을 [.filename]#/boot/loader.conf# 에 추가합니다. `_115200_` 을 사용할 속도로 바꿉니다.
+
[.programlisting]
....
boot_multicons="YES"
boot_serial="YES"
comconsole_speed="115200"
console="comconsole,vidconsole"
....

[[serialconsole-ddb]]
=== 직렬 회선에서 DDB 디버거에 들어가기

직렬 콘솔에서 커널 디버거로 드롭하는 기능을 구성하려면 커스텀 커널 구성 파일에 다음 옵션을 추가하고 crossref:kernelconfig[kernelconfig,Configuring the FreeBSD Kernel]의 지침에 따라 커널을 컴파일합니다. 이 방법은 원격 진단에 유용하지만 직렬 포트에서 가짜 브레이크가 생성될 경우 위험할 수 있습니다. 커널 디버거에 대한 자세한 내용은 man:ddb[4] 및 man:ddb[8]을 참조하십시오.

[.programlisting]
....
options BREAK_TO_DEBUGGER
options DDB
....
