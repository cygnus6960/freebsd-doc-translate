---
description: '이 장에서는 FreeBSD에서 메일 서버를 실행하는 기본적인 소개와 함께 FreeBSD를 사용하여 이메일을 보내고 받는 방법을 소개합니다'
next: books/handbook/network-servers
part: 'IV. 네트워크 통신'
path: /books/handbook/
prev: books/handbook/ppp-and-slip
showBookMenu: 'true'
tags: ["mail", "sendmail", "MTA", "SMTP", "user agents", "fetchmail", "procmail", "alpine", "mut"]
title: '30장. 전자 메일'
weight: 35
---

[[mail]]
= 전자메일
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 30
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/mail/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[]
include::shared/{{% lang %}}/teams.adoc[]
include::shared/{{% lang %}}/mailing-lists.adoc[]
include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[mail-synopsis]]
== 요약

이메일로 더 잘 알려진 "전자 메일"은 오늘날 가장 널리 사용되는 커뮤니케이션 형태 중 하나입니다. 이 장에서는 FreeBSD에서 메일 서버를 실행하는 기본적인 소개와 함께 FreeBSD를 사용하여 이메일을 보내고 받는 방법을 소개합니다. 이 주제에 대한 보다 자세한 내용은 crossref:bibliography[bibliography,Bibliography] 에 나열된 책을 참조하세요.

이 장을 읽고 나면 다음을 알 수 있습니다:

* 전자 메일 송수신에 관여하는 소프트웨어 구성 요소.
* FreeBSD에 존재하는 기본 Sendmail 구성 파일.
* 원격 사서함과 로컬 사서함의 차이점.
* 스패머가 메일 서버를 중계기로 불법적으로 사용하지 못하도록 차단하는 방법.
* Sendmail을 대체하는 대체 메일 전송 에이전트를 설치하고 구성하는 방법.
* 일반적인 메일 서버 문제를 해결하는 방법.
* 메일 송신 전용서버로 시스템을 설정하는 방법.
* 전화 접속으로 메일을 사용하는 방법.
* 보안 강화를 위해 SMTP 인증을 구성하는 방법.
* 메일 사용자 에이전트(예: mutt)를 설치하고 사용하여 이메일을 주고받는 방법.
* 원격 POP 또는 IMAP 서버에서 메일을 다운로드하는 방법.
* 수신 이메일에 필터 및 규칙을 자동으로 적용하는 방법.

이 챕터를 읽기 전에 알아두어야 할 사항입니다:

* 네트워크 연결의 올바른 설정 (crossref:advanced-networking[advanced-networking,Advanced Networking]).
* 메일 호스트에 대한 DNS 정보의 올바른 설정 (crossref:network-servers[network-servers,Network Servers]).
* 타사 소프트웨어를 추가로 설치하는 방법을 알고 있습니다(crossref:ports[ports,Installing Applications: Packages and Ports]).

[[mail-using]]
== 메일 구성요소

이메일 교환에는 메일 사용자 에이전트(Mail User Agent, MUA), 메일 전송 에이전트(Mail Transfer Agent, MTA), 메일 호스트, 원격 또는 로컬 사서함, DNS 등 5가지 주요 부분이 있습니다. 이 섹션에서는 이러한 구성 요소에 대한 개요를 제공합니다.

메일 사용자 에이전트 (MUA)::
MUA (메일 사용자 에이전트)는 이메일을 작성, 전송 및 수신하는 데 사용되는 애플리케이션입니다. 이 애플리케이션은 내장된 `mail` 유틸리티와 같은 명령줄 프로그램 또는 포트 컬렉션의 타사 애플리케이션(예: mutt, alpine, elm)일 수 있습니다. Claws Mail, Evolution, Thunderbird 등 수십 개의 그래픽 프로그램도 포트 컬렉션에서 사용할 수 있습니다. 일부 조직에서는 웹 브라우저를 통해 액세스할 수 있는 웹 메일 프로그램을 제공합니다. FreeBSD에서 MUA를 설치하고 사용하는 방법에 대한 자세한 정보는 <<mail-agents>> 에서 확인할 수 있습니다.

메일 전송 에이전트(MTA)::
메일 전송 에이전트(MTA)는 메일을 수신하고 발신 메일을 전달하는 역할을 합니다. FreeBSD는 Sendmail을 기본 MTA로 제공하지만, Exim, Postfix, qmail을 포함한 수많은 다른 메일 서버 데몬도 지원합니다. Sendmail 구성은 <<sendmail>> 에 설명되어 있습니다. 포트 컬렉션을 사용하여 다른 MTA를 설치한 경우, 설치 후 메시지에 FreeBSD 관련 구성 세부 정보가 표시되고 애플리케이션의 웹 사이트에서 보다 일반적인 구성 지침을 참조하세요.

메일 호스트 및 사서함::
메일 호스트는 호스트 또는 네트워크에 대한 메일을 전달하고 수신하는 역할을 하는 서버입니다. 메일 호스트는 도메인으로 전송된 모든 메일을 수집하여 구성에 따라 기본 [.filename]#mbox# 또는 대체 Maildir 형식으로 저장합니다. 메일이 저장되면 MUA를 사용하여 로컬에서 읽거나 POP 또는 IMAP 등의 프로토콜을 사용하여 원격으로 액세스하여 수집할 수 있습니다. 메일을 로컬에서 읽는 경우에는 POP 또는 IMAP 서버를 설치할 필요가 없습니다.
+
원격으로 사서함에 액세스하려면 메일 프로토콜을 통해 사용자가 원격 위치에서 사서함에 연결할 수 있으므로 POP 또는 IMAP 서버가 필요합니다. IMAP은 POP에 비해 몇 가지 장점이 있습니다. 여기에는 메시지가 다운로드된 후 원격 서버에 메시지 사본을 저장하는 기능과 동시 업데이트가 포함됩니다. IMAP은 사용자가 메시지를 다운로드하지 않고도 메시지의 구조를 가져올 수 있으므로 저속 링크에서 유용할 수 있습니다. 또한 클라이언트와 서버 간의 데이터 전송을 최소화하기 위해 서버에서 검색과 같은 작업을 수행할 수도 있습니다.
+
포트 컬렉션에서 여러가지 POP 및 IMAP 서버를 사용할 수 있습니다. 여기에는 package:mail/qpopper[], package:mail/imap-uw[], package:mail/courier-imap[], package:mail/dovecot2[] 가 포함됩니다.
+
[WARNING]
====
POP와 IMAP 모두 사용자 아이디와 비밀번호 자격 증명을 포함한 정보를 일반 텍스트로 전송한다는 점에 유의해야 합니다. 이러한 프로토콜을 통한 정보 전송을 보호하려면 man:ssh[1]를 통해 세션을 터널링하거나( crossref:security[security-ssh-tunneling,"SSH Tunneling"] ) SSL( crossref:security[openssl,"OpenSSL"] )을 사용하는 것을 고려하세요.
====

도메인 네임 시스템(DNS)::
DNS(도메인 네임 시스템)와 그 데몬 `named` 는 이메일 전송에서 중요한 역할을 합니다. 한 사이트에서 다른 사이트로 메일을 전달하기 위해 MTA는 DNS에서 원격 사이트를 조회하여 대상에 대한 메일을 수신할 호스트를 결정합니다. 이 프로세스는 원격 호스트에서 MTA로 메일이 전송될 때도 발생합니다.
+
DNS는 호스트 이름을 IP 주소에 매핑하는 것 외에도 메일 전달과 관련된 정보, 즉 메일 익스체인저 MX 레코드를 저장하는 역할을 담당합니다. MX 레코드는 특정 도메인에 대한 메일을 수신할 호스트를 지정합니다.
+
도메인의 MX 레코드를 보려면 레코드 유형을 지정합니다. 이 명령에 대한 자세한 내용은 man:host[1]를 참조하세요:
+
[source, shell]
....
% host -t mx FreeBSD.org
FreeBSD.org mail is handled by 10 mx1.FreeBSD.org
....
+
DNS 및 그 구성에 대한 자세한 내용은 crossref:network-servers[network-dns,"Domain Name System (DNS)"] 을 참조하세요.

[[sendmail]]
== Sendmail 구성 파일

Sendmail은 FreeBSD와 함께 설치된 기본 MTA입니다. 이 메일은 MUA로부터 메일을 받아 구성에 정의된 대로 적절한 메일 호스트로 전달합니다. Sendmail은 네트워크 연결을 수락하고 로컬 사서함이나 다른 프로그램으로 메일을 전달할 수도 있습니다.

Sendmail의 구성 파일은 [.filename]#/etc/mail# 에 있습니다. 이 섹션에서는 이러한 파일에 대해 자세히 설명합니다.

[.filename]#/etc/mail/access#::
이 액세스 데이터베이스 파일은 로컬 메일 서버에 액세스할 수 있는 호스트 또는 IP 주소와 액세스 권한의 종류를 정의합니다. 기본 옵션인 `OK` 로 나열된 호스트는 메일의 최종 목적지가 로컬 컴퓨터인 한 이 호스트로 메일을 보낼 수 있습니다. `REJECT` 로 표시된 호스트는 모든 메일 연결이 거부됩니다. `RELAY` 로 나열된 호스트는 이 메일 서버를 사용하여 모든 대상에 대해 메일을 보낼 수 있습니다. `ERROR` 로 표시된 호스트는 지정된 메일 오류와 함께 메일이 반환됩니다. 호스트가 `SKIP` 으로 나열된 경우 Sendmail은 메일을 수락하거나 거부하지 않고 이 항목에 대한 현재 검색을 중단합니다. `QUARANTINE` 로 표시된 호스트는 메시지가 보류되며 보류 사유로 지정된 텍스트를 받게 됩니다.
+
IPv4 및 IPv6 주소 모두에 이러한 옵션을 사용하는 예는 FreeBSD 샘플 구성인 [.filename]#/etc/mail/access.sample# 에서 확인할 수 있습니다:
+
[.programlisting]
....
# $FreeBSD$
#
# Mail relay access control list.  Default is to reject mail unless the
# destination is local, or listed in /etc/mail/local-host-names
#
## Examples (commented out for safety)
#From:cyberspammer.com          ERROR:"550 We don't accept mail from spammers"
#From:okay.cyberspammer.com     OK
#Connect:sendmail.org           RELAY
#To:sendmail.org                RELAY
#Connect:128.32                 RELAY
#Connect:128.32.2               SKIP
#Connect:IPv6:1:2:3:4:5:6:7     RELAY
#Connect:suspicious.example.com QUARANTINE:Mail from suspicious host
#Connect:[127.0.0.3]            OK
#Connect:[IPv6:1:2:3:4:5:6:7:8] OK
....
+
액세스 데이터베이스를 구성하려면 샘플에 표시된 형식을 사용하여 [.filename]#/etc/mail/access# 에 항목을 입력하되, 항목 앞에 주석 기호( `+#+` )를 넣지 마세요. 액세스를 구성해야 하는 각 호스트 또는 네트워크에 대한 항목을 만듭니다. 표의 왼쪽과 일치하는 메일 발신자는 표의 오른쪽에 있는 작업의 영향을 받습니다.
+
이 파일을 업데이트할 때마다 데이터베이스를 업데이트하고 센드메일을 다시 시작하세요:
+
[source, shell]
....
# makemap hash /etc/mail/access < /etc/mail/access
# service sendmail restart
....

[.filename]#/etc/mail/aliases#::
이 데이터베이스 파일에는 사용자, 파일, 프로그램 또는 기타 별칭으로 확장된 가상 사서함 목록이 포함되어 있습니다. 다음은 파일 형식을 설명하기 위한 몇 가지 항목입니다:
+
[.programlisting]
....
root: localuser
ftp-bugs: joe,eric,paul
bit.bucket:  /dev/null
procmail: "|/usr/local/bin/procmail"
....
+
콜론 왼쪽의 사서함 이름이 오른쪽의 대상으로 확장됩니다. 첫 번째 항목은 `root` 사서함을 `localuser` 사서함으로 확장한 다음 [.filename]#/etc/mail/aliases# 데이터베이스에서 조회합니다. 일치하는 항목이 없으면 메시지가 `localuser` 로 전달됩니다. 두 번째 항목은 메일 목록을 보여줍니다. `ftp-bugs` 로 보내는 메일은 세 개의 로컬 사서함인 `joe`, `eric`, `paul` 로 확장됩니다. 원격 사서함은 _user@example.com_ 로 지정할 수 있습니다. 세 번째 항목은 파일에 메일을 쓰는 방법(이 경우 [.filename]#/dev/null# )을 보여줍니다. 마지막 항목은 UNIX(R) 파이프를 통해 프로그램(예: [.filename]#/usr/local/bin/procmail# )으로 메일을 보내는 방법을 보여줍니다. 이 파일의 형식에 대한 자세한 내용은 man:aliases[5]를 참조하세요.
+
이 파일이 업데이트될 때마다 `newaliases` 를 실행하여 별칭 데이터베이스를 업데이트하고 초기화합니다.

[.filename]#/etc/mail/sendmail.cf#::
Sendmail의 마스터 구성 파일입니다. 이메일 주소 재작성부터 수신 거부 메시지 인쇄, 원격 메일 서버에 이르기까지 Sendmail의 전반적인 동작을 제어합니다. 따라서 이 구성 파일은 상당히 복잡합니다. 다행히도 표준 메일 서버의 경우 이 파일을 변경할 필요가 거의 없습니다.
+
마스터 Sendmail 구성 파일은 Sendmail의 기능과 동작을 정의하는 man:m4[1] 매크로로 작성할 수 있습니다. 자세한 내용은 [.filename]#/usr/src/contrib/sendmail/cf/README# 를 참조하세요.
+
이 파일을 변경할 때마다 Sendmail을 다시 시작해야 변경 내용을 적용할 수 있습니다.

[.filename]#/etc/mail/virtusertable#::
이 데이터베이스 파일은 가상 도메인 및 사용자의 메일 주소를 실제 사서함에 매핑합니다. 이러한 사서함은 로컬, 원격, [.filename]#/etc/mail/aliases# 에 정의된 별칭 또는 파일일 수 있습니다. 이를 통해 하나의 컴퓨터에서 여러 가상 도메인을 호스팅할 수 있습니다.
+
FreeBSD는 [.filename]#/etc/mail/virtusertable.sample# 에 샘플 구성 파일을 제공하며 형식을 자세히 설명합니다. 다음 예는 이 형식을 사용하여 사용자 지정 항목을 만드는 방법을 보여줍니다:
+
[.programlisting]
....
root@example.com                root
postmaster@example.com          postmaster@noc.example.net
@example.com                    joe
....
+
이 파일은 먼저 일치하는 순서를 기준으로 처리됩니다. 이메일 주소가 왼쪽의 주소와 일치하면 오른쪽에 나열된 로컬 사서함에 매핑됩니다. 이 예에서 첫 번째 항목의 형식은 특정 이메일 주소를 로컬 사서함에 매핑하고, 두 번째 항목의 형식은 특정 이메일 주소를 원격 사서함에 매핑합니다. 마지막으로, 이전 항목과 일치하지 않는 `example.com` 의 모든 이메일 주소는 마지막 매핑과 일치하여 로컬 사서함 `joe` 로 전송됩니다. 사용자 지정 항목을 만들 때는 이 형식을 사용하여 [.filename]#/etc/mail/virtusertable# 에 추가하세요. 이 파일을 편집할 때마다 데이터베이스를 업데이트하고 Sendmail을 다시 시작하세요:
+
[source, shell]
....
# makemap hash /etc/mail/virtusertable < /etc/mail/virtusertable
# service sendmail restart
....

[.filename]#/etc/mail/relay-domains#::
FreeBSD 기본 설치에서 Sendmail은 실행 중인 호스트에서만 메일을 보내도록 구성됩니다. 예를 들어 POP 서버를 사용할 수 있는 경우 사용자는 원격 위치에서 메일을 확인할 수 있지만 외부 위치에서 발신 메일을 보낼 수는 없습니다. 일반적으로 시도 후 몇 분 후에 `5.7 Relaying Denied` 메시지와 함께 `MAILER-DAEMON` 에서 이메일이 전송됩니다.
+
가장 간단한 방법은 [.filename]#/etc/mail/relay-domains# 에 ISP의 FQDN을 추가하는 것입니다. 여러 개의 주소가 필요한 경우 한 줄에 하나씩 추가하세요:
+
[.programlisting]
....
your.isp.example.com
other.isp.example.net
users-isp.example.org
www.example.org
....
+
이 파일을 만들거나 편집한 후 `service sendmail restart` 으로 Sendmail을 재시작합니다.
+
이제 사용자가 시스템에 계정이 있는 경우 이 목록에 있는 호스트가 시스템을 통해 보내는 모든 메일이 성공합니다. 따라서 사용자는 인터넷에서 스팸을 중계하기 위해 시스템을 열지 않고도 시스템에서 원격으로 메일을 보낼 수 있습니다.

[[mail-changingmta]]
== 메일 전송 에이전트 변경하기

FreeBSD에는 발신 및 수신 메일을 담당하는 MTA로 Sendmail이 이미 설치되어 있습니다. 하지만 시스템 관리자는 시스템의 MTA를 변경할 수 있습니다. FreeBSD 포트 컬렉션의 `mail` 카테고리에서 다양한 대체 MTA를 선택할 수 있습니다.

새 MTA가 설치되면 Sendmail을 교체하기 전에 새 소프트웨어를 구성하고 테스트합니다. 소프트웨어를 구성하는 방법에 대한 자세한 내용은 새 MTA의 설명서를 참조하세요.

새 MTA가 작동하면 이 섹션의 지침에 따라 Sendmail을 비활성화하고 대체 MTA를 사용하도록 FreeBSD를 구성합니다.

[[mail-disable-sendmail]]
=== Sendmail 비활성화

[WARNING]
====

Sendmail의 발신 메일 서비스가 비활성화되어 있는 경우 다른 메일 전달 시스템으로 대체하는 것이 중요합니다. 그렇지 않으면 man:periodic[8]과 같은 시스템 기능이 이메일로 결과를 전달할 수 없게 됩니다. 시스템의 많은 부분이 제대로 작동하는 MTA를 기대합니다. 애플리케이션이 비활성화된 후에도 Sendmail의 바이너리를 계속 사용하여 이메일 전송을 시도하면 메일이 비활성 Sendmail 대기열로 이동하여 전달되지 않을 수 있습니다.
====

Sendmail을 완전히 비활성화하려면 [.filename]#/etc/rc.conf# 에 다음 줄을 추가하거나 편집하세요:

[.programlisting]
....
sendmail_enable="NO"
sendmail_submit_enable="NO"
sendmail_outbound_enable="NO"
sendmail_msp_queue_enable="NO"
....

Sendmail의 수신 메일 서비스만 비활성화하려면 [.filename]#/etc/rc.conf# 에서 이 항목만 사용하세요:

[.programlisting]
....
sendmail_enable="NO"
....

Sendmail의 시작 옵션에 대한 자세한 내용은 man:rc.sendmail[8] 에서 확인할 수 있습니다.

=== 기본 MTA 교체

포트 컬렉션을 사용하여 새 MTA를 설치하면 해당 시작 스크립트도 설치되며 시작 지침이 패키지 메시지에 언급됩니다. 새 MTA를 시작하기 전에 실행 중인 Sendmail 프로세스를 중지합니다. 이 예에서는 이러한 모든 서비스를 중지한 다음 Postfix 서비스를 시작합니다:

[source, shell]
....
# service sendmail stop
# service postfix start
....

시스템 부팅 시 대체 MTA를 시작하려면 [.filename]#/etc/rc.conf# 에 해당 구성 줄을 추가합니다. 이 항목은 포스트픽스 MTA를 활성화합니다:

[.programlisting]
....
postfix_enable="YES"
....

일부 MTA는 대부분의 소프트웨어들이 시스템에 Sendmail이 설치되어 있고 동작한다고 가정하기 때문에 약간의 추가 구성이 필요합니다. [.filename]#/etc/periodic.conf# 를 확인하고 이 값이 `NO` 로 설정되어 있는지 확인합니다. 이 파일이 존재하지 않는 경우 다음 항목으로 파일을 생성하세요:

[.programlisting]
....
daily_clean_hoststat_enable="NO"
daily_status_mail_rejects_enable="NO"
daily_status_include_submit_mailq="NO"
daily_submit_queuerun="NO"
....

일부 대체 MTA는 Sendmail의 drop-in 대체용으로 쉽게 사용할 수 있도록 자체적으로 호환 가능한 Sendmail 명령줄 인터페이스 구현을 제공합니다. 그러나 일부 MUA는 새로운 MTA 바이너리 대신 표준 Sendmail 바이너리를 실행하려고 시도할 수 있습니다. FreeBSD는 [.filename]#/etc/mail/mailer.conf# 를 사용하여 예상되는 Sendmail 바이너리를 새 바이너리의 위치에 매핑합니다. 이 매핑에 대한 자세한 정보는 man:mailwrapper[8]에서 확인할 수 있습니다.

기본 [.filename]#/etc/mail/mailer.conf# 은 다음과 같습니다:

[.programlisting]
....
# $FreeBSD$
#
# Execute the "real" sendmail program, named /usr/libexec/sendmail/sendmail
#
sendmail        /usr/libexec/sendmail/sendmail
send-mail       /usr/libexec/sendmail/sendmail
mailq           /usr/libexec/sendmail/sendmail
newaliases      /usr/libexec/sendmail/sendmail
hoststat        /usr/libexec/sendmail/sendmail
purgestat       /usr/libexec/sendmail/sendmail
....

왼쪽에 나열된 명령 중 하나를 실행하면 시스템은 실제로 오른쪽에 표시된 관련 명령을 실행합니다. 이 시스템을 사용하면 이러한 기본 바이너리가 호출될 때 실행되는 바이너리를 쉽게 변경할 수 있습니다.

일부 MTA는 포트 컬렉션을 사용하여 설치할 때 새 바이너리를 위해 이 파일을 업데이트하라는 메시지를 표시합니다. 예를 들어 Postfix는 다음과 같이 파일을 업데이트합니다:

[.programlisting]
....
#
# Execute the Postfix sendmail program, named /usr/local/sbin/sendmail
#
sendmail        /usr/local/sbin/sendmail
send-mail       /usr/local/sbin/sendmail
mailq           /usr/local/sbin/sendmail
newaliases      /usr/local/sbin/sendmail
....

MTA를 설치해도 [.filename]#/etc/mail/mailer.conf# 가 자동으로 업데이트되지 않으면 텍스트 편집기에서 이 파일을 편집하여 새 바이너리를 가리키도록 합니다. 이 예에서는 package:mail/ssmtp[] 로 설치된 바이너리를 가리킵니다:

[.programlisting]
....
sendmail        /usr/local/sbin/ssmtp
send-mail       /usr/local/sbin/ssmtp
mailq           /usr/local/sbin/ssmtp
newaliases      /usr/local/sbin/ssmtp
hoststat        /usr/bin/true
purgestat       /usr/bin/true
....

모든 구성이 완료되면 시스템을 재부팅하는 것이 좋습니다. 재부팅하면 부팅 시 새 MTA가 자동으로 시작되도록 시스템이 올바르게 구성되었는지 확인할 수 있습니다.

[[mail-trouble]]
== 문제 해결

=== 내 사이트의 호스트에 FQDN을 사용해야 하는 이유는 무엇인가요?

호스트가 실제로 다른 도메인에 있을 수 있습니다. 예를 들어, `foo.bar.edu` 의 호스트가 `bar.edu` 도메인의 `mumble` 이라는 호스트에 도달하려면 `mumble` 이 아닌 정규화된 도메인 이름 FQDN인 `mumble.bar.edu` 로 호스트를 참조해야 합니다.

이는 FreeBSD와 함께 제공되는 BIND의 버전이 더 이상 로컬 도메인 이외의 non-FQDN에 대한 기본 약어를 제공하지 않기 때문입니다. `mumble` 과 같은 정규화되지 않은 호스트는 `mumble.foo.bar.edu` 로 찾거나 루트 도메인에서 검색해야 합니다.

이전 버전의 BIND에서는 `mumble.bar.edu` 와 `mumble.edu` 에서 검색이 계속되었습니다. 왜 이것이 나쁜 관행 또는 보안 허점으로 간주되는지에 대한 자세한 내용은 RFC 1535를 참조하세요.

좋은 해결 방법으로 다음 내용을 배치합니다:

[.programlisting]
....
search foo.bar.edu bar.edu
....

를 대신해서:

[.programlisting]
....
domain foo.bar.edu
....

를 [.filename]#/etc/resolv.conf# 에 추가합니다. 그러나 검색 순서가 RFC 1535에서 말하는 "boundary between local and public administration"를 넘지 않도록 해야 합니다.

=== 전화 접속 PPP 호스트에서 메일 서버를 실행하려면 어떻게 해야 하나요?

LAN에서 FreeBSD 메일 게이트웨이에 연결합니다. PPP 연결은 전용이 아닙니다.

이를 위한 한 가지 방법은 도메인에 보조 MX 서비스를 제공할 풀타임 인터넷 서버를 확보하는 것입니다. 이 예제에서 도메인은 `example.com` 이고 ISP는 이 도메인에 보조 MX 서비스를 제공하도록 `example.net` 을 구성했습니다:

[.programlisting]
....
example.com.          MX        10      example.com.
                      MX        20      example.net.
....

최종 수신자로는 한 호스트만 지정해야 합니다. Sendmail의 경우 `example.com` 의 [.filename]#/etc/mail/sendmail.cf# 에 `Cw example.com` 을 추가합니다.

보내는 MTA가 메일을 전달하려고 하면 PPP 링크를 통해 시스템인`example.com` 에 연결을 시도합니다. 목적지가 오프라인 상태이면 시간이 초과됩니다. MTA는 인터넷 서비스 제공업체(ISP)의 보조 MX 사이트인 `example.net` 에 자동으로 메일을 전달합니다. 보조 MX 사이트는 주기적으로 기본 MX 호스트인 `example.com` 에 연결을 시도합니다.

로그인 스크립트로 다음과 같은 것을 사용합니다:

[.programlisting]
....
#!/bin/sh
# Put me in /usr/local/bin/pppmyisp
( sleep 60 ; /usr/sbin/sendmail -q ) &
/usr/sbin/ppp -direct pppmyisp
....

사용자를 위한 별도의 로그인 스크립트를 만들 때는 위의 스크립트에서 `sendmail -qRexample.com` 을 대신 사용하세요. 이렇게 하면 `example.com` 에 대한 대기열에 있는 모든 메일이 즉시 처리됩니다.

이 예제에서 {freebsd-isp}의 상황을 더 세분화하여 볼 수 있습니다:

[.programlisting]
....
> we provide the secondary MX for a customer. The customer connects to
> our services several times a day automatically to get the mails to
> his primary MX (We do not call his site when a mail for his domains
> arrived). Our sendmail sends the mailqueue every 30 minutes. At the
> moment he has to stay 30 minutes online to be sure that all mail is
> gone to the primary MX.
>
> Is there a command that would initiate sendmail to send all the mails
> now? The user has not root-privileges on our machine of course.

In the privacy flags section of sendmail.cf, there is a
definition Opgoaway,restrictqrun

Remove restrictqrun to allow non-root users to start the queue processing.
You might also like to rearrange the MXs. We are the 1st MX for our
customers like this, and we have defined:

# If we are the best MX for a host, try directly instead of generating
# local config error.
OwTrue

That way a remote site will deliver straight to you, without trying
the customer connection.  You then send to your customer.  Only works for
hosts, so you need to get your customer to name their mail
machine customer.com as well as
hostname.customer.com in the DNS.  Just put an A record in
the DNS for customer.com.
....

[[mail-advanced]]
== 고급 주제

이 섹션에서는 메일 구성 및 전체 도메인에 대한 메일 설정과 같은, 보다 복잡한 주제를 다룹니다.

[[mail-config]]
=== 기본 구성

기본적으로 [.filename]#/etc/resolv.conf# 가 구성되어 있거나 네트워크에서 구성된 DNS 서버에 액세스할 수 있는 경우 외부 호스트로 이메일을 보낼 수 있습니다. FreeBSD 호스트의 MTA로 이메일을 전달하려면 다음 중 하나를 수행하세요:

* 도메인에 대한 DNS 서버를 실행합니다.
* 메일을 컴퓨터의 FQDN으로 직접 배달하세요.

호스트에 직접 메일을 전달하려면 호스트에 동적 IP 주소가 아닌 영구 고정 IP 주소가 있어야 합니다. 시스템이 방화벽 뒤에 있는 경우 SMTP 트래픽을 허용하도록 구성해야 합니다. 호스트에서 직접 메일을 받으려면 다음 두 가지 중 하나를 구성해야 합니다:

* DNS에서 가장 낮은 번호의 MX 레코드가 호스트의 고정 IP 주소를 가리키는지 확인하세요.
* 호스트에 대한 DNS에 MX 항목이 있는지 확인합니다.

위의 두 가지 방법 중 하나를 사용하면 호스트에서 직접 메일을 받을 수 있습니다.

이렇게 해보세요:

[source, shell]
....
# hostname
example.FreeBSD.org
# host example.FreeBSD.org
example.FreeBSD.org has address 204.216.27.XX
....

이 예에서는 `example.FreeBSD.org` 에서 Sendmail이 올바르게 실행되고 있다고 가정하면 mailto:yourlogin@example.FreeBSD.org[yourlogin@example.FreeBSD.org] 로 직접 보낸 메일이 문제없이 작동합니다.

이 예시에서는:

[source, shell]
....
# host example.FreeBSD.org
example.FreeBSD.org has address 204.216.27.XX
example.FreeBSD.org mail is handled (pri=10) by nevdull.FreeBSD.org
....

`example.FreeBSD.org` 로 전송된 모든 메일은 호스트로 직접 전송되지 않고 동일한 사용자 이름으로 `hub` 에 수집됩니다.

위의 정보는 DNS 서버에서 처리합니다. 메일 라우팅 정보를 전달하는 DNS 레코드는 MX 항목입니다. MX 레코드가 존재하지 않으면 메일은 해당 IP 주소를 통해 호스트에게 직접 전달됩니다.

한때 `freefall.FreeBSD.org` 의 MX 항목은 다음과 같았습니다:

[.programlisting]
....
freefall		MX	30	mail.crl.net
freefall		MX	40	agora.rdrop.com
freefall		MX	10	freefall.FreeBSD.org
freefall		MX	20	who.cdrom.com
....

`freefall` 는 MX 항목이 많습니다. 가장 낮은 MX 번호는 가능한 경우 메일을 직접 수신하는 호스트입니다. 어떤 이유로 액세스할 수 없는 경우, 다음 낮은 번호의 호스트가 일시적으로 메시지를 수락하고 더 낮은 번호의 호스트를 사용할 수 있게 되면 이를 전달합니다.

대체 MX 사이트를 가장 유용하게 사용하려면 별도의 인터넷 연결이 있어야 합니다. ISP에서 이 서비스를 제공할 수 있습니다.

[[mail-domain]]
=== 도메인용 메일

네트워크에 대한 MTA를 구성할 때 해당 도메인의 호스트로 전송되는 모든 메일은 사용자가 마스터 메일 서버에서 메일을 받을 수 있도록 MTA로 리디렉션되어야 합니다.

가장 쉽게 사용할 수 있도록 MTA와 MUA가 있는 시스템 모두에 동일한 _username_ 을 가진 사용자 계정이 존재해야 합니다. man:adduser[8]를 사용하여 사용자 계정을 만듭니다.

MTA는 네트워크의 각 워크스테이션에 대해 지정된 메일 교환기여야 합니다. 이 작업은 MX 레코드를 사용하여 DNS 구성에서 수행됩니다:

[.programlisting]
....
example.FreeBSD.org	A	204.216.27.XX		; Workstation
			MX	10 nevdull.FreeBSD.org	; Mailhost
....

이렇게 하면 A 레코드가 가리키는 위치에 관계없이 워크스테이션의 메일이 MTA로 리디렉션됩니다. 메일은 MX 호스트로 전송됩니다.

이 설정은 DNS 서버에서 구성해야 합니다. 네트워크에서 자체 DNS 서버를 실행하지 않는 경우 ISP 또는 DNS 공급업체에 문의하세요.

다음은 가상 이메일 호스팅의 예입니다. `customer1.org` 도메인을 가진 고객이 있다고 가정할 때, `customer1.org` 에 대한 모든 메일은 `mail.myhost.com` 으로 전송되어야 합니다. DNS 항목은 다음과 같아야 합니다:

[.programlisting]
....
customer1.org		MX	10	mail.myhost.com
....

해당 도메인에 대한 이메일만 처리하기 위해 `customer1.org` 에는 `A` 레코드가 _필요하지_ 않습니다. 그러나 `customer1.org` 에 대해 `ping` 을 실행 했을때 `A` 레코드가 없으면 작동하지 않습니다.

MTA에 메일을 허용할 도메인 및/또는 호스트 이름을 알려줍니다. 다음 중 하나가 Sendmail에 사용할 수 있습니다:

* `FEATURE(use_cw_file)` 을 사용할 때 호스트를 [.filename]#/etc/mail/local-host-names# 에 추가합니다.
* [.filename]#/etc/sendmail.cf# 에 `Cwyour.host.com` 줄을 추가합니다.

[[outgoing-only]]
== Send Only 설정하기

릴레이를 통해서만 메일을 보내야 하는 경우가 많이 있습니다. 몇 가지 예를 들면 다음과 같습니다:

* ISP의 메일 릴레이를 사용하여 man:mail[1]과 같은 프로그램을 사용해야 하는 데스크톱 컴퓨터입니다.
* 로컬에서 메일을 처리하지 않고 처리를 위해 모든 메일을 릴레이로 전달해야 하는 서버입니다.

모든 MTA가 이 특정 틈새를 메울 수 있지만, 메일 오프로딩을 처리하기 위해 모든 기능을 갖춘 MTA를 적절하게 구성하는 것은 어려울 수 있습니다. Sendmail 및 Postfix와 같은 프로그램은 이러한 용도로 사용하기에는 과합니다.

또한 일반적인 인터넷 액세스 서비스 계약에서는 "mail server" 운영을 금지할 수 있습니다.

이러한 요구 사항을 충족하는 가장 쉬운 방법은 package:mail/ssmtp[] 포트를 설치하는 것입니다:

[source, shell]
....
# cd /usr/ports/mail/ssmtp
# make install replace clean
....

설치가 완료되면 [.filename]#/usr/local/etc/ssmtp/ssmtp.conf# 를 사용하여 package:mail/ssmtp[] 를 구성할 수 있습니다:

[.programlisting]
....
root=yourrealemail@example.com
mailhub=mail.example.com
rewriteDomain=example.com
hostname=_HOSTNAME_
....

`root` 에 실제 이메일 주소를 사용합니다. `mail.example.com` 대신 ISP의 발신 메일 릴레이를 입력합니다. 일부 ISP는 이를 "outgoing mail server" 또는 "SMTP 서버"라고 부릅니다.

발신 메일 서비스를 포함하여 Sendmail을 비활성화해야 합니다. 자세한 내용은 <<mail-disable-sendmail>> 을 참조하세요.

package:mail/ssmtp[] 에는 몇 가지 다른 옵션이 있습니다. 자세한 내용은 [.filename]#/usr/local/etc/ssmtp# 의 예시 또는 ssmtp의 매뉴얼 페이지를 참조하세요.

이러한 방식으로 ssmtp를 설정하면 메일을 보내야 하는 컴퓨터의 모든 소프트웨어가 제대로 작동하면서 ISP의 사용 정책을 위반하거나 스패머에게 컴퓨터가 도용되지 않도록 할 수 있습니다.

[[SMTP-dialup]]
== 전화 접속 연결로 메일 사용하기

고정 IP 주소를 사용하는 경우에는 기본 구성을 조정할 필요가 없습니다. 호스트 이름을, 할당된 인터넷 이름으로 설정하면 나머지는 Sendmail에서 알아서 처리합니다.

동적으로 할당된 IP 주소와 인터넷에 대한 전화 접속 PPP 연결을 사용하는 경우 일반적으로 ISP의 메일 서버에 사서함이 있습니다. 이 예에서 ISP의 도메인은 `example.net`, 사용자 이름은 `user`, 호스트 이름은 `bsd.home` 이며, ISP가 `relay.example.net` 을 메일 릴레이로 허용했습니다.

ISP의 사서함에서 메일을 검색하려면 포트 컬렉션에서 검색 에이전트를 설치하세요. package:mail/fetchmail[] 은 다양한 프로토콜을 지원하므로 좋은 선택입니다. 일반적으로 ISP는 POP를 제공합니다. 사용자가 PPP를 사용하는 경우, 인터넷 연결이 설정되면 [.filename]#/etc/ppp/ppp.linkup# 에 다음 항목을 추가하여 이메일을 자동으로 가져올 수 있습니다:

[.programlisting]
....
MYADDR:
!bg su user -c fetchmail
....

Sendmail을 사용하여 로컬이 아닌 계정으로 메일을 배달할 때는 인터넷 연결이 설정되는 즉시 메일 대기열을 처리하도록 Sendmail을 구성하세요. 이렇게 하려면 [.filename]#/etc/ppp/ppp.linkup# 에서 위의 `fetchmail` 항목 뒤에 다음 줄을 추가합니다:

[.programlisting]
....
  !bg su user -c "sendmail -q"
....

이 예제에서는 `bsd.home` 에 `user` 계정이 있습니다. `user` 의 `bsd.home` 에 있는 홈 디렉터리에서 다음이 포함된 [.filename]#.fetchmailrc# 를 만듭니다:

[.programlisting]
....
poll example.net protocol pop3 fetchall pass MySecret
....

이 파일에는 비밀번호 `MySecret` 이 포함되어 있으므로 `user` 외에는 누구도 이 파일을 읽을 수 없어야 합니다.

올바른 `from:` 헤더를 사용하여 메일을 보내려면 mailto:user@bsd.home[user@bsd.home] 이 아닌 mailto:user@example.net[user@example.net] 을 사용하고 모든 메일을 `relay.example.net` 을 통해 보내도록 Sendmail을 구성하면 더 빠르게 메일을 전송할 수 있습니다.

다음 [.filename]#.mc# 이면 충분합니다:

[.programlisting]
....
VERSIONID(`bsd.home.mc version 1.0')
OSTYPE(bsd4.4)dnl
FEATURE(nouucp)dnl
MAILER(local)dnl
MAILER(smtp)dnl
Cwlocalhost
Cwbsd.home
MASQUERADE_AS(`example.net')dnl
FEATURE(allmasquerade)dnl
FEATURE(masquerade_envelope)dnl
FEATURE(nocanonify)dnl
FEATURE(nodns)dnl
define(`SMART_HOST', `relay.example.net')
Dmbsd.home
define(`confDOMAIN_NAME',`bsd.home')dnl
define(`confDELIVERY_MODE',`deferred')dnl
....

이 파일을 [.filename]#sendmail.cf# 형식으로 변환하는 방법에 대한 자세한 내용은 이전 섹션을 참조하세요. [.filename]#sendmail.cf# 을 업데이트한 후에는 Sendmail을 다시 시작하는 것을 잊지 마세요.

[[SMTP-Auth]]
== SMTP Authentication

MTA에서 SMTP 인증을 구성하면 여러 가지 이점이 있습니다. SMTP 인증은 Sendmail에, 보안 계층을 추가하고 호스트를 전환하는 모바일 사용자에게 매번 메일 클라이언트의 설정을 다시 구성할 필요 없이 동일한 MTA를 사용할 수 있는 기능을 제공합니다.

[.procedure]
. 포트 컬렉션에서 package:security/cyrus-sasl2[] 를 설치합니다. 이 포트는 여러 컴파일 시기의 옵션을 지원합니다. 이 예제에서 설명하는 SMTP 인증 방법의 경우 `LOGIN` 이 비활성화되어 있지 않은지 확인합니다.
. package:security/cyrus-sasl2[] 를 설치한 후 [.filename]#/usr/local/lib/sasl2/Sendmail.conf# 을 편집하거나 파일이 없는 경우 새로 만들어 다음 줄을 추가합니다:
+
[.programlisting]
....
pwcheck_method: saslauthd
....

. 그런 다음 package:security/cyrus-sasl2-saslauthd[] 를 설치하고 [.filename]#/etc/rc.conf# 에 다음 줄을 추가합니다:
+
[.programlisting]
....
saslauthd_enable="YES"
....
+
마지막으로 saslauthd 데몬을 시작합니다:
+
[source, shell]
....
# service saslauthd start
....
+
이 데몬은 Sendmail이 FreeBSD man:passwd[5] 데이터베이스에 대해 인증하는 브로커 역할을 합니다. 이렇게 하면 SMTP 인증을 사용해야 하는 각 사용자에 대해 사용자 이름과 비밀번호를 새로 만들어야 하는 수고를 덜 수 있으며 로그인 및 메일 비밀번호를 동일하게 유지할 수 있습니다.
. 그런 다음 [.filename]#/etc/make.conf# 를 편집하고 다음 줄을 추가합니다:
+
[.programlisting]
....
SENDMAIL_CFLAGS=-I/usr/local/include/sasl -DSASL
SENDMAIL_LDADD=/usr/local/lib/libsasl2.so
....
+
이 줄은 컴파일 시 package:cyrus-sasl2[] 에 연결하기 위한 적절한 구성 옵션을 Sendmail에 제공합니다. Sendmail을 다시 컴파일하기 전에 package:cyrus-sasl2[] 가 설치되어 있는지 확인하세요.
. 다음 명령을 실행하여 Sendmail을 다시 컴파일합니다:
+
[source, shell]
....
# cd /usr/src/lib/libsmutil
# make cleandir && make obj && make
# cd /usr/src/lib/libsm
# make cleandir && make obj && make
# cd /usr/src/usr.sbin/sendmail
# make cleandir && make obj && make && make install
....
+
이 컴파일은 [.filename]#/usr/src# 이 크게 변경되지 않았고 필요한 공유 라이브러리를 사용할 수 있는 경우 아무런 문제가 없어야 합니다.
. Sendmail을 컴파일하고 다시 설치한 후 [.filename]#/etc/mail/freebsd.mc# 또는 로컬 [.filename]#.mc# 을 편집합니다. 많은 관리자가 고유성을 위해 man:hostname[1] 의 출력을 [.filename]#.mc# 의 이름으로 사용하기도 합니다. 다음 줄을 추가합니다:
+
[.programlisting]
....
dnl set SASL options
TRUST_AUTH_MECH(`GSSAPI DIGEST-MD5 CRAM-MD5 LOGIN')dnl
define(`confAUTH_MECHANISMS', `GSSAPI DIGEST-MD5 CRAM-MD5 LOGIN')dnl
....
+
이러한 옵션은 Sendmail에서 사용자를 인증하는 데 사용할 수 있는 다양한 방법을 구성합니다. pwcheck 이외의 방법을 사용하려면 Sendmail 설명서를 참조하세요.
. 마지막으로 [.filename]#/etc/mail# 에서 man:make[1] 을 실행합니다. 그러면 새 [.filename]#.mc# 가 실행되고 [.filename]#freebsd.cf# 또는 로컬 [.filename]#.mc# 에 사용된 이름인 [.filename]#.cf# 가 생성됩니다. 그런 다음 `make install restart` 를 실행하여 파일을 [.filename]#sendmail.cf# 에 복사한 후 Sendmail을 다시 시작합니다. 이 프로세스에 대한 자세한 내용은 [.filename]#/etc/mail/Makefile# 을 참조하세요.

구성을 테스트하려면 MUA를 사용하여 테스트 메시지를 보내세요. 추가 조사를 위해 Sendmail의 `LogLevel` 을 `13` 으로 설정하고 [.filename]#/var/log/maillog# 에서 오류가 있는지 확인합니다.

자세한 내용은 http://www.sendmail.org/~ca/email/auth.html[SMTP authentication]을 참조하세요.

[[mail-agents]]
== 메일 사용자 에이전트

MUA는 이메일을 주고받는 데 사용되는 애플리케이션입니다. 이메일이 "진화"하고 더 복잡해짐에 따라, MUA는 점점 더 강력해지고 있으며 사용자에게 향상된 기능과 유연성을 제공합니다. FreeBSD 포트 컬렉션의 `mail` 카테고리에는 수많은 MUA가 포함되어 있습니다. 여기에는 Evolution이나 Balsa와 같은 그래픽 이메일 클라이언트와 mutt나 alpine과 같은 콘솔 기반 클라이언트가 포함됩니다.

[[mail-command]]
=== `mail`

man:mail[1]은 FreeBSD와 함께 설치되는 기본 MUA입니다. 이것은 텍스트 기반 이메일을 보내고 받는 데 필요한 기본 기능을 제공하는 콘솔 기반 MUA입니다. 제한된 첨부 파일 지원을 제공하며 로컬 사서함에만 액세스할 수 있습니다.

`mail` 은 기본적으로 POP 또는 IMAP 서버와의 상호 작용을 지원하지 않지만, 이러한 사서함은 fetchmail과 같은 애플리케이션을 사용하여 로컬 [.filename]#mbox# 로 다운로드할 수 있습니다.

이메일을 주고받으려면 `mail` 을 실행합니다:

[source, shell]
....
% mail
....

[.filename]#/var/mail# 에 있는 사용자 사서함의 내용은 `mail` 에서 자동으로 읽습니다. 사서함이 비어 있으면 메일을 찾을 수 없다는 메시지와 함께 유틸리티가 종료됩니다. 메일이 있으면 애플리케이션 인터페이스가 시작되고 메시지 목록이 표시됩니다. 다음 예에서 볼 수 있듯이 메시지에는 자동으로 번호가 매겨집니다:

[source, shell]
....
Mail version 8.1 6/6/93.  Type ? for help.
"/var/mail/marcs": 3 messages 3 new
>N  1 root@localhost        Mon Mar  8 14:05  14/510   "test"
 N  2 root@localhost        Mon Mar  8 14:05  14/509   "user account"
 N  3 root@localhost        Mon Mar  8 14:05  14/509   "sample"
....

이제 kbd:[t] 다음에 메시지 번호를 입력하여 메시지를 읽을 수 있습니다. 이 예에서는 첫 번째 이메일을 읽습니다:

[source, shell]
....
& t 1
Message 1:
From root@localhost  Mon Mar  8 14:05:52 2004
X-Original-To: marcs@localhost
Delivered-To: marcs@localhost
To: marcs@localhost
Subject: test
Date: Mon,  8 Mar 2004 14:05:52 +0200 (SAST)
From: root@localhost (Charlie Root)

This is a test message, please reply if you receive it.
....

이 예에서 볼 수 있듯이 메시지가 전체 헤더와 함께 표시됩니다. 메시지 목록을 다시 표시하려면 kbd:[h]를 누릅니다.

이메일에 답장이 필요한 경우 kbd:[R] 또는 kbd:[r] `mail` 키를 누릅니다. kbd:[R]은 `mail` 이 이메일 발신자에게만 답장하도록 지시하는 반면, kbd:[r]은 메시지의 다른 모든 수신자에게 답장하도록 지시합니다. 이러한 명령 뒤에 회신할 메시지의 메일 번호를 붙일 수 있습니다. 응답을 입력한 후에는 메시지 끝을 자체 줄에 kbd:[.]로 표시해야 합니다. 아래에서 예시를 볼 수 있습니다:

[source, shell]
....
& R 1
To: root@localhost
Subject: Re: test

Thank you, I did get your email.
.
EOT
....

새 이메일을 보내려면 kbd:[m]을 누른 다음 수신자 이메일 주소를 입력합니다. 각 주소를 kbd:[,] 구분 기호로 구분하여 여러 명의 수신자를 지정할 수 있습니다. 그런 다음 메시지 제목을 입력한 다음 메시지 내용을 입력할 수 있습니다. 메시지의 끝은 한 줄에 kbd:[.]를 하나씩 넣어 지정해야 합니다.

[source, shell]
....
& mail root@localhost
Subject: I mastered mail

Now I can send and receive email using mail ... :)
.
EOT
....

`mail` 을 사용하는 동안 언제든지 kbd:[?]를 누르면 도움말이 표시됩니다. `mail` 사용 방법에 대한 자세한 도움말은 man:mail[1]을 참조하세요.

[NOTE]
====
man:mail[1]은 첨부파일을 처리하도록 설계되지 않았기 때문에 첨부파일을 제대로 처리하지 못합니다. 최신 MUA는 첨부 파일을 보다 지능적으로 처리합니다. `mail` 을 사용하는 것을 선호하는 사용자는 package:converters/mpack[] 포트가 상당히 유용할 수 있습니다.
====

[[mutt-command]]
=== mutt

mutt는 다음과 같은 다양한 기능을 갖춘 강력한 MUA입니다:

* 메시지 스레딩 기능.
* 이메일의 디지털 서명 및 암호화를 위한 PGP 지원.
* MIME 지원.
* Maildir 지원.
* 고도의 사용자 지정 기능.

mutt에 대한 자세한 내용은 http://www.mutt.org[http://www.mutt.org] 를 참조하세요.

package:mail/mutt[] 포트를 사용하여 mutt를 설치할 수 있습니다. 포트가 설치된 후 다음 명령을 실행하여 mutt를 시작할 수 있습니다:

[source, shell]
....
% mutt
....

mutt는 [.filename]#/var/mail# 에 있는 사용자 사서함의 내용을 자동으로 읽고 표시합니다. 메일을 찾지 못하면 mutt는 사용자의 명령을 기다립니다. 아래 예시는 메시지 목록을 표시하는 mutt를 보여줍니다:

image::mutt1.png["메시지 목록을 보여주는 mutt 이메일 클라이언트"]

이메일을 읽으려면 커서 키를 사용하여 이메일을 선택하고 kbd:[Enter]를 누릅니다. 아래에서 이메일을 표시하는 mutt의 예를 볼 수 있습니다:

image::mutt2.png["이메일을 표시하는 mutt 이메일 클라이언트"]

man:mail[1]과 마찬가지로 mutt를 사용하여 메시지를 보낸 사람에게만 답장할 수도 있고 모든 수신자에게 답장할 수도 있습니다. 이메일 발신자에게만 답장하려면 kbd:[r]을 누르세요. 모든 메시지 수신자뿐만 아니라 원래 보낸 사람에게도 그룹 답장을 보내려면 kbd:[g]를 누릅니다.

[NOTE]
====
기본적으로 mutt는 man:vi[1] 편집기를 사용하여 이메일을 작성하고 답장합니다. 각 사용자는 홈 디렉터리에서 [.filename]#.muttrc# 를 만들거나 편집하고 `editor` 변수를 설정하거나 `EDITOR` 환경 변수를 설정하여 이를 사용자 지정할 수 있습니다. mutt 구성에 대한 자세한 내용은 http://www.mutt.org/[http://www.mutt.org/] 를 참조하세요.
====

새 메일 메시지를 작성하려면 kbd:[m]을 누릅니다. 유효한 제목을 입력하면 mutt가 man:vi[1]을 시작하여 이메일을 작성할 수 있습니다. 이메일 내용이 완성되면 저장하고 `vi` 에서 종료합니다. mutt가 다시 시작되어 전달할 메일의 요약 화면을 표시합니다. 메일을 보내려면 kbd:[y]를 누릅니다. 요약 화면의 예는 아래와 같습니다:

image::mutt3.png["요약 화면을 보여주는 mutt 이메일 클라이언트"]

mutt에는 대부분의 메뉴에서 kbd:[?]를 눌러 액세스할 수 있는 광범위한 도움말이 포함되어 있습니다. 상단 줄에는 적절한 경우 키보드 단축키도 표시됩니다.

[[alpine-command]]
=== alpine

alpine은 초보 사용자를 대상으로 하지만 일부 고급 기능도 포함되어 있습니다.

[WARNING]
====
alpine은 과거에 원격 공격자가 특별히 준비된 이메일을 보내 로컬 시스템의 사용자로 임의의 코드를 실행할 수 있는 원격 취약점이 여러 번 발견되었습니다. 알려진 문제는 수정되었지만, alpine 코드는 안전하지 않은 스타일로 작성되어 있으며 FreeBSD 보안 담당자는 발견되지 않은 다른 취약점이 있을 가능성이 있다고 생각합니다. 사용자는 자신의 책임 하에 alpine을 설치해야 합니다.
====

현재 버전의 alpine은 package:mail/alpine[] 포트를 사용하여 설치할 수 있습니다. 포트가 설치되면 다음 명령을 실행하여 alpine을 시작할 수 있습니다:

[source, shell]
....
% alpine
....

alpine을 처음 실행하면 간단한 소개가 포함된 인사말 페이지가 표시되며, alpine 개발팀에서 얼마나 많은 사용자가 클라이언트를 사용하고 있는지 판단할 수 있도록 익명 이메일 메시지를 보내달라는 요청이 표시됩니다. 이 익명 메시지를 보내려면 kbd:[Enter]를 누르세요. 또는 익명 메시지를 보내지 않고 인사말을 종료하려면 kbd:[E]를 누르세요. 인사말 페이지의 예는 아래와 같습니다:

image::pine1.png["인사말 페이지를 표시하는 alpine 이메일 클라이언트"]

그러면 커서 키를 사용하여 탐색할 수 있는 주 메뉴가 표시됩니다. 이 메인 메뉴에는 새 메일 작성, 메일 디렉터리 탐색, 주소록 항목 관리를 위한 단축키가 있습니다. 주 메뉴 아래에는 현재 작업과 관련된 기능을 수행할 수 있는 관련 키보드 단축키가 표시됩니다.

alpine에서 열리는 기본 디렉터리는 [.filename]#inbox# 입니다. 메시지 인덱스를 보려면 kbd:[I]를 누르거나 아래 표시된 [.guimenuitem]#MESSAGE INDEX# 옵션을 선택합니다:

image::pine2.png["기본 디렉터리를 보여주는 alpine 이메일 클라이언트"]

메시지 색인에는 현재 디렉터리에 있는 메시지가 표시되며 커서 키를 사용하여 탐색할 수 있습니다. 강조 표시된 메시지는 kbd:[Enter]를 눌러 읽을 수 있습니다.

image::pine3.png["메시지 색인을 보여주는 alpine 이메일 클라이언트"]

아래 스크린샷은 alpine으로 표시되는 샘플 메시지입니다. 상황에 맞는 키보드 단축키는 화면 하단에 표시됩니다. 단축키의 한 예로 현재 표시 중인 메시지에 답장하도록 MUA에 지시하는 kbd:[r]을 들 수 있습니다.

image::pine4.png["이메일을 보여주는 alpine 이메일 클라이언트"]

alpine에서 이메일에 답장하는 것은 alpine과 함께 기본적으로 설치되어 있는 pico 편집기를 사용하여 수행됩니다. pico를 사용하면 메시지를 쉽게 탐색할 수 있으며, 초보자도 man:vi[1] 또는 man:mail[1]보다 쉽게 사용할 수 있습니다. 답장이 완료되면 kbd:[Ctrl+X]를 눌러 메시지를 전송할 수 있습니다. alpine은 메시지를 보내기 전에 확인을 요청합니다.

image::pine5.png["메시지 작성 창을 보여주는 alpine 이메일 클라이언트"]

alpine은 메인 메뉴의 [.guimenuitem]#SETUP# 옵션을 사용하여 사용자 지정할 수 있습니다. 자세한 내용은 http://www.washington.edu/alpine/[http://www.washington.edu/alpine/] 를 참조하세요.

[[mail-fetchmail]]
== fetchmail 사용하기

fetchmail은 모든 기능을 갖춘 IMAP 및 POP 클라이언트입니다. 이 클라이언트를 사용하면 원격 IMAP 및 POP 서버에서 메일을 자동으로 다운로드하여 로컬 사서함에 저장하여 보다 쉽게 액세스할 수 있습니다. fetchmail은 package:mail/fetchmail[] 포트를 사용하여 설치할 수 있으며 다음과 같은 다양한 기능을 제공합니다:

* POP3, APOP, KPOP, IMAP, ETRN 및 ODMR 프로토콜을 지원.
* 필터링, 전달 및 별칭 지정이 정상적으로 작동하는 SMTP를 사용하여 메일을 전달할 수 있는 기능.
* 데몬 모드에서 실행하여 주기적으로 새 메시지를 확인할 수 있음.
* 여러 개의 사서함을 검색하여 구성에 따라 다른 로컬 사용자에게 전달할 수 있음.

이 섹션에서는 fetchmail의 몇 가지 기본 기능에 대해 설명합니다. 이 유틸리티를 올바르게 실행하려면 사용자의 홈 디렉터리에 [.filename]#.fetchmailrc# 구성이 필요합니다. 이 파일에는 서버 정보와 로그인 자격 증명이 포함되어 있습니다. 이 파일 내용의 민감한 특성으로 인해 다음 명령을 사용하여 사용자만 읽을 수 있도록 설정하는 것이 좋습니다:

[source, shell]
....
% chmod 600 .fetchmailrc
....

다음 [.filename]#.fetchmailrc# 는 POP를 사용하여 단일 사용자 사서함을 다운로드하는 예제입니다. 이 예는 fetchmail이 사용자 이름 `joesoap` 과 비밀번호 `XXX` 를 사용하여 `example.com` 에 연결하도록 지시합니다. 이 예에서는 로컬 시스템에 사용자 `joesoap` 이 존재한다고 가정합니다.

[.programlisting]
....
poll example.com protocol pop3 username "joesoap" password "XXX"
....

다음 예는 여러 POP 및 IMAP 서버에 연결하고 해당되는 경우 다른 로컬 사용자 이름으로 리디렉션합니다:

[.programlisting]
....
poll example.com proto pop3:
user "joesoap", with password "XXX", is "jsoap" here;
user "andrea", with password "XXXX";
poll example2.net proto imap:
user "john", with password "XXXXX", is "myth" here;
....

fetchmail는 데몬 모드에서 `-d` 와 함께 실행한 다음 [.filename]#.fetchmailrc# 에 나열된 서버를 폴링(polling) 해야 하는 간격(초)을 지정하여 실행할 수 있습니다. 다음 예는 600초마다 폴링하도록 fetchmail을 구성합니다:

[source, shell]
....
% fetchmail -d 600
....

fetchmail에 대한 자세한 내용은 http://www.fetchmail.info/[http://www.fetchmail.info/] 에서 확인할 수 있습니다.

[[mail-procmail]]
== procmail 사용하기

procmail은 수신 메일을 필터링하는 데 사용되는 강력한 애플리케이션입니다. 사용자는 수신 메일과 일치하는 "규칙"을 정의하여 특정 기능을 수행하거나 대체 사서함 또는 이메일 주소로 메일을 다시 라우팅할 수 있습니다. procmail은 package:mail/procmail[] 포트를 사용하여 설치할 수 있습니다. 일단 설치되면 대부분의 MTA에 직접 통합할 수 있습니다. 자세한 내용은 MTA 설명서를 참조하세요. 또는 사용자의 홈 디렉터리에 있는 [.filename]#.forward# 에 다음 줄을 추가하여 procmail을 통합할 수도 있습니다:

[.programlisting]
....
"|exec /usr/local/bin/procmail || exit 75"
....

다음 섹션에서는 몇 가지 기본적인 프로메일 규칙과 그 기능에 대한 간략한 설명을 표시합니다. 규칙은 사용자의 홈 디렉터리에 있어야 하는 [.filename]#.procmailrc# 에 삽입해야 합니다.

이러한 규칙의 대부분은 man:procmailex[5]에서 찾을 수 있습니다.

mailto:user@example.com[user@example.com] 의 모든 메일을 mailto:goodmail@example2.com[goodmail@example2.com] 의 외부 주소로 전달합니다:

[.programlisting]
....
:0
* ^From.*user@example.com
! goodmail@example2.com
....

1000바이트보다 짧은 모든 메일을 mailto:goodmail@example2.com[goodmail@example2.com] 의 외부 주소로 전달합니다:

[.programlisting]
....
:0
* < 1000
! goodmail@example2.com
....

mailto:alternate@example.com[alternate@example.com] 로 보낸 모든 메일을 [.filename]#alternate# 라는 사서함으로 보내려면 다음과 같이 하세요:

[.programlisting]
....
:0
* ^TOalternate@example.com
alternate
....

제목이 "Spam" 인 모든 메일을 [.filename]#/dev/null# 로 보내려면 다음과 같이 하세요:

[.programlisting]
....
:0
^Subject:.*Spam
/dev/null
....

수신되는 `FreeBSD.org` 메일링 리스트를 구문 분석하고 각 목록을 자체 메일함에 배치하는 유용한 레시피입니다:

[.programlisting]
....
:0
* ^Sender:.owner-freebsd-\/[^@]+@FreeBSD.ORG
{
	LISTNAME=${MATCH}
	:0
	* LISTNAME??^\/[^@]+
	FreeBSD-${MATCH}
}
....
